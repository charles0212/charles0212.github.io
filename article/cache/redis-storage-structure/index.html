<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <title>
        
        Redis存储结构 |
        
        启航的蜗牛</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- open graph -->
    <meta name="description" content="前言  Redis 作为一款高性能数据库，表现在：它接收到一个键值对操作后， 能以微秒级别的速度找到数据，并快速完成操作。其高性能得奥秘来缘于以下两点：   * Redis 是内存数据库，    所有操作都在内存上完成，内存的访问速度本身就很快  * Reids    通过高效的数据结构来组织数据。  本章节可以让你在最短的时间了解如下内容：   * Redis 支持五大数据类型  * Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis存储结构">
<meta property="og:url" content="https://www.alicharles.com/article/cache/redis-storage-structure/index.html">
<meta property="og:site_name" content="启航的蜗牛">
<meta property="og:description" content="前言  Redis 作为一款高性能数据库，表现在：它接收到一个键值对操作后， 能以微秒级别的速度找到数据，并快速完成操作。其高性能得奥秘来缘于以下两点：   * Redis 是内存数据库，    所有操作都在内存上完成，内存的访问速度本身就很快  * Reids    通过高效的数据结构来组织数据。  本章节可以让你在最短的时间了解如下内容：   * Redis 支持五大数据类型  * Redis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648779832457-c09e705a-bf33-4cf0-b9b4-411792c87aef.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=566&id=u136f6d07&margin=%5Bobject%20Object%5D&name=image.png&originHeight=566&originWidth=1056&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=207909&status=done&style=none&taskId=u2ae3c090-ef92-4b9c-ad82-c7d159475cf&title=&width=1056">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648779889129-ec383f85-181f-4e98-b070-ba902f0d2c4d.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=692&id=ud220931d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=692&originWidth=794&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=250853&status=done&style=none&taskId=u0cdb692f-9f75-4de4-923a-68fc2d282e8&title=&width=794">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648779914591-e4c4c721-7f22-4a94-96bb-e424742d1f2a.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=650&id=ueecd49e3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=999&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=327606&status=done&style=none&taskId=u6dd9ec86-ebe2-484d-bb62-8c9dd78d3d8&title=&width=999">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780229010-3120360f-507a-4c46-b6e1-7b229dc38f13.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=156&id=ued930961&margin=%5Bobject%20Object%5D&name=image.png&originHeight=623&originWidth=1056&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=194203&status=done&style=none&taskId=ube66eb53-78ef-4e48-8235-458252f0166&title=&width=264">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780246131-132be37e-abc1-4b14-a54b-cbf87e1904a6.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=305&id=u6f02ecf5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=305&originWidth=994&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=151661&status=done&style=none&taskId=u5e069a5c-7cb4-4dad-a0b6-9223b3b09f1&title=&width=994">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780289412-e0046012-68e4-48e6-8bd4-3837c90d3a99.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=758&id=u00197c7c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=758&originWidth=1050&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=148199&status=done&style=none&taskId=uf419e644-49bb-4e7b-90f8-dd32520d17a&title=&width=1050">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780346574-992aa687-ba7f-4fc5-ad31-7556b50ad899.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=739&id=u2582c374&margin=%5Bobject%20Object%5D&name=image.png&originHeight=739&originWidth=1014&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=178694&status=done&style=none&taskId=u5fba1ee8-a340-49cf-9ece-0718c9677d0&title=&width=1014">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780372496-d0edb5de-d6a1-4de7-8539-820e2fb62b57.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=699&id=uc6849a5a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=699&originWidth=1142&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=274491&status=done&style=none&taskId=u5a96a5a3-c6af-4bad-a787-caf4933822a&title=&width=1142">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780382346-7e852ee4-6a21-4d27-9bee-5e4b5f0f9ace.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=399&id=u30fbfc37&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=1142&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=148863&status=done&style=none&taskId=ubd3f3538-7eb0-41a6-9354-20aa6f9f563&title=&width=1142">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780393549-1666cf4f-3954-424c-b1b6-662573a8a72a.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=650&id=ud3c02b32&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1142&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=215444&status=done&style=none&taskId=u615ac002-3f9e-46a4-a278-2287b313cdc&title=&width=1142">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780405398-4c31b4eb-f4a0-4f6a-8fd2-16ac48cb814f.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=399&id=uba73997a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=1142&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=146326&status=done&style=none&taskId=u96c32cac-6a3c-4c6e-a81a-1160217d084&title=&width=1142">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780423996-14ad8829-63a6-435c-8c73-28991bd46931.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=500&id=uf11ba9af&margin=%5Bobject%20Object%5D&name=image.png&originHeight=500&originWidth=1142&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=228581&status=done&style=none&taskId=uff6cd8ff-b47a-4ffe-a058-1560829d9b0&title=&width=1142">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780439047-c93a6e28-9ed3-4863-9cb7-028181e193df.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=653&id=u20485c50&margin=%5Bobject%20Object%5D&name=image.png&originHeight=653&originWidth=1146&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=280270&status=done&style=none&taskId=u3178c682-0adc-46b5-be58-814860e460e&title=&width=1146">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780454355-cbd5dd1a-727f-446f-b18f-36ca360171ae.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=u619cc6f5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=246&originWidth=1200&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=65335&status=done&style=none&taskId=u8488eda2-eb22-4b8f-a664-b88c7accfee&title=&width=1200">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780467106-0c83a678-28ed-47af-8672-316dd2d0d4d9.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=ua0fd48b0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=854&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=72717&status=done&style=none&taskId=u9939bcc3-55fa-490c-8987-15b181db90c&title=&width=854">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780486188-d17fc325-6f0d-442d-a36c-a200458f6ec1.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=380&id=u47fb909b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=1200&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=110718&status=done&style=none&taskId=ue9f201c5-e21b-4036-b0fe-6c19e2bbb89&title=&width=1200">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780502069-e09aedf4-9ee5-4c76-adbd-144055c2221a.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=339&id=u4cb75eb1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=339&originWidth=1060&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=108377&status=done&style=none&taskId=u45806980-2ab9-4b4c-856b-449384af80c&title=&width=1060">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780517323-ffa1704a-7d35-48ed-9332-39408e37262f.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=299&id=u51195243&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=1200&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=100794&status=done&style=none&taskId=u581807bc-fd85-4ec7-8792-62a10ca4b92&title=&width=1200">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780537452-e936d830-7f57-49df-adbc-69e5874c5849.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=550&id=ue6e6b33e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=550&originWidth=987&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=244526&status=done&style=none&taskId=u068db4c3-e323-4683-983e-26e2a3e5c04&title=&width=987">
<meta property="article:published_time" content="2021-06-22T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-02T16:49:05.000Z">
<meta property="article:author" content="charles">
<meta property="article:tag" content="Cache">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1648779832457-c09e705a-bf33-4cf0-b9b4-411792c87aef.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=566&id=u136f6d07&margin=%5Bobject%20Object%5D&name=image.png&originHeight=566&originWidth=1056&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=207909&status=done&style=none&taskId=u2ae3c090-ef92-4b9c-ad82-c7d159475cf&title=&width=1056">

    <link rel="icon" sizes="any" mask href="//cdn.alicharles.com/static/images/logo.svg">
    <link rel="stylesheet" href="//cdn.alicharles.com/static/css/bootstrap.css">  
    <link rel="stylesheet" href="//cdn.alicharles.com/static/css/style.css">   
    <link rel="stylesheet" href="//cdn.alicharles.com/static/lib/fontawesome/css/all.css">   
    <link rel="stylesheet" href="//cdn.alicharles.com/static/lib/prism/css/prism.css">   
    
    

<meta name="generator" content="Hexo 6.2.0"></head>


<body>

  <!-- Nav -->
  <header>
    <nav class="navbar navbar-expand-md navbar-light charles-navbar py-0">
        <div class="container">
            <a class="navbar-brand mr-0 mr-md-2" href="/">
                <img src="//cdn.alicharles.com/static/images/charles-logo.png" height="32px" width="80px" alt="charles">
            </a>
            <button class="navbar-toggler"
                    type="button"
                    data-bs-toggle="collapse"
                    data-bs-target="#navbarDropdown">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse justify-content-end" id="navbarDropdown">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="/">主页<span class="sr-only">(current)</span></a>
                    </li>
                    
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" data-toggle="dropdown" target="_blank">
                            推荐
                        </a>
                        <div class="dropdown-menu dropdown-menu-right mt-0" >
                            <div class="row mx-0" style="width: 16rem">
                                
                                
                                    
                                    
                                    <div class="col-sm " style="overflow: hidden;">
                                        
                                            <a class="nav-link" href="/categories/jvm/" target="_blank">JVM</a>
                                        
                                            <a class="nav-link" href="/categories/design-pattern/" target="_blank">设计模式</a>
                                        
                                            <a class="nav-link" href="/tags/Lock/" target="_blank">Java锁</a>
                                        
                                    </div>
                                    
                                    
                                
                                    
                                    
                                    <div class="col-sm  border-left " style="overflow: hidden;">
                                        
                                            <a class="nav-link" href="/categories/disruptor/" target="_blank">Disruptor</a>
                                        
                                            <a class="nav-link" href="/categories/netty/" target="_blank">Netty</a>
                                        
                                            <a class="nav-link" href="/categories/ddd/" target="_blank">领域驱动设计</a>
                                        
                                    </div>
                                    
                                    
                                
                            </div>
                        </div>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link" href="/categories" target="_blank">分类</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/tags" target="_blank">标签</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/archives" target="_blank">归档</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about" target="_blank">关于</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/search" target="_blank">搜索</a>
                    </li>
                </ul>
            </div>
        </div> <!-- /container -->
    </nav>
</header>


  <!-- Main Content -->
  <div class="container bg-white my-3">
    <div class="post-article">
        <section id="posts" class="posts-expand">
            <h1>Redis存储结构</h1>
<header class="post-header">
     <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="fa far fa-user"></i>
        </span>
        <span class="post-meta-item-text">发表于</span>
        <time itemprop="dateCreated" datetime="2021-06-23T00:00:00+08:00">
            2021-06-23
        </time>
    </span>
    <span class="post-category">
        
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="fa far fa-calendar-alt"></i>
        </span>
        <span class="post-meta-item-text">分类于</span>
        
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
            <a href="/categories/cache/" itemprop="url" rel="index">
              <span itemprop="name">cache</span>
            </a>
        </span>
        
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
            <a href="/categories/cache/redis/" itemprop="url" rel="index">
              <span itemprop="name">redis</span>
            </a>
        </span>
        
    
    </span>
</header>
<div class="post-body">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 作为一款高性能数据库，表现在：它接收到一个键值对操作后， 能以微秒级别的速度找到数据，并快速完成操作。其高性能得奥秘来缘于以下两点：</p>
<ul>
<li>Redis 是内存数据库， 所有操作都在内存上完成，内存的访问速度本身就很快</li>
<li>Reids 通过高效的数据结构来组织数据。</li>
</ul>
<p>本章节可以让你在最短的时间了解如下内容：</p>
<ul>
<li>Redis 支持五大数据类型</li>
<li>Redis 组织 Key-Value 数据结构</li>
<li>Redis5 大值类型数据存储结构</li>
</ul>
<h2 id="一、五大数据类型"><a href="#一、五大数据类型" class="headerlink" title="一、五大数据类型"></a>一、五大数据类型</h2><ul>
<li>String(字符串)</li>
<li>List(列表)</li>
<li>Set(集合)</li>
<li>Hash（哈希）</li>
<li>Zset（有序集合）</li>
</ul>
<h2 id="二、组织-Key-Value-数据结构"><a href="#二、组织-Key-Value-数据结构" class="headerlink" title="二、组织 Key-Value 数据结构"></a>二、组织 Key-Value 数据结构</h2><p>在 redis 中无论什么数据类型，在数据库中都是以 key-value 形式保存，通过进行对 Redis-key 的操作，来完成对数据库中数据的操作。</p>
<h3 id="全局哈希表"><a href="#全局哈希表" class="headerlink" title="全局哈希表"></a>全局哈希表</h3><p>为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。<br>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一 个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。<br>哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。在下图中，可以看到，_哈希桶中的 entry 元素中保存了 key 和_value 指针<strong>，分别指向了 实际的键和值<br>因为这个哈希表保存了所有的键值对，所以，我也把它称为</strong>全局哈希表**。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648779832457-c09e705a-bf33-4cf0-b9b4-411792c87aef.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=566&id=u136f6d07&margin=%5Bobject%20Object%5D&name=image.png&originHeight=566&originWidth=1056&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=207909&status=done&style=none&taskId=u2ae3c090-ef92-4b9c-ad82-c7d159475cf&title=&width=1056" alt="image.png"></p>
<h4 id="哈希表优势"><a href="#哈希表优势" class="headerlink" title="哈希表优势"></a>哈希表优势</h4><p>让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算 键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。这个查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说， 不管哈希表里有 10 万个键还是 100 万个键，我们只需要一次计算就能找到相应的键。</p>
<h4 id="哈希表劣势"><a href="#哈希表劣势" class="headerlink" title="哈希表劣势"></a>哈希表劣势</h4><p>当往哈希表写入大量数据后，就可能发现操作有时候会突然变慢了，这其实是因为你忽略了一个潜在 的风险点，那就是<strong>哈希冲突</strong>问题和 <strong>rehash</strong> 可能带来的操作阻塞。</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。<br>哈希冲突，也就是 指，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。毕竟，哈希桶的个数通常要少于 key 的数量，这也就是说，难免会有一些 key 的哈希值对 应到了同一个哈希桶中。</p>
<h4 id="链式哈希"><a href="#链式哈希" class="headerlink" title="链式哈希"></a>链式哈希</h4><p>链式哈希也很容易理解，就是指同一个哈希 桶中的多个元素用一个链表来保存，它们之间依次用指针连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648779889129-ec383f85-181f-4e98-b070-ba902f0d2c4d.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=692&id=ud220931d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=692&originWidth=794&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=250853&status=done&style=none&taskId=u0cdb692f-9f75-4de4-923a-68fc2d282e8&title=&width=794" alt="image.png"><br>如上图所示：entry1、entry2 和 entry3 都需要保存在哈希桶 3 中，导致了哈希冲突。此 时，entry1 元素会通 过一个_next 指针指向 entry2，同样，entry2 也会通过_next 指针 指向 entry3。这样一来，即使哈希桶 3 中的元素有 100 个，我们也可以通过 entry 元素 中的指针，把它们连起来。这就形成了一个链表，也叫作哈希冲突链。</p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>哈希冲突链上的元素只能通过指针逐一查找再操作。如果 哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链 过长，进而导致这个链上的元素查找耗时长，效率降低。<br>Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐 增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个 桶中的冲突。</p>
<h4 id="简单-rehash"><a href="#简单-rehash" class="headerlink" title="简单 rehash"></a>简单 rehash</h4><p>为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希 表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空 间。随着数据逐步增多，Redis 开始执行 rehash,这个过程分为三步：</p>
<ul>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中</li>
<li>释放哈希表 1 的空间</li>
</ul>
<p>到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来 的哈希表 1 留作下一次 rehash 扩容备用。（有点类似 JVM 年轻代复制回收）</p>
<h4 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h4><p>简单 rehash 过程中最大的问题在于第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都 迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据 了。为了避免这个问题，Redis 采用了渐进式 rehash。<br>渐进式 rehash 简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求 时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝 到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。<br>这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操 作，保证了数据的快速访问。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648779914591-e4c4c721-7f22-4a94-96bb-e424742d1f2a.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=650&id=ueecd49e3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=999&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=327606&status=done&style=none&taskId=u6dd9ec86-ebe2-484d-bb62-8c9dd78d3d8&title=&width=999" alt="image.png"></p>
<h3 id="内存使用大小"><a href="#内存使用大小" class="headerlink" title="内存使用大小"></a>内存使用大小</h3><p>哈希表的每一项是 一个 dictEntry 的结构体，用来指向一个键值对。dictEntry 结构中有三个 8 字节的指针， 分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节。<br>但这里需要注意的是这里 Redis 使用的内 存分配库 jemalloc 了。<br>jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。<br>举个例子。如果你申请 6 字节空间，jemalloc 实际会分配 8 字节空间；如果你申请 24 字 节空间，jemalloc 则会分配 32 字节。所以，在我们刚刚说的场景里，<strong>dictEntry 结构就占 用了 32 字节</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780229010-3120360f-507a-4c46-b6e1-7b229dc38f13.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=156&id=ued930961&margin=%5Bobject%20Object%5D&name=image.png&originHeight=623&originWidth=1056&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=194203&status=done&style=none&taskId=ube66eb53-78ef-4e48-8235-458252f0166&title=&width=264" alt="image.png"></p>
<h2 id="三、不同数据类型存储结构"><a href="#三、不同数据类型存储结构" class="headerlink" title="三、不同数据类型存储结构"></a>三、不同数据类型存储结构</h2><p>Redis 底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈 希表、跳表和整数数组。它们和数据类型的对应关系如下图所示<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780246131-132be37e-abc1-4b14-a54b-cbf87e1904a6.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=305&id=u6f02ecf5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=305&originWidth=994&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=151661&status=done&style=none&taskId=u5e069a5c-7cb4-4dad-a0b6-9223b3b09f1&title=&width=994" alt="image.png"></p>
<h3 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h3><p>Redis String 类型就会用简单动态字符串（Simple Dynamic String，SDS）结构体来保存。</p>
<h4 id="Redis-SDS-数据结构"><a href="#Redis-SDS-数据结构" class="headerlink" title="Redis SDS 数据结构"></a>Redis SDS 数据结构</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780289412-e0046012-68e4-48e6-8bd4-3837c90d3a99.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=758&id=u00197c7c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=758&originWidth=1050&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=148199&status=done&style=none&taskId=uf419e644-49bb-4e7b-90f8-dd32520d17a&title=&width=1050" alt="image.png"></p>
<h5 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h5><p>Redis 简单字符串可以存储数据类型有很多，而且，不同数据类型都有些相同的元数据要记录，这其中包括：</p>
<ul>
<li>最后一次访问的时间</li>
<li>被引用的次数</li>
<li>….</li>
</ul>
<p>其中元数据占用 8 个字节。</p>
<h5 id="PRT"><a href="#PRT" class="headerlink" title="PRT"></a>PRT</h5><p>表示一个指针，指针再进一步指向具体 数据类型的实际数据所在。如果存储类型是 String 类型，那么指针指向的是的 SDS 结构所在的内存地址。<br>其中 PRT 指针占用 8 个字节。</p>
<h5 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h5><p>SDS 存储结构负责存储具体数据。其中包括了三层结构：</p>
<h6 id="buf"><a href="#buf" class="headerlink" title="buf"></a>buf</h6><ul>
<li>字节数组，保存实际数据。</li>
<li>为了表示字节数组的结束，Redis 会自动在数组最后加 一个“\0”，这就会额外占用 1 个字节的开销。</li>
</ul>
<h6 id="len"><a href="#len" class="headerlink" title="len"></a>len</h6><ul>
<li>占 4 个字节，表示 buf 的已用长度。</li>
</ul>
<h6 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h6><ul>
<li>也占个 4 字节，表示 buf 的实际分配长度，一般大于 len。</li>
</ul>
<p>[图片上传失败…(image-ec3716-1611492954707)]</p>
<h4 id="Redis-SDS-内存优化"><a href="#Redis-SDS-内存优化" class="headerlink" title="Redis SDS 内存优化"></a>Redis SDS 内存优化</h4><p>为了节省内存空间，Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计。</p>
<h5 id="Long-类型整数"><a href="#Long-类型整数" class="headerlink" title="Long 类型整数"></a>Long 类型整数</h5><p>当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据 了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。</p>
<h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><h6 id="当字符串小于-44-字节时"><a href="#当字符串小于-44-字节时" class="headerlink" title="当字符串小于 44 字节时"></a>当字符串小于 44 字节时</h6><p>RedisObject 中的元 数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被 称为 embstr 编码方式。</p>
<h6 id="当字符串大于-44-字节时"><a href="#当字符串大于-44-字节时" class="headerlink" title="当字符串大于 44 字节时"></a>当字符串大于 44 字节时</h6><p>SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。 这种布局方式被称为 raw 编码模式。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780346574-992aa687-ba7f-4fc5-ad31-7556b50ad899.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=739&id=u2582c374&margin=%5Bobject%20Object%5D&name=image.png&originHeight=739&originWidth=1014&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=178694&status=done&style=none&taskId=u5fba1ee8-a340-49cf-9ece-0718c9677d0&title=&width=1014" alt="image.png"></p>
<h4 id="Redis-SDS-优势"><a href="#Redis-SDS-优势" class="headerlink" title="Redis SDS 优势"></a>Redis SDS 优势</h4><p>SDS 这种数据结构相对于 C 字符串有以下优点：</p>
<ul>
<li>杜绝缓冲区溢出</li>
<li>减少字符串操作中的内存重分配次数</li>
<li>二进制安全</li>
<li>由于 SDS 遵循以空字符结尾的惯例，因此兼容部门 C 字符串函数</li>
</ul>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><table><thead><tr>
<th>操作</th>
<th>时间复杂度</th>
</tr>
</thead><tbody><tr>
<td>获取 SDS 长度</td>
<td>由于 SDS 中提供了 len 属性，因此我们可以直接获取时间复杂度为 O(1),C 字符串为 O(n)。</td>
</tr>
<tr>
<td>获取 SDS 未使用空间长度</td>
<td>O(1)</td>
</tr>
<tr>
<td>清除 SDS 保存的内容</td>
<td>由于惰性分配策略，O(1)</td>
</tr>
<tr>
<td>创建一个长度为 N 字符串</td>
<td>O(n)</td>
</tr>
<tr>
<td>拼接一个长度为 N 的 C 字符串</td>
<td>O(n)</td>
</tr>
<tr>
<td>拼接一个长度为 N 的 SDS 字符串</td>
<td>O(n)</td>
</tr>
</tbody></table><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><h4 id="数据结构-链表"><a href="#数据结构-链表" class="headerlink" title="数据结构-链表"></a>数据结构-链表</h4><p>相比数组，链表是一种稍微复杂一点的数据结构。数组需要一块连续的内存空间来存储，对内存的要求比较高。而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780372496-d0edb5de-d6a1-4de7-8539-820e2fb62b57.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=699&id=uc6849a5a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=699&originWidth=1142&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=274491&status=done&style=none&taskId=u5a96a5a3-c6af-4bad-a787-caf4933822a&title=&width=1142" alt="image.png"><br>链表结构五花八门，其中三种最常见的链表结构，它们分别是：<strong>单链表</strong>、<strong>双向链表</strong>和<strong>循环链表</strong>。</p>
<h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作后继指针 next。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780382346-7e852ee4-6a21-4d27-9bee-5e4b5f0f9ace.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=399&id=u30fbfc37&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=1142&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=148863&status=done&style=none&taskId=ubd3f3538-7eb0-41a6-9354-20aa6f9f563&title=&width=1142" alt="image.png"><br>其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。</p>
<h6 id="插入-amp-删除"><a href="#插入-amp-删除" class="headerlink" title="插入&amp;删除"></a>插入&amp;删除</h6><p>而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780393549-1666cf4f-3954-424c-b1b6-662573a8a72a.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=650&id=ud3c02b32&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1142&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=215444&status=done&style=none&taskId=u615ac002-3f9e-46a4-a278-2287b313cdc&title=&width=1142" alt="image.png"></p>
<h6 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h6><p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点<br>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</p>
<h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><p>循环链表是一种特殊的单链表。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780405398-4c31b4eb-f4a0-4f6a-8fd2-16ac48cb814f.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=399&id=uba73997a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=1142&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=146326&status=done&style=none&taskId=u96c32cac-6a3c-4c6e-a81a-1160217d084&title=&width=1142" alt="image.png"></p>
<p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。</p>
<h5 id="双向链表-1"><a href="#双向链表-1" class="headerlink" title="双向链表"></a>双向链表</h5><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p>
<h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><p>双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。如删除某个结点 q 需要知道其前驱结点<br><strong>删除某个结点前驱结点</strong><br>我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next&#x3D;q，说明 p 是 q 的前驱结点。但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针， 不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了。<br><strong>某个指定结点前面插入</strong><br>同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。<br><strong>查询某个节点</strong><br>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。<br>Java 语言，你肯定用过 LinkedHashMap 这个容器。如果你深入研究 LinkedHashMap 的实现原理，就会发现其中就用到了双向链表这种数据结构。</p>
<h6 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h6><p>这里有一个更加重要的知识点需要你掌握，那就是用空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p>
<h5 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780423996-14ad8829-63a6-435c-8c73-28991bd46931.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=500&id=uf11ba9af&margin=%5Bobject%20Object%5D&name=image.png&originHeight=500&originWidth=1142&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=228581&status=done&style=none&taskId=uff6cd8ff-b47a-4ffe-a058-1560829d9b0&title=&width=1142" alt="image.png"></p>
<h5 id="链表-VS-数组性能"><a href="#链表-VS-数组性能" class="headerlink" title="链表 VS 数组性能"></a>链表 VS 数组性能</h5><p>数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p>
<h6 id="数组优势"><a href="#数组优势" class="headerlink" title="数组优势"></a><strong>数组优势</strong></h6><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p>
<h6 id="数组劣势"><a href="#数组劣势" class="headerlink" title="数组劣势"></a><strong>数组劣势</strong></h6><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p>
<h6 id="取舍"><a href="#取舍" class="headerlink" title="取舍"></a><strong>取舍</strong></h6><p>如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p>
<h4 id="Redis-链表结构"><a href="#Redis-链表结构" class="headerlink" title="Redis 链表结构"></a>Redis 链表结构</h4><p>Redis 链表使用双向链表结构<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780439047-c93a6e28-9ed3-4863-9cb7-028181e193df.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=653&id=u20485c50&margin=%5Bobject%20Object%5D&name=image.png&originHeight=653&originWidth=1146&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=280270&status=done&style=none&taskId=u3178c682-0adc-46b5-be58-814860e460e&title=&width=1146" alt="image.png"></p>
<ul>
<li>双向：链表节点带有前驱、后继指针获取某个节点的前驱、后继节点的时间复杂度为 0(1)。</li>
<li>无环: 链表为非循环链表表头节点的前驱指针和表尾节点的后继指针都指向 NULL，对链表的访问以 NULL 为终点。</li>
<li>带表头指针和表尾指针：通过 list 结构中的 head 和 tail 指针，获取表头和表尾节点的时间复杂度都为 O(1)。</li>
<li>带链表长度计数器:通过 list 结构的 len 属性获取节点数量的时间复杂度为 O(1)。</li>
<li>多态：链表节点使用 void*指针保存节点的值，并且可以通过 list 结构的 dup、free、match 三个属性为节点值设置类型特定函数，所以链表可以用来保存各种不同类型的值。</li>
</ul>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表(zip1ist)是列表和哈希的底层实现之一。</p>
<ul>
<li>当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么 Redis 就会使用压缩列表来做列表的底层实现。</li>
<li>当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么 Redis 就会使用压缩列表来做哈希的底层实现。</li>
</ul>
<h4 id="数据结构-压缩列表"><a href="#数据结构-压缩列表" class="headerlink" title="数据结构-压缩列表"></a>数据结构-压缩列表</h4><p>听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存,是相较于数组的存储思路而言的。我们知道,数组要求每个元素的大小相同,如果我们要存储不同长度的字符串,那我们就需要用最大长度的字符串大小作为元素的大小(假设是 20 个字节)。存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780454355-cbd5dd1a-727f-446f-b18f-36ca360171ae.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=246&id=u619cc6f5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=246&originWidth=1200&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=65335&status=done&style=none&taskId=u8488eda2-eb22-4b8f-a664-b88c7accfee&title=&width=1200" alt="image.png"><br>数组的优势占用一片连续的空间可以很好的利用 CPU 缓存访问数据。如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780467106-0c83a678-28ed-47af-8672-316dd2d0d4d9.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=ua0fd48b0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=854&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=72717&status=done&style=none&taskId=u9939bcc3-55fa-490c-8987-15b181db90c&title=&width=854" alt="image.png"><br>是这样有一个问题，我们在遍历它的时候由于不知道每个元素的大小是多少，因此也就无法计算出下一个节点的具体位置。这个时候我们可以给每个节点增加一个 lenght 的属性。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780486188-d17fc325-6f0d-442d-a36c-a200458f6ec1.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=380&id=u47fb909b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=1200&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=110718&status=done&style=none&taskId=ue9f201c5-e21b-4036-b0fe-6c19e2bbb89&title=&width=1200" alt="image.png"><br>如此。我们在遍历节点的之后就知道每个节点的长度(占用内存的大小)，就可以很容易计算出下一个节点再内存中的位置。这种结构就像一个简单的压缩列表了。</p>
<h4 id="Redis-压缩列表结构"><a href="#Redis-压缩列表结构" class="headerlink" title="Redis 压缩列表结构"></a>Redis 压缩列表结构</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780502069-e09aedf4-9ee5-4c76-adbd-144055c2221a.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=339&id=u4cb75eb1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=339&originWidth=1060&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=108377&status=done&style=none&taskId=u45806980-2ab9-4b4c-856b-449384af80c&title=&width=1060" alt="image.png"></p>
<h5 id="zlbytes"><a href="#zlbytes" class="headerlink" title="zlbytes"></a>zlbytes</h5><ul>
<li>记录整个压缩列表占用的内存字节数；</li>
<li>在对压缩列表进行重新内存分配，或者计算 zlleng 的位置时使用；</li>
<li>占用 4 个字节；</li>
</ul>
<h5 id="zltail"><a href="#zltail" class="headerlink" title="zltail"></a>zltail</h5><ul>
<li>记录压缩列表表尾节点(entryN)起始偏移量距离压缩列表的起始地址有多少字节；</li>
<li>通过这个偏移量，程序无须遍历整个压缩列表就可以确认压缩列表尾节点的地址；</li>
<li>占用 4 个字节；</li>
</ul>
<h5 id="zllen"><a href="#zllen" class="headerlink" title="zllen"></a>zllen</h5><ul>
<li>记录压缩列表包含了节点(entryN)数量；</li>
<li>当这个属性的小于 65535 时，这个属性的值就是压缩列表包含节点的数量；</li>
<li>当这个属性的大于等于 65535 时，节点的真实数量需要遍历整个压缩列表才能计算获得；</li>
<li>占用 2 个字节；</li>
</ul>
<h5 id="zlend"><a href="#zlend" class="headerlink" title="zlend"></a>zlend</h5><ul>
<li>特殊值 OxFF,用于记录压缩列表的未端；</li>
<li>占用 1 个字节；</li>
</ul>
<h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><p><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780517323-ffa1704a-7d35-48ed-9332-39408e37262f.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=299&id=u51195243&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=1200&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=100794&status=done&style=none&taskId=u581807bc-fd85-4ec7-8792-62a10ca4b92&title=&width=1200" alt="image.png"></p>
<ul>
<li>zllen 表示当前压缩列表有 3 个节点；</li>
<li>zltail 表示压缩列表表尾节点(entryN)起始偏移量距离压缩列表的起始地址有 60 个字节，因此如果表示 P 指向了压缩列表开始偏移量，那么 entry3 节点开始偏移量为 P+60；</li>
<li>zlbytes 表示整个压缩列表占用的内存字节数，因此通过计算可以知道 entry3 大小为 19&#x3D;80-60-1；</li>
</ul>
<h5 id="entry-数据结构"><a href="#entry-数据结构" class="headerlink" title="entry 数据结构"></a>entry 数据结构</h5><p>列表节点</p>
<h6 id="prev-len"><a href="#prev-len" class="headerlink" title="prev_len"></a>prev_len</h6><p>表示前一个 entry 的长度。<br><strong>表示上一个 entry 的长度小于 254 字节</strong></p>
<ul>
<li>占用 1 字节</li>
<li>前一节点的长度就保存在这一个字节里面</li>
</ul>
<p><strong>表示上一个 entry 的长度大于 254 字节</strong></p>
<ul>
<li>占用 5 字节</li>
<li>第一字节会被设置为 0xFE</li>
<li>之后的四个字节则用于保存前一节点的长度</li>
</ul>
<h6 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h6><ul>
<li>表示数据的类型和长度</li>
<li>占用 1 字节</li>
</ul>
<h6 id="len-1"><a href="#len-1" class="headerlink" title="len"></a>len</h6><ul>
<li>表示自身长度</li>
<li>占用 4 字节</li>
</ul>
<h6 id="key"><a href="#key" class="headerlink" title="key"></a>key</h6><ul>
<li>保存实际数据</li>
</ul>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><table><thead><tr>
<th>操作</th>
<th>时间复杂度</th>
</tr>
</thead><tbody><tr>
<td>创建一个压缩列表</td>
<td>O(1)</td>
</tr>
<tr>
<td>创建一个包含给定值的新节点，并将这个新节点添加到压缩列表的表头或者表尾</td>
<td>平均 O(N),最坏 O(N^2)(可能发生连锁更新)</td>
</tr>
<tr>
<td>将包含给定值的新节点插入到给定节点之后</td>
<td>平均 O(N),最坏 O(N^2)(可能发生连锁更新</td>
</tr>
<tr>
<td>返回压缩列表给定索引上的节点</td>
<td>O(N)</td>
</tr>
<tr>
<td>在压缩列表中查找并返回包含了给定值的节点</td>
<td>因为节点的值可能是一个字节数组，所以检查节点值和给定值是否相同的复杂度为 O(N)，而查找整个泪飙的复杂度则(N^2)</td>
</tr>
<tr>
<td>返回给定节点的下一个节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>返回给定节点的前一个节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>获取给定节点所保存的值</td>
<td>O(1)</td>
</tr>
<tr>
<td>从压缩列表中删除给定的节点</td>
<td>平均 O(N),最坏 O(N^2)(可能发生连锁更新</td>
</tr>
<tr>
<td>删除压缩列表在给定索引上的连续多个</td>
<td>平均 O(N),最坏 O(N^2)(可能发生连锁更新</td>
</tr>
<tr>
<td>返回压缩列表目前占用的内存字节数</td>
<td>O(1)</td>
</tr>
<tr>
<td>返回压缩列表目前包含的节点数量</td>
<td>点数量小于 65535 时为 O(1)，大于 65535 时为 O(N)</td>
</tr>
</tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1648780537452-e936d830-7f57-49df-adbc-69e5874c5849.png#clientId=u7897f90e-c8d9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=550&id=ue6e6b33e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=550&originWidth=987&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=244526&status=done&style=none&taskId=u068db4c3-e323-4683-983e-26e2a3e5c04&title=&width=987" alt="image.png"></p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><h3 id="整数数组"><a href="#整数数组" class="headerlink" title="整数数组"></a>整数数组</h3><h3 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h3><p>集合类型的操作类型很多，有读写单个集合元素的，例如 HGET、HSET，也有操作多个元 素的，例如 SADD，还有对整个集合进行遍历操作的，例如 SMEMBERS。这么多操作， 它们的复杂度也各不相同。而复杂度的高低又是我们选择集合类型的重要依据。<br>我总结了一个“四句口诀”，希望能帮助你快速记住集合常见操作的复杂度。这样你在使 用过程中，就可以提前规避高复杂度操作了</p>
<ul>
<li>单元素操作是基础；</li>
<li>范围操作非常耗时；</li>
<li>统计操作通常高效；</li>
<li>例外情况只有几个。</li>
</ul>
<h5 id="单元素操作"><a href="#单元素操作" class="headerlink" title="单元素操作"></a>单元素操作</h5><p>第一，<strong>单元素操作，是指每一种集合类型对单个数据实现的增删改查操作</strong>。例如，Hash 类 型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。<strong>这些操 作的复杂度由集合采用的数据结构决定</strong>，例如，HGET、HSET 和 HDEL 是对哈希表做操 作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、 SREM、SRANDMEMBER 复杂度也是 O(1)。<br>这里，有个地方你需要注意一下，集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操 作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元 素时，复杂度就从 O(1) 变成 O(M) 了。</p>
<h5 id="范围操作"><a href="#范围操作" class="headerlink" title="范围操作"></a>范围操作</h5><p>第二，<strong>范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据</strong>，比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。<strong>这类操作的复杂度一般是 O(N)，比较耗时， 我们应该尽量避免</strong>。<br>不过，Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻 塞。</p>
<h5 id="统计操作"><a href="#统计操作" class="headerlink" title="统计操作"></a>统计操作</h5><p>第三，统计操作，是指<strong>集合类型对集合中所有元素个数的记录</strong>，例如 LLEN 和 SCARD。这 类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数 据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</p>
<h5 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h5><p>第四，例外情况，是指某些数据结构的特殊记录，例如<strong>压缩列表和双向链表都会记录表头 和表尾的偏移量</strong>。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操 作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂 度也只有 O(1)，可以实现快速操作</p>
<h2 id="四、经典案例"><a href="#四、经典案例" class="headerlink" title="四、经典案例"></a>四、经典案例</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>当时，我们要开发一个图片存储系统，要求这个系统能快速地记录图片 ID 和图片在存储系 统中保存时的 ID（可以直接叫作图片存储对象 ID）。同时，还要能够根据图片 ID 快速查 找到图片存储对象 ID。<br>因为图片数量巨大，所以我们就用 10 位数来表示图片 ID 和图片存储对象 ID，例如，图片 ID 为 1101000051，它在存储系统中对应的 ID 号是 3301000051。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">photo_id: 1101000051
photo_obj_id: 3301000051</code></pre>

<p>可以看到，图片 ID 和图片存储对象 ID 正好一一对应，是典型的“键 - 单值”模式。所谓 的“单值”，就是指键值对中的值就是一个值，而不是一个集合，这和 String 类型提供 的“一个键对应一个值的数据”的保存形式刚好契合。</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><h4 id="使用-String-类型"><a href="#使用-String-类型" class="headerlink" title="使用 String 类型"></a>使用 String 类型</h4><p>使用 String 保存数据。我们把图片 ID 和图片存储对象 ID 分别 作为键值对的 key 和 value 来保存，其中，图片存储对象 ID 用了 String 类型。</p>
<h4 id="String-类型内存开销大"><a href="#String-类型内存开销大" class="headerlink" title="String 类型内存开销大"></a>String 类型内存开销大</h4><p>随着图片数据量的不断 增加，我们的 Redis 内存使用量也在增加，结果就遇到了大内存 Redis 实例因为生成 RDB 而响应变慢的问题。<br>当我们使用 String 类型时，除了记录实际数据，String 类型还需要额外的内存空间记录数据长度、空间使用等 信息，这些信息也叫作元数据。当实际保存的数据较小时，元数据的空间开销就显得比较 大了，有点“喧宾夺主”的意思。</p>
<ul>
<li>1 亿张图片的信息，用了约 6.4GB 的内存，一个图片 ID 和 图片存储对象 ID 的记录平均用了 64 字节。</li>
<li>但问题是，一组图片 ID 及其存储对象 ID 的记录，实际只需要 16 字节就可以了。</li>
</ul>
<h4 id="计算-String-内存大小"><a href="#计算-String-内存大小" class="headerlink" title="计算 String 内存大小"></a>计算 String 内存大小</h4><p>因为 10 位数的图片 ID 和图片存储对象 ID 是 Long 类型整数，所以可以直接用 int 编码 的 RedisObject 保存<br>根据下图计算一共 64 字节。</p>
<table><thead><tr>
<th>结构</th>
<th>大小</th>
</tr>
</thead><tbody><tr>
<td>key-value 哈希表 dictEntry</td>
<td>32 字节</td>
</tr>
<tr>
<td>图片 ID 简单字符串 SDS 元数据</td>
<td>8 字节</td>
</tr>
<tr>
<td>图片 ID 简单字符串 PRT</td>
<td>8 字节</td>
</tr>
<tr>
<td>图片存储对象 ID 简单字符串 SDS 元数据</td>
<td>8 字节</td>
</tr>
<tr>
<td>图片 ID 简单字符串 PRT 简单字符串 PRT</td>
<td>8 字节</td>
</tr>
</tbody></table>
</div>
<footer class="post-meta">
    <span class="post-tag">
        
        <span class="post-meta-item-icon">
                <i class="fa far fa-folder-open"></i>
            </span>
        
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                <a href="/tags/Cache/" itemprop="url" rel="index">
                  <span itemprop="name">Cache</span>
                </a>
            </span>
        
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                <a href="/tags/Redis/" itemprop="url" rel="index">
                  <span itemprop="name">Redis</span>
                </a>
            </span>
        
        
    </span>
</footer>

<div class="author">
    <!--个人信息-->
    
    <img class="author-image qrcode" itemprop="image"
         src="https://cdn.alicharles.com/static/images/mp_qrcode.jpg"
         alt="https://cdn.alicharles.com/static/images/mp_qrcode.jpg"/>
    
</div>


<div class="post-nav">
    <div class="post-nav-next post-nav-item">
        
        <a href="/article/hbase/hbase-architecture/" rel="next" title="HBase 系统架构">
            <i class="fa far fa-chevron-left"></i> HBase 系统架构
        </a>
        
    </div>
    <span class="post-nav-divider"></span>
    <div class="post-nav-prev post-nav-item">
        
        <a href="/article/hbase/hbase-lsm/" rel="prev" title="HBase（三）LSM树">
            HBase（三）LSM树 <i class="fa far fa-chevron-right"></i>
        </a>
        
    </div>
</div>

        </section>
    </div>
    <div id="post-toc" class="post-toc">
        <div class="post-toc-title">文章目录</div>
        <div class="post-toc-content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">一、五大数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BB%84%E7%BB%87-Key-Value-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">二、组织 Key-Value 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">全局哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BC%98%E5%8A%BF"><span class="toc-text">哈希表优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%8A%A3%E5%8A%BF"><span class="toc-text">哈希表劣势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-text">哈希冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%93%88%E5%B8%8C"><span class="toc-text">链式哈希</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash"><span class="toc-text">rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95-rehash"><span class="toc-text">简单 rehash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F-rehash"><span class="toc-text">渐进式 rehash</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%B0%8F"><span class="toc-text">内存使用大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">三、不同数据类型存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88SDS%EF%BC%89"><span class="toc-text">简单动态字符串（SDS）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-SDS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">Redis SDS 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">元数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PRT"><span class="toc-text">PRT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SDS"><span class="toc-text">SDS</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#buf"><span class="toc-text">buf</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#len"><span class="toc-text">len</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#alloc"><span class="toc-text">alloc</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-SDS-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-text">Redis SDS 内存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Long-%E7%B1%BB%E5%9E%8B%E6%95%B4%E6%95%B0"><span class="toc-text">Long 类型整数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-text">字符串类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%93%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%8F%E4%BA%8E-44-%E5%AD%97%E8%8A%82%E6%97%B6"><span class="toc-text">当字符串小于 44 字节时</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%93%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E4%BA%8E-44-%E5%AD%97%E8%8A%82%E6%97%B6"><span class="toc-text">当字符串大于 44 字节时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-SDS-%E4%BC%98%E5%8A%BF"><span class="toc-text">Redis SDS 优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8"><span class="toc-text">数据结构-链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-amp-%E5%88%A0%E9%99%A4"><span class="toc-text">插入&amp;删除</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-text">查询</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-1"><span class="toc-text">双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-text">优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-text">设计思想</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">双向循环链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8-VS-%E6%95%B0%E7%BB%84%E6%80%A7%E8%83%BD"><span class="toc-text">链表 VS 数组性能</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BC%98%E5%8A%BF"><span class="toc-text">数组优势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8A%A3%E5%8A%BF"><span class="toc-text">数组劣势</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%96%E8%88%8D"><span class="toc-text">取舍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-text">Redis 链表结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-text">压缩列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-text">数据结构-压缩列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-text">Redis 压缩列表结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#zlbytes"><span class="toc-text">zlbytes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#zltail"><span class="toc-text">zltail</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#zllen"><span class="toc-text">zllen</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#zlend"><span class="toc-text">zlend</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90"><span class="toc-text">举个栗子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#entry-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">entry 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#prev-len"><span class="toc-text">prev_len</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#encoding"><span class="toc-text">encoding</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#len-1"><span class="toc-text">len</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#key"><span class="toc-text">key</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-text">跳表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84"><span class="toc-text">整数数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">不同操作的复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-text">单元素操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%93%8D%E4%BD%9C"><span class="toc-text">范围操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%93%8D%E4%BD%9C"><span class="toc-text">统计操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%A4%96%E6%83%85%E5%86%B5"><span class="toc-text">例外情况</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B"><span class="toc-text">四、经典案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80"><span class="toc-text">方案一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-String-%E7%B1%BB%E5%9E%8B"><span class="toc-text">使用 String 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98%E5%BC%80%E9%94%80%E5%A4%A7"><span class="toc-text">String 类型内存开销大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97-String-%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-text">计算 String 内存大小</span></a></li></ol></li></ol></li></ol>
        </div>
    </div>
    
</div>

  <!-- footer -->
  <div class="footer">
    <div class="container justify-content-center py-4">
        Charles &copy;2022 &nbsp <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备14035515号-1</a></span> &nbsp
        <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253510913'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1253510913%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
    </div>

    <!-- scrollTop -->
    <div class="go-top">
        <i class="fas fa-arrow-up"></i>
    </div>

    <!-- js -->
    <script src="//cdn.alicharles.com/static/lib/jquery/jquery.min.js"></script>
    <script src="//cdn.alicharles.com/static/lib/popper.js/popper.js"></script>
    <script src="//cdn.alicharles.com/static/lib/bootstrap/js/bootstrap.min.js"></script>
    <script src="//cdn.alicharles.com/static/lib/prism/js/prism.js"></script>
    <script src="//cdn.alicharles.com/static/js/app.js"></script>

    
</div>
</body>

</html>
