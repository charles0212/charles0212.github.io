<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <title>
        
        架构（三）通用可编排订单状态机引擎设计 |
        
        启航的蜗牛</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- open graph -->
    <meta name="description" content="&gt; 简介： &gt; 订单状态流转是交易系统的最为核心的工作，订单系统往往都会存在状态多、链路长、逻辑复杂的特点，还存在多场景、多类型、多业务维度等业务特性。在保证订单状态流转稳定性的前提下、可扩展性和可维护性是我们需要重点关注和解决的问题。     一、背景  订单状态流转是交易系统的最为核心的工作，订单系统往往都会存在状态多、链路长、逻辑复杂的特点，还存在多场景、多类型、多业务维度等业务特性。在保证">
<meta property="og:type" content="article">
<meta property="og:title" content="架构（三）通用可编排订单状态机引擎设计">
<meta property="og:url" content="https://www.alicharles.com/article/architecture/architecture-order-fsm/index.html">
<meta property="og:site_name" content="启航的蜗牛">
<meta property="og:description" content="&gt; 简介： &gt; 订单状态流转是交易系统的最为核心的工作，订单系统往往都会存在状态多、链路长、逻辑复杂的特点，还存在多场景、多类型、多业务维度等业务特性。在保证订单状态流转稳定性的前提下、可扩展性和可维护性是我们需要重点关注和解决的问题。     一、背景  订单状态流转是交易系统的最为核心的工作，订单系统往往都会存在状态多、链路长、逻辑复杂的特点，还存在多场景、多类型、多业务维度等业务特性。在保证">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122547682-625bb362-4995-48b1-80c1-a04a247ddc03.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=352&id=u0cb29d2e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=639&originWidth=1024&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=1040780&status=done&style=none&taskId=u038939a2-db37-4232-b314-306f47aca40&title=&width=564">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122546005-0543cc56-7641-4acb-825b-486786885810.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0a5c3acf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=457&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=130195&status=done&style=none&taskId=u63891d7e-3007-407c-8181-a4edeecd2a6&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122546581-7d7979fe-5da4-49fc-be45-abe3092389a8.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue0b046c3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=699&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=202124&status=done&style=none&taskId=u3f55da17-bc19-418d-9cae-4f32b0b3828&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122545954-f48261ba-a341-4bc7-bd8c-60382122a914.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uefd9681a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=232&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=79645&status=done&style=none&taskId=u8061e814-8311-4556-9849-f13b6a73b20&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122546996-7f5e6ed2-0521-4dcd-986d-a2c8d6427ae2.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u828ac9b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=761&originWidth=998&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=307486&status=done&style=none&taskId=u46c03995-c47a-4f6e-97a0-d21f36caf6b&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122547582-44a5d079-02f2-4ff4-bc30-9ac119d6585d.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u69f91899&margin=%5Bobject%20Object%5D&name=image.png&originHeight=480&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=211547&status=done&style=none&taskId=u15f56b94-e8ec-493a-89c5-e11e3a33ddf&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122547541-bb17dc47-8c23-4c72-9a19-f419772c7af1.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8de51909&margin=%5Bobject%20Object%5D&name=image.png&originHeight=425&originWidth=970&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=79554&status=done&style=none&taskId=u454306f1-4980-4c43-b9b0-e96b7023cb1&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122549139-f0a376cd-0dcc-45b4-a9ea-a80edd0eaf75.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u564f5a0f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=114981&status=done&style=none&taskId=u0b253840-a35c-4ce8-945e-4840ef6b177&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122549211-345d5066-f7b1-4136-a217-5775e94b35e4.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8a05f07e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=429&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=187776&status=done&style=none&taskId=ub65c3f7d-4263-42ad-acc6-3399c52d4ba&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122549592-582b0835-d20b-4889-ba86-306067eb9431.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u25544e7f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=801&originWidth=987&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=282340&status=done&style=none&taskId=uda26ed97-04ee-45c0-b393-a754e73870f&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122549670-166d5f84-6331-4825-ad55-018e84b50e54.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5e8f7ddb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=575&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=288965&status=done&style=none&taskId=uf5cbc2d9-5897-49a3-8483-98a024b0046&title=">
<meta property="article:published_time" content="2022-02-11T16:00:00.000Z">
<meta property="article:modified_time" content="2022-09-04T14:28:15.770Z">
<meta property="article:author" content="charles">
<meta property="article:tag" content="Architecture">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122547682-625bb362-4995-48b1-80c1-a04a247ddc03.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=352&id=u0cb29d2e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=639&originWidth=1024&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=1040780&status=done&style=none&taskId=u038939a2-db37-4232-b314-306f47aca40&title=&width=564">

    <link rel="shortcut icon" href="//cdn.alicharles.com/static/images/logo.png" type="image/png">
    <link rel="icon" sizes="any" mask href="//cdn.alicharles.com/static/images/logo.svg">
    <link rel="stylesheet" href="//cdn.alicharles.com/static/css/bootstrap.css">  
    <link rel="stylesheet" href="//cdn.alicharles.com/static/css/style.css">   
    <link rel="stylesheet" href="//cdn.alicharles.com/static/lib/fontawesome/css/all.css">   
    <link rel="stylesheet" href="//cdn.alicharles.com/static/lib/prism/css/prism.css">   
    
    

<meta name="generator" content="Hexo 6.2.0"></head>


<body>

  <!-- Nav -->
  <header>
    <nav class="navbar navbar-expand-md navbar-light charles-navbar py-0">
        <div class="container">
            <a class="navbar-brand mr-0 mr-md-2" href="/">
                <img src="//cdn.alicharles.com/static/images/charles-logo.png" height="32px" width="80px" alt="charles">
            </a>
            <button class="navbar-toggler"
                    type="button"
                    data-toggle="collapse"
                    data-target="#navbarDropdown">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse justify-content-end" id="navbarDropdown">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="/">主页<span class="sr-only">(current)</span></a>
                    </li>
                    
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" data-toggle="dropdown" target="_blank">
                            推荐
                        </a>
                        <div class="dropdown-menu dropdown-menu-right mt-0" >
                            <div class="row mx-0" style="width: 16rem">
                                
                                
                                    
                                    
                                    <div class="col-sm " style="overflow: hidden;">
                                        
                                            <a class="nav-link" href="/categories/jvm/" target="_blank">JVM</a>
                                        
                                            <a class="nav-link" href="/categories/design-pattern/" target="_blank">设计模式</a>
                                        
                                            <a class="nav-link" href="/tags/Lock/" target="_blank">Java锁</a>
                                        
                                    </div>
                                    
                                    
                                
                                    
                                    
                                    <div class="col-sm  border-left " style="overflow: hidden;">
                                        
                                            <a class="nav-link" href="/categories/disruptor/" target="_blank">Disruptor</a>
                                        
                                            <a class="nav-link" href="/categories/netty/" target="_blank">Netty</a>
                                        
                                            <a class="nav-link" href="/categories/ddd/" target="_blank">领域驱动设计</a>
                                        
                                    </div>
                                    
                                    
                                
                            </div>
                        </div>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link" href="/categories" target="_blank">分类</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/tags" target="_blank">标签</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/archives" target="_blank">归档</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about" target="_blank">关于</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/search" target="_blank">搜索</a>
                    </li>
                </ul>
            </div>
        </div> <!-- /container -->
    </nav>
</header>


  <!-- Main Content -->
  <div class="container bg-white my-3">
    <div class="post-article">
        <section id="posts" class="posts-expand">
            <h1>架构（三）通用可编排订单状态机引擎设计</h1>
<header class="post-header">
     <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="fa far fa-user"></i>
        </span>
        <span class="post-meta-item-text">发表于</span>
        <time itemprop="dateCreated" datetime="2022-02-12T00:00:00+08:00">
            2022-02-12
        </time>
    </span>
    <span class="post-category">
        
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="fa far fa-calendar-alt"></i>
        </span>
        <span class="post-meta-item-text">分类于</span>
        
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
            <a href="/categories/architecture/" itemprop="url" rel="index">
              <span itemprop="name">architecture</span>
            </a>
        </span>
        
    
    </span>
</header>
<div class="post-body">
<blockquote>
<p>简介： 订单状态流转是交易系统的最为核心的工作，订单系统往往都会存在状态多、链路长、逻辑复杂的特点，还存在多场景、多类型、多业务维度等业务特性。在保证订单状态流转稳定性的前提下、可扩展性和可维护性是我们需要重点关注和解决的问题。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122547682-625bb362-4995-48b1-80c1-a04a247ddc03.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=352&id=u0cb29d2e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=639&originWidth=1024&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=1040780&status=done&style=none&taskId=u038939a2-db37-4232-b314-306f47aca40&title=&width=564" alt="image.png"></p>
<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>订单状态流转是交易系统的最为核心的工作，订单系统往往都会存在状态多、链路长、逻辑复杂的特点，还存在多场景、多类型、多业务维度等业务特性。在保证订单状态流转稳定性的前提下、可扩展性和可维护性是我们需要重点关注和解决的问题。<br>以高德打车业务的订单状态为例，订单状态就有乘客下单、司机接单、司机已到达乘车点、开始行程、行程结束、确认费用、支付成功、订单取消、订单关闭等；订单车型有专车、快车、出租车等几种车型，而专车又分舒适型、豪华型、商务型等；业务场景接送机、企业用车、城际拼车等等场景。<br>当订单状态、类型、场景、以及其他一些维度组合时，每一种组合都可能会有不同的处理逻辑、也可能会存在共性的业务逻辑，这种情况下代码中各种 if-else 肯定是不敢想象的。怎么处理这种”多状态+多类型+多场景+多维度”的复杂订单状态流转业务，又要保证整个系统的可扩展性和可维护性，本文的解决思路和方案同大家一起探讨。</p>
<h2 id="二、实现方案"><a href="#二、实现方案" class="headerlink" title="二、实现方案"></a>二、实现方案</h2><p>要解决”多状态+多类型+多场景+多维度”的复杂订单状态流转业务，我们从纵向和横向两个维度进行设计。纵向主要从业务隔离和流程编排的角度出发解决问题、而横向主要从逻辑复用和业务扩展的角度解决问题。</p>
<h3 id="1、纵向解决业务隔离和流程编排"><a href="#1、纵向解决业务隔离和流程编排" class="headerlink" title="1、纵向解决业务隔离和流程编排"></a>1、纵向解决业务隔离和流程编排</h3><p>状态模式的应用<br>通常我们处理一个多状态或者多维度的业务逻辑，都会采用状态模式或者策略模式来解决，我们这里不讨论两种设计模式的异同，其核心其实可以概括为一个词”分而治之”，抽象一个基础逻辑接口、每一个状态或者类型都实现该接口，业务处理时根据不同的状态或者类型调用对应的业务实现，以到达逻辑相互独立互不干扰、代码隔离的目的。<br>这不仅仅是从可扩展性和可维护性的角度出发，其实我们做架构做稳定性、隔离是一种减少影响面的基本手段，类似的隔离环境做灰度、分批发布等，这里不做扩展。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122546005-0543cc56-7641-4acb-825b-486786885810.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0a5c3acf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=457&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=130195&status=done&style=none&taskId=u63891d7e-3007-407c-8181-a4edeecd2a6&title=" alt="image.png"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 状态机处理器接口
 *&#x2F;
public interface StateProcessor &#123;
    &#x2F;**
     * 执行状态迁移的入口
     *&#x2F;
    void action(StateContext context) throws Exception;
&#125;

&#x2F;**
 * 状态A对应的状态处理器
 *&#x2F;
public class StateAProcessor implements StateProcessor &#123;
    &#x2F;**
     * 执行状态迁移的入口
     *&#x2F;
    @Override
    public void action(StateContext context) throws Exception &#123;
    &#125;
&#125;</code></pre>

<p>单一状态或类型可以通过上面的方法解决，那么”<strong>多状态+多类型+多场景+多维度</strong>“这种组合业务呢，当然也可以采用这种模式或思路来解决。首先在开发阶段通过一个注解@OrderPorcessor 将不同的维度予以组合、开发出多个对应的具体实现类，在系统运行阶段，通过判断上下文来动态选择具体使用哪一个实现类执行。@OrderPorcessor 中分别定义 state 代表当前处理器要处理的状态，bizCode 和 sceneId 分别代表业务类型和场景，这两个字段留给业务进行扩展，比如可以用 bizCode 代表产品或订单类型、sceneId 代表业务形态或来源场景等等，如果要扩展多个维度的组合、也可以用多个维度拼接后的字符串赋值到 bizCode 和 sceneId 上。<br>受限于 Java 枚举不能继承的规范，如果要开发通用的功能、注解中就不能使用枚举、所以此处只好使用 String。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122546581-7d7979fe-5da4-49fc-be45-abe3092389a8.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue0b046c3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=699&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=202124&status=done&style=none&taskId=u3f55da17-bc19-418d-9cae-4f32b0b3828&title=" alt="image.png"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 状态机引擎的处理器注解标识
 *&#x2F;
@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Component
public @interface OrderProcessor &#123;
    &#x2F;**
     * 指定状态，state不能同时存在
     *&#x2F;
    String[] state() default &#123;&#125;;
    &#x2F;**
     * 业务
     *&#x2F;
    String[] bizCode() default &#123;&#125;;
    &#x2F;**
     * 场景
     *&#x2F;
    String[] sceneId() default &#123;&#125;;
&#125;


&#x2F;**
 * 创建订单状态对应的状态处理器
 *&#x2F;
@OrderProcessor(state &#x3D; &quot;INIT&quot;, bizCode &#x3D; &#123;&quot;CHEAP&quot;,&quot;POPULAR&quot;&#125;, sceneId &#x3D; &quot;H5&quot;)
public class StateCreateProcessor implements StateProcessor &#123;
&#125;</code></pre>

<p>再想一下，因为涉及到状态流转，不可能会是一个状态 A 只能流转到状态 B、状态 A 可能在不同的场景下流转到状态 B、状态 C、状态 D；还有虽然都是由状态 A 流转到状态 B、但是不同的场景处理流程也可能不一样，比如都是将<strong>订单从从待支付状态进行支付、用户主动发起支付和系统免密支付的流程可能就不一样</strong>。针对上面这两种情况、我们把这里的**”场景”统一封装为”事件（event）”，以”事件驱动”的方式来控制状态的流向<strong>，一个状态遇到一个特定的处理事件来决定该状态的业务处理流程和最终状态流向。我们可以总结下，其实状态机模式简单说就是：基于某些特定业务和场景下，根据源状态和发生的事件，来执行下一步的流程处理逻辑，并设置一个目标状态。<br>这里有人可能有一些疑问，这个”事件”和上面说的”多场景”、”多维度”有什么不一样。解释一下，我们这里说的是</strong>“事件”是一个具体的业务要执行的动作，比如用户下单是一个业务事件、用户取消订单是一个业务事件、用户支付订单也是一个业务事件**。而”<strong>多场景”、”多维度”则是可交由业务自行进行扩展的维度</strong>，比如自有标准模式来源的订单、通过开放平台 API 来的订单、通过第三方标准来源的订单，某某小程序、某某 APP 来源可以定义为不同场景，而接送机、企业用车、拼车等可以定义为维度。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122545954-f48261ba-a341-4bc7-bd8c-60382122a914.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uefd9681a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=232&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=79645&status=done&style=none&taskId=u8061e814-8311-4556-9849-f13b6a73b20&title=" alt="image.png"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public @interface OrderProcessor &#123;
    &#x2F;**
     * 指定状态
     *&#x2F;
    String[] state() default &#123;&#125;;
    &#x2F;**
     * 订单操作事件
     *&#x2F;
    String event();
    ......
&#125;

&#x2F;**
 * 订单状态迁移事件
 *&#x2F;
public interface OrderStateEvent &#123;
    &#x2F;**
     * 订单状态事件
     *&#x2F;
    String getEventType();
    &#x2F;**
     * 订单ID
     *&#x2F;
    String getOrderId();
    &#x2F;**
     * 如果orderState不为空，则代表只有订单是当前状态才进行迁移
     *&#x2F;
    default String orderState() &#123;
        return null;
    &#125;
    &#x2F;**
     * 是否要新创建订单
     *&#x2F;
    boolean newCreate();
&#125;</code></pre>

<p>状态迁移流程的封装<br>在满足了上面说的多维度组合的业务场景、开发多个实现类来执行的情况，我们思考执行这些实现类在流程上是否有再次抽象和封装的地方、以减少研发工作量和尽量的实现通用流程。我们经过观察和抽象，发现每一个订单状态流转的流程中，都会有三个流程：校验、业务逻辑执行、数据更新持久化；于是再次抽象，可以将一个状态流转分为数据准备（prepare）——&gt;校验（check）——&gt;获取下一个状态（getNextState）——&gt;业务逻辑执行（action）——&gt;数据持久化（save）——&gt;后续处理（after）这六个阶段；然后通过一个模板方法将六个阶段方法串联在一起、形成一个有顺序的执行逻辑。这样一来整个状态流程的执行逻辑就更加清晰和简单了、可维护性上也得到的一定的提升。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122546996-7f5e6ed2-0521-4dcd-986d-a2c8d6427ae2.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u828ac9b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=761&originWidth=998&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=307486&status=done&style=none&taskId=u46c03995-c47a-4f6e-97a0-d21f36caf6b&title=" alt="image.png"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 状态迁移动作处理步骤
 *&#x2F;
public interface StateActionStep&lt;T, C&gt; &#123;
    &#x2F;**
     * 准备数据
     *&#x2F;
    default void prepare(StateContext&lt;C&gt; context) &#123;
    &#125;
    &#x2F;**
     * 校验
     *&#x2F;
    ServiceResult&lt;T&gt; check(StateContext&lt;C&gt; context);
    &#x2F;**
     * 获取当前状态处理器处理完毕后，所处于的下一个状态
     *&#x2F;
    String getNextState(StateContext&lt;C&gt; context);
    &#x2F;**
     * 状态动作方法，主要状态迁移逻辑
     *&#x2F;
    ServiceResult&lt;T&gt; action(String nextState, StateContext&lt;C&gt; context) throws Exception;
    &#x2F;**
     * 状态数据持久化
     *&#x2F;
    ServiceResult&lt;T&gt; save(String nextState, StateContext&lt;C&gt; context) throws Exception;
    &#x2F;**
     * 状态迁移成功，持久化后执行的后续处理
     *&#x2F;
    void after(StateContext&lt;C&gt; context);
&#125;

&#x2F;**
 * 状态机处理器模板类
 *&#x2F;
@Component
public abstract class AbstractStateProcessor&lt;T, C&gt; implements StateProcessor&lt;T, C&gt;, StateActionStep&lt;T, C&gt; &#123;
    @Override
    public final ServiceResult&lt;T&gt; action(StateContext&lt;C&gt; context) throws Exception &#123;
        ServiceResult&lt;T&gt; result &#x3D; null;
        try &#123;
            &#x2F;&#x2F; 数据准备
            this.prepare(context);
            &#x2F;&#x2F; 串行校验器
            result &#x3D; this.check(context);
            if (!result.isSuccess()) &#123;
                return result;
            &#125;
            &#x2F;&#x2F; getNextState不能在prepare前，因为有的nextState是根据prepare中的数据转换而来
            String nextState &#x3D; this.getNextState(context);
            &#x2F;&#x2F; 业务逻辑
            result &#x3D; this.action(nextState, context);
            if (!result.isSuccess()) &#123;
                return result;
            &#125;
            &#x2F;&#x2F; 持久化
            result &#x3D; this.save(nextState, context);
            if (!result.isSuccess()) &#123;
                return result;
            &#125;
            &#x2F;&#x2F; after
            this.after(context);
            return result;
        &#125; catch (Exception e) &#123;
            throw e;
        &#125;
    &#125;
&#125;

&#x2F;**
 * 状态A对应的状态处理器
 *&#x2F;
@OrderProcessor(state &#x3D; &quot;INIT&quot;, bizCode &#x3D; &#123;&quot;CHEAP&quot;,&quot;POPULAR&quot;&#125;, sceneId &#x3D; &quot;H5&quot;)
public class StateCreateProcessor extends AbstractStateProcessor&lt;String, CreateOrderContext&gt; &#123;
    ......
&#125;</code></pre>

<p>（1）校验器<br>上面提到了校验（check），我们都知道任何一个状态的流转甚至接口的调用其实都少不了一些校验规则，尤其是对于复杂的业务、其校验规则和校验逻辑也会更加复杂。那么对于这些校验规则怎么解耦呢，既要将校验逻辑从复杂的业务流程中解耦出来、同时又需要把复杂的校验规则简单化，使整个校验逻辑更具有可扩展性和可维护性。其实做法也比较简单、参考上面的逻辑，只需要抽象一个校验器接口 checker、把复杂的校验逻辑拆开、形成多个单一逻辑的校验器实现类，状态处理器在调用 check 时只需要调用一个接口、由校验器执行多个 checker 的集合就可以了。将校验器 checker 进行封装之后，发现要加入一个新的校验逻辑就十分简单了，只需要写一个新的 checker 实现类加入校验器就行、对其他代码基本没有改动。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 状态机校验器
 *&#x2F;
public interface Checker&lt;T, C&gt; &#123;
    ServiceResult&lt;T&gt; check(StateContext&lt;C&gt; context);
    &#x2F;**
     * 多个checker时的执行顺序
     *&#x2F;
    default int order() &#123;
        return 0;
    &#125;
&#125;</code></pre>

<p><strong>逻辑简单了、扩展性和维护性解决了、性能问题就会显现出来</strong>。多个校验器 checker 串行执行性能肯定性能比较差，此时很简单的可以想到使用并行执行，是的、此处使用多线程并行执行多个校验器 checker 能显著提高执行效率。但是也应该意识到，有些校验器逻辑可能是有前后依赖的（其实不应该出现），还有写业务流程中要求某些校验器的执行必须有前后顺序，还有些流程不要求校验器的执行顺序但是要求错误时的返回顺序、那么怎么在并行的前提下保证顺序呢、此处就可以用 order+Future 实现了。经过一系列的思考和总结，我们把校验器分为参数校验（paramChecker）、同步校验（syncChecker）、异步校验（asyncChecker）三种类型，其中参数校验 paramChecker 是需要在状态处理器最开始处执行的，为什么这么做、因为参数都不合法了肯定没有继续向下执行的必要了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122547582-44a5d079-02f2-4ff4-bc30-9ac119d6585d.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u69f91899&margin=%5Bobject%20Object%5D&name=image.png&originHeight=480&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=211547&status=done&style=none&taskId=u15f56b94-e8ec-493a-89c5-e11e3a33ddf&title=" alt="image.png"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 状态机校验器
 *&#x2F;
public interface Checkable &#123;
    &#x2F;**
     * 参数校验
     *&#x2F;
    default List&lt;Checker&gt; getParamChecker() &#123;
        return Collections.EMPTY_LIST;
    &#125;
    &#x2F;**
     * 需同步执行的状态检查器
     *&#x2F;
    default List&lt;Checker&gt; getSyncChecker() &#123;
        return Collections.EMPTY_LIST;
    &#125;
    &#x2F;**
     * 可异步执行的校验器
     *&#x2F;
    default List&lt;Checker&gt; getAsyncChecker() &#123;
        return Collections.EMPTY_LIST;
    &#125;
&#125;

&#x2F;**
 * 校验器的执行器
 *&#x2F;
public class CheckerExecutor &#123;
    &#x2F;**
     * 执行并行校验器，
     * 按照任务投递的顺序判断返回。
     *&#x2F;
    public ServiceResult&lt;T, C&gt; parallelCheck(List&lt;Checker&gt; checkers, StateContext&lt;C&gt; context) &#123;
        if (!CollectionUtils.isEmpty(checkers)) &#123;
            if (checkers.size() &#x3D;&#x3D; 1) &#123;
                return checkers.get(0).check(context);
            &#125;
            List&lt;Future&lt;ServiceResult&gt;&gt; resultList &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;(checkers.size()));
            checkers.sort(Comparator.comparingInt(Checker::order));
            for (Checker c : checkers) &#123;
                Future&lt;ServiceResult&gt; future &#x3D; executor.submit(() -&gt; c.check(context));
                resultList.add(future);
            &#125;
            for (Future&lt;ServiceResult&gt; future : resultList) &#123;
                try &#123;
                    ServiceResult sr &#x3D; future.get();
                    if (!sr.isSuccess()) &#123;
                        return sr;
                    &#125;
                &#125; catch (Exception e) &#123;
                    log.error(&quot;parallelCheck executor.submit error.&quot;, e);
                    throw new RuntimeException(e);
                &#125;
            &#125;
        &#125;
        return new ServiceResult&lt;&gt;();
    &#125;
&#125;</code></pre>

<p>checkable 在模板方法中的使用。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface StateActionStep&lt;T, C&gt; &#123;
    Checkable getCheckable(StateContext&lt;C&gt; context);
    ....
&#125;

public abstract class AbstractStateProcessor&lt;T, C&gt; implements StateProcessor&lt;T&gt;, StateActionStep&lt;T, C&gt; &#123;
    @Resource
    private CheckerExecutor checkerExecutor;
    @Override
    public final ServiceResult&lt;T&gt; action(StateContext&lt;C&gt; context) throws Exception &#123;
        ServiceResult&lt;T&gt; result &#x3D; null;
        Checkable checkable &#x3D; this.getCheckable(context);
        try &#123;
            &#x2F;&#x2F; 参数校验器
            result &#x3D; checkerExecutor.serialCheck(checkable.getParamChecker(), context);
            if (!result.isSuccess()) &#123;
                return result;
            &#125;
            &#x2F;&#x2F; 数据准备
            this.prepare(context);
            &#x2F;&#x2F; 串行校验器
            result &#x3D; checkerExecutor.serialCheck(checkable.getSyncChecker(), context);
            if (!result.isSuccess()) &#123;
                return result;
            &#125;
            &#x2F;&#x2F; 并行校验器
            result &#x3D; checkerExecutor.parallelCheck(checkable.getAsyncChecker(), context);
            if (!result.isSuccess()) &#123;
                return result;
            &#125;
        ......
&#125;</code></pre>

<p>checkable 在具体状态处理器中的代码应用举例。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@OrderProcessor(state &#x3D; &quot;INIT&quot;, bizCode &#x3D; &#123;&quot;CHEAP&quot;,&quot;POPULAR&quot;&#125;, sceneId &#x3D; &quot;H5&quot;)
public class OrderCreatedProcessor extends AbstractStateProcessor&lt;String, CreateOrderContext&gt; &#123;
    @Resource
    private CreateParamChecker createParamChecker;
    @Resource
    private UserChecker userChecker;
    @Resource
    private UnfinshChecker unfinshChecker;
    @Override
    public Checkable getCheckable(StateContext&lt;CreateOrderContext&gt; context) &#123;
        return new Checkable() &#123;
            @Override
            public List&lt;Checker&gt; getParamChecker() &#123;
                return Arrays.asList(createParamChecker);
            &#125;
            @Override
            public List&lt;Checker&gt; getSyncChecker() &#123;
                return Collections.EMPTY_LIST;
            &#125;
            @Override
            public List&lt;Checker&gt; getAsyncChecker() &#123;
                return Arrays.asList(userChecker, unfinshChecker);
            &#125;
        &#125;;
    &#125;
......</code></pre>

<p>checker 的定位是校验器，负责校验参数或业务的合法性，但实际编码过程中、checker 中可能会有一些临时状态类操作，比如在校验之前进行计数或者加锁操作、在校验完成后根据结果进行释放，这里就需要支持统一的释放功能。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Checker&lt;T, C&gt; &#123;
    ......
    &#x2F;**
     * 是否需求release
     *&#x2F;
    default boolean needRelease() &#123;
        return false;
    &#125;
    &#x2F;**
     * 业务执行完成后的释放方法,
     * 比如有些业务会在checker中加一些状态操作，等业务执行完成后根据结果选择处理这些状态操作,
     * 最典型的就是checker中加一把锁，release根据结果释放锁.
     *&#x2F;
    default void release(StateContext&lt;C&gt; context, ServiceResult&lt;T&gt; result) &#123;
    &#125;
&#125;


public class CheckerExecutor &#123;
    &#x2F;**
     * 执行checker的释放操作
     *&#x2F;
    public &lt;T, C&gt; void releaseCheck(Checkable checkable, StateContext&lt;C&gt; context, ServiceResult&lt;T&gt; result) &#123;
        List&lt;Checker&gt; checkers &#x3D; new ArrayList&lt;&gt;();
        checkers.addAll(checkable.getParamChecker());
        checkers.addAll(checkable.getSyncChecker());
        checkers.addAll(checkable.getAsyncChecker());
        checkers.removeIf(Checker::needRelease);
        if (!CollectionUtils.isEmpty(checkers)) &#123;
            if (checkers.size() &#x3D;&#x3D; 1) &#123;
                checkers.get(0).release(context, result);
                return;
            &#125;
            CountDownLatch latch &#x3D; new CountDownLatch(checkers.size());
            for (Checker c : checkers) &#123;
                executor.execute(() -&gt; &#123;
                    try &#123;
                        c.release(context, result);
                    &#125; finally &#123;
                        latch.countDown();
                    &#125;
                &#125;);
            &#125;
            try &#123;
                latch.await();
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<p>2）上下文<br>从上面代码可以发现，整个状态迁移的几个方法都是使用上下文 Context 对象串联的。Context 对象中一共有三类对象，（1）订单的基本信息（订单 ID、状态、业务属性、场景属性）、（2）事件对象（其参数基本就是状态迁移行为的入参）、（3）具体处理器决定的泛型类。<strong>一般要将数据在多个方法中进行传递有两种方案：一个是包装使用 ThreadLocal、每个方法都可以对当前 ThreadLocal 进行赋值和取值；另一种是使用一个上下文 Context 对象做为每个方法的入参传递</strong>。这种方案都有一些优缺点，使用 ThreadLocal 其实是一种”隐式调用”，虽然可以在”随处”进行调用、但是对使用方其实不明显的、在中间件中会大量使用、在开发业务代码中是需要尽量避免的；而使用 Context 做为参数在方法中进行传递、可以有效的减少”不可知”的问题。<br>不管是使用 ThreadLocal 还是 Context 做为参数传递，对于实际承载的数据载体有两种方案，常见的是使用 Map 做为载体，业务在使用的时候可以根据需要随意的设置任何 kv，但是这种情况对代码的可维护性和可读性是极大的挑战，所以这里<strong>使用泛型类来固定数据格式，一个具体的状态处理流程到底需要对哪些数据做传递需要明确定义好。其实原则是一样的，业务开发尽量用用可见性避免不可知</strong>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StateContext&lt;C&gt; &#123;
    &#x2F;**
     * 订单操作事件
     *&#x2F;
    private OrderStateEvent orderStateEvent;
    &#x2F;**
     * 状态机需要的订单基本信息
     *&#x2F;
    private FsmOrder fsmOrder;
    &#x2F;**
     * 业务可定义的上下文泛型对象
     *&#x2F;
    private C context;
    public StateContext(OrderStateEvent orderStateEvent, FsmOrder fsmOrder) &#123;
        this.orderStateEvent &#x3D; orderStateEvent;
        this.fsmOrder &#x3D; fsmOrder;
    &#125;
    ......

&#x2F;**
 * 状态机引擎所需的订单信息基类信息
 *&#x2F;
public interface FsmOrder &#123;
    &#x2F;**
     * 订单ID
     *&#x2F;
    String getOrderId();
    &#x2F;**
     * 订单状态
     *&#x2F;
    String getOrderState();
    &#x2F;**
     * 订单的业务属性
     *&#x2F;
    String bizCode();
    &#x2F;**
     * 订单的场景属性
     *&#x2F;
    String sceneId();
&#125;
</code></pre>

<p>（3）<strong>迁移到的状态判定</strong><br>为什么要把下一个状态（getNextState）抽象为单独一个步骤、而不是交由业务自己进行设置呢？是因为要迁移到的下一个状态不一定是固定的，就是说根据当前状态和发生的事件、再遇到更加细节的逻辑时也可能会流转到不同的状态。举个例子，当<strong>前状态是用户已下单完成、要发生的事件是用户取消订单，此时根据不同的逻辑，订单有可能流转到取消状态、也有可能流转到取消待审核状态、甚至有可能流转到取消待支付费用状态。</strong>当然这里要取决于业务系统对状态和事件定义的粗细和状态机的复杂程度，做为状态机引擎、这里把下一个状态的判定交由业务根据上下文对象自己来判断。<br>getNextState()使用及状态迁移持久化举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@OrderProcessor(state &#x3D; OrderStateEnum.INIT, event &#x3D; OrderEventEnum.CREATE, bizCode &#x3D; &quot;BUSINESS&quot;)
public class OrderCreatedProcessor extends AbstractStateProcessor&lt;String, CreateOrderContext&gt; &#123;

    ........

    @Override
    public String getNextState(StateContext&lt;CreateOrderContext&gt; context) &#123;
    &#x2F;&#x2F; if (context.getOrderStateEvent().getEventType().equals(&quot;xxx&quot;)) &#123;
    &#x2F;&#x2F;     return OrderStateEnum.INIT;
    &#x2F;&#x2F;  &#125;
        return OrderStateEnum.NEW;
    &#125;
    @Override
    public ServiceResult&lt;String&gt; save(String nextState, StateContext&lt;CreateOrderContext&gt; context) throws Exception &#123;
        OrderInfo orderInfo &#x3D; context.getContext().getOrderInfo();
        &#x2F;&#x2F; 更新状态
        orderInfo.setOrderState(nextState);
        &#x2F;&#x2F; 持久化
        &#x2F;&#x2F;this.updateOrderInfo(orderInfo);
        log.info(&quot;save BUSINESS order success, userId:&#123;&#125;, orderId:&#123;&#125;&quot;, orderInfo.getUserId(), orderInfo.getOrderId());
        return new ServiceResult&lt;&gt;(orderInfo.getOrderId(), &quot;business下单成功&quot;);
    &#125;
&#125;</code></pre>

<p><strong>状态消息</strong><br>一般来说，所有的状态迁移都应该发出对应的消息，由下游消费方订阅进行相应的业务处理。<br>（1）状态消息内容<br>对于状态迁移消息的发送内容通常有两种形式，一个是只发状态发生迁移这个通知、举例子就是只发送”订单 ID、变更前状态、变更后状态”等几个关键字段，具体下游业务需要哪些具体内容在调用相应的接口进行反查；还有一种是发送所有字段出去、类似于发一个状态变更后的订单内容快照，下游接到消息后几乎不需要在调用接口进行反查。<br>（2）状态消息的时序<br>状态迁移是有时序的，因此很多下游依赖方也需要判断消息的顺序。一种实现方案是使用顺序消息（rocketmq、kafka 等），但基于并发吞吐量的考虑很少采用这种方案；一般都是在消息体中加入”消息发送时间”或者”状态变更时间”字段，有消费方自己进行处理。<br>（3）数据库状态变更和消息的一致性<br>状态变更需要和消息保持一致吗？<br>很多时候是需要的，如果数据库状态变更成功了、但是状态消息没有发送出去、则会导致一些下游依赖方处理逻辑的缺失。而我们知道，数据库和消息系统是无法保证 100%一致的，我们要保证的是主要数据库状态变更了、消息就要尽量接近 100%的发送成功。<br>那么怎么保证呢？<br>其实通常确实有几种方案：<br>a）使用 rocketmq 等支持的两阶段式消息提交方式：</p>
<ol>
<li>先向消息服务器发送一条预处理消息</li>
<li>当本地数据库变更提交之后、再向消息服务器发送一条确认发送的消息</li>
<li>如果本地数据库变更失败、则向消息服务器发送一条取消发送的消息</li>
<li>如果长时间没有向消息服务器发生确认发送的消息，消息系统则会回调一个提前约定的接口、来查看本地业务是否成功，以此决定是否真正发生消息</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122547541-bb17dc47-8c23-4c72-9a19-f419772c7af1.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8de51909&margin=%5Bobject%20Object%5D&name=image.png&originHeight=425&originWidth=970&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=79554&status=done&style=none&taskId=u454306f1-4980-4c43-b9b0-e96b7023cb1&title=" alt="image.png"><br>b）使用数据库事务方案保证：</p>
<ol>
<li>创建一个消息发送表，将要发送的消息插入到该表中，同本地业务在一个数据库事务中进行提交</li>
<li>之后在由一个定时任务来轮询发送、直到发送成功后在删除当前表记录</li>
</ol>
<p>c）还是使用数据库事务方案保证：</p>
<ol>
<li>创建一个消息发送表，将要发送的消息插入到该表中，同本地业务在一个数据库事务中进行提交</li>
<li>向消息服务器发送消息</li>
<li>发送成功则删除掉当前表记录</li>
<li>对于没有发送成功的消息（也就是表里面没有被删除的记录），再由定时任务来轮询发送</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122549139-f0a376cd-0dcc-45b4-a9ea-a80edd0eaf75.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u564f5a0f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=114981&status=done&style=none&taskId=u0b253840-a35c-4ce8-945e-4840ef6b177&title=" alt="image.png"><br>还有其他方案吗？有的。<br>d）数据对账、发现不一致时进行补偿处理、以此保证数据的最终一致。其实不管使用哪种方案来保证数据库状态变更和消息的一致，数据对账的方案都是”必须”要有的一种兜底方案。<br>那么、还有其他方案吗？还是有的，对于数据库状态变更和消息的一致性的问题，细节比较多，每种方案又都有相应的优缺点，本文主要是介绍状态机引擎的设计，对于消息一致性的问题就不过多介绍，后面也许会有单独的文章对数据库变更和消息的一致性的问题进行介绍和讨论。</p>
<h3 id="2、横向解决逻辑复用和实现业务扩展"><a href="#2、横向解决逻辑复用和实现业务扩展" class="headerlink" title="2、横向解决逻辑复用和实现业务扩展"></a>2、横向解决逻辑复用和实现业务扩展</h3><p><strong>实现基于”多类型+多场景+多维度”的代码分离治理、以及标准处理流程模板的状态机模型</strong>之后，其实在真正编码的时候会发现不同类型不同维度对于同一个状态的流程处理过程，有时多个处理逻辑中的一部分流程一样的或者是相似的，比如支付环节不管是采用免密还是其他方式、其中核销优惠券的处理逻辑、设置发票金额的处理逻辑等都是一样的；甚至有些时候多个类型间的处理逻辑大部分是相同的而差异是小部分，比如下单流程的处理逻辑基本逻辑都差不多，而出租车对比网约车可能就多了出租车红包、无预估价等个别流程的差异。<br>对于上面这种情况、其实就是要实现在<strong>纵向解决业务隔离和流程编排</strong>的基础上，需要支持小部分逻辑或代码段的复用、或者大部分流程的复用，减少重复建设和开发。对此我们在状态机引擎中支持两种解决方案：<br><strong>基于插件化的解决方案</strong><br>插件的主要逻辑是：可以在业务逻辑执行（action）、数据持久化（save）这两个节点前加载对应到的插件类进行执行，主要是对上下文 Context 对象进行操作、或者根据 Context 参数发起不同的流程调用，已到达改变业务数据或流程的目的。<br>（1）标准流程+差异化插件<br>上面讲到同一个状态模型下、不同的类型或维度有些逻辑或处理流程是一样的小部分逻辑是不同的。于是我们可以把一种处理流程定义为标准的或默认的处理逻辑，把差异化的代码写成插件，当业务执行到具体差异化逻辑时会调用到不同的插件进行处理，这样只需要为不同的类型或维度编写对应有差异逻辑的插件即可、标准的处理流程由默认的处理器执行就行。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122549211-345d5066-f7b1-4136-a217-5775e94b35e4.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8a05f07e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=429&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=187776&status=done&style=none&taskId=ub65c3f7d-4263-42ad-acc6-3399c52d4ba&title=" alt="image.png"><br>（2）差异流程+公用插件<br>当然对于小部分逻辑和代码可以公用的场景，也可以用插件化的方案解决。比如对于同一个状态下多个维度下不同处理器中、我们可以把相同的逻辑或代码封装成一个插件，多个处理器中都可以识别加载该插件进行执行，从而实现多个差异的流程使用想用插件的形式。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 插件注解
 *&#x2F;
@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Component
public @interface ProcessorPlugin &#123;
    &#x2F;**
     * 指定状态，state不能同时存在
     *&#x2F;
    String[] state() default &#123;&#125;;
    &#x2F;**
     * 订单操作事件
     *&#x2F;
    String event();
    &#x2F;**
     * 业务
     *&#x2F;
    String[] bizCode() default &#123;&#125;;
    &#x2F;**
     * 场景
     *&#x2F;
    String[] sceneId() default &#123;&#125;;
&#125;

&#x2F;* 插件处理器
 *&#x2F;
public interface PluginHandler&lt;T, C&gt; extends StateProcessor&lt;T, C&gt; &#123;
&#125;
</code></pre>

<p>Plugin 在处理器模板中的执行逻辑。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class AbstractStateProcessor&lt;T, C&gt; implements StateProcessor&lt;T&gt;, StateActionStep&lt;T, C&gt; &#123;
    @Override
    public final ServiceResult&lt;T&gt; action(StateContext&lt;C&gt; context) throws Exception &#123;
        ServiceResult&lt;T&gt; result &#x3D; null;
        try &#123;
            ......
            &#x2F;&#x2F; 业务逻辑
            result &#x3D; this.action(nextState, context);
            if (!result.isSuccess()) &#123;
                return result;
            &#125;

            &#x2F;&#x2F; 在action和save之间执行插件逻辑
            this.pluginExecutor.parallelExecutor(context);
            &#x2F;&#x2F; 持久化
            result &#x3D; this.save(nextState, context));
            if (!result.isSuccess()) &#123;
                return result;
            &#125;
            ......
        &#125; catch (Exception e) &#123;
            throw e;
        &#125;
    &#125;
&#125;</code></pre>

<p>插件使用的例子：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 预估价插件
 *&#x2F;
@ProcessorPlugin(state &#x3D; OrderStateEnum.INIT, event &#x3D; OrderEventEnum.CREATE, bizCode &#x3D; &quot;BUSINESS&quot;)
public class EstimatePricePlugin implements PluginHandler&lt;String, CreateOrderContext&gt; &#123;
    @Override
    public ServiceResult action(StateContext&lt;CreateOrderContext&gt; context) throws Exception &#123;
&#x2F;&#x2F;        String price &#x3D; priceSerive.getPrice();
        String price &#x3D; &quot;&quot;;
        context.getContext().setEstimatePriceInfo(price);
        return new ServiceResult();
    &#125;
&#125;</code></pre>

<p>基于代码继承方式的解决方案<br>当发现新增一个状态不同维度的处理流程，和当前已存在的一个处理器大部分逻辑是相同的，此时就可以使新写的这个处理器 B 继承已存在的处理器 A，只需要让处理器 B 覆写 A 中不同方法逻辑、实现差异逻辑的替换。这种方案比较好理解，但是需要处理器 A 已经规划好一些可以扩展的点、其他处理器可以基于这些扩展点进行覆写替换。当然更好的方案其实是，先实现一个默认的处理器，把所有的标准处理流程和可扩展点进行封装实现、其他处理器进行继承、覆写、替换就好。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@OrderProcessor(state &#x3D; OrderStateEnum.INIT, event &#x3D; OrderEventEnum.CREATE, bizCode &#x3D; &quot;CHEAP&quot;)
public class OrderCreatedProcessor extends AbstractStateProcessor&lt;String, CreateOrderContext&gt; &#123;
    @Override
    public ServiceResult action(String nextState, StateContext&lt;CreateOrderContext&gt; context) throws Exception &#123;
        CreateEvent createEvent &#x3D; (CreateEvent) context.getOrderStateEvent();
        &#x2F;&#x2F; 促销信息信息
        String promtionInfo &#x3D; this.doPromotion();
        ......
    &#125;

    &#x2F;**
     * 促销相关扩展点
     *&#x2F;
    protected String doPromotion() &#123;
        return &quot;1&quot;;
    &#125;
&#125;

@OrderProcessor(state &#x3D; OrderStateEnum.INIT, event &#x3D; OrderEventEnum.CREATE, bizCode &#x3D; &quot;TAXI&quot;)
public class OrderCreatedProcessor4Taxi extends OrderCreatedProcessor&lt;String, CreateOrderContext&gt;  &#123;
    @Override
    protected String doPromotion() &#123;
        return &quot;taxt1&quot;;
    &#125;
&#125;</code></pre>

<h3 id="3、状态迁移流程的执行流程"><a href="#3、状态迁移流程的执行流程" class="headerlink" title="3、状态迁移流程的执行流程"></a>3、状态迁移流程的执行流程</h3><p>状态机引擎的执行过程<br>通过上面的介绍，大体明白了怎么实现状态流程编排、业务隔离和扩展等等，但是状态机引擎具体是怎么把这个过程串联起来的呢？简单说、分为两个阶段：初始化阶段和运行时阶段。<br>（1）状态机引擎初始化阶段<br>首先在代码编写阶段、根据上面的分析，业务通过实现 AbstractStateProcessor 模板类、并添加@OrderProcessor 注解来实现自己的多个需要的特定状态处理器。<br>那么在系统初始化阶段，所有添加了@OrderProcessor 注解的实现类都会被 spring 所管理成为 spring bean，状态机引擎在通过监听 spring bean 的注册（BeanPostProcessor）来将这些状态处理器 processor 装载到自己管理的容器中。直白来说、这个状态处理器容器其实就是一个多层 map 实现的，第一层 map 的 key 是状态（state），第二层 map 的 key 是状态对应的事件（event）、一个状态可以有多个要处理的事件，第三层 map 的 key 是具体的场景 code（也就是 bizCode 和 sceneId 的组合），最后的 value 是 AbstractStateProcessor 集合。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DefaultStateProcessRegistry implements BeanPostProcessor &#123;
    &#x2F;**
     * 第一层key是订单状态。
     * 第二层key是订单状态对应的事件，一个状态可以有多个事件。
     * 第三层key是具体场景code，场景下对应的多个处理器，需要后续进行过滤选择出一个具体的执行。
     *&#x2F;
    private static Map&lt;String, Map&lt;String, Map&lt;String, List&lt;AbstractStateProcessor&gt;&gt;&gt;&gt; stateProcessMap &#x3D; new ConcurrentHashMap&lt;&gt;();
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;
        if (bean instanceof AbstractStateProcessor &amp;&amp; bean.getClass().isAnnotationPresent(OrderProcessor.class)) &#123;
            OrderProcessor annotation &#x3D; bean.getClass().getAnnotation(OrderProcessor.class);
            String[] states &#x3D; annotation.state();
            String event &#x3D; annotation.event();
            String[] bizCodes &#x3D; annotation.bizCode().length &#x3D;&#x3D; 0 ? new String[]&#123;&quot;#&quot;&#125; : annotation.bizCode();
            String[] sceneIds &#x3D; annotation.sceneId().length &#x3D;&#x3D; 0 ? new String[]&#123;&quot;#&quot;&#125; : annotation.sceneId();
            initProcessMap(states, event, bizCodes, sceneIds, stateProcessMap, (AbstractStateProcessor) bean);
        &#125;
        return bean;
    &#125;
    private &lt;E extends StateProcessor&gt; void initProcessMap(String[] states, String event, String[] bizCodes, String[] sceneIds,
            Map&lt;String, Map&lt;String, Map&lt;String, List&lt;E&gt;&gt;&gt;&gt; map, E processor) &#123;
        for (String bizCode : bizCodes) &#123;
            for (String sceneId : sceneIds) &#123;
                Arrays.asList(states).parallelStream().forEach(orderStateEnum -&gt; &#123;
                    registerStateHandlers(orderStateEnum, event, bizCode, sceneId, map, processor);
                &#125;);
            &#125;
        &#125;
    &#125;
    &#x2F;**
     * 初始化状态机处理器
     *&#x2F;
    public &lt;E extends StateProcessor&gt; void registerStateHandlers(String orderStateEnum, String event, String bizCode, String sceneId,
                                      Map&lt;String, Map&lt;String, Map&lt;String, List&lt;E&gt;&gt;&gt;&gt; map, E processor) &#123;
        &#x2F;&#x2F; state维度
        if (!map.containsKey(orderStateEnum)) &#123;
            map.put(orderStateEnum, new ConcurrentHashMap&lt;&gt;());
        &#125;
        Map&lt;String, Map&lt;String, List&lt;E&gt;&gt;&gt; stateTransformEventEnumMap &#x3D; map.get(orderStateEnum);
        &#x2F;&#x2F; event维度
        if (!stateTransformEventEnumMap.containsKey(event)) &#123;
            stateTransformEventEnumMap.put(event, new ConcurrentHashMap&lt;&gt;());
        &#125;
        &#x2F;&#x2F; bizCode and sceneId
        Map&lt;String, List&lt;E&gt;&gt; processorMap &#x3D; stateTransformEventEnumMap.get(event);
        String bizCodeAndSceneId &#x3D; bizCode + &quot;@&quot; + sceneId;
        if (!processorMap.containsKey(bizCodeAndSceneId)) &#123;
            processorMap.put(bizCodeAndSceneId, new CopyOnWriteArrayList&lt;&gt;());
        &#125;
        processorMap.get(bizCodeAndSceneId).add(processor);
    &#125;
&#125;</code></pre>

<p>（2）状态机引擎运行时阶段<br>经过初始化之后，所有的状态处理器 processor 都被装载到容器。在运行时，通过一个入口来发起对状态机的调用，方法的主要参数是操作事件（event）和业务入参，如果是新创建订单请求需要携带业务（bizCode）和场景（sceneId）信息、如果是已存在订单的更新状态机引擎会根据 oderId 自动获取业务（bizCode）、场景（sceneId）和当前状态（state）。之后引擎根据 state+event+bizCode+sceneId 从状态处理器容器中获取到对应的具体处理器 processor，从而进行状态迁移处理。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * 状态机执行引擎
 *&#x2F;
public interface OrderFsmEngine &#123;
    &#x2F;**
     * 执行状态迁移事件，不传FsmOrder默认会根据orderId从FsmOrderService接口获取
     *&#x2F;
    &lt;T&gt; ServiceResult&lt;T&gt; sendEvent(OrderStateEvent orderStateEvent) throws Exception;
    &#x2F;**
     * 执行状态迁移事件，可携带FsmOrder参数
     *&#x2F;
    &lt;T&gt; ServiceResult&lt;T&gt; sendEvent(OrderStateEvent orderStateEvent, FsmOrder fsmOrder) throws Exception;
&#125;

@Component
public class DefaultOrderFsmEngine implements OrderFsmEngine &#123;
    @Override
    public &lt;T&gt; ServiceResult&lt;T&gt; sendEvent(OrderStateEvent orderStateEvent) throws Exception &#123;
        FsmOrder fsmOrder &#x3D; null;
        if (orderStateEvent.newCreate()) &#123;
            fsmOrder &#x3D; this.fsmOrderService.getFsmOrder(orderStateEvent.getOrderId());
            if (fsmOrder &#x3D;&#x3D; null) &#123;
                throw new FsmException(ErrorCodeEnum.ORDER_NOT_FOUND);
            &#125;
        &#125;
        return sendEvent(orderStateEvent, fsmOrder);
    &#125;
    @Override
    public &lt;T&gt; ServiceResult&lt;T&gt; sendEvent(OrderStateEvent orderStateEvent, FsmOrder fsmOrder) throws Exception &#123;
        &#x2F;&#x2F; 构造当前事件上下文
        StateContext context &#x3D; this.getStateContext(orderStateEvent, fsmOrder);
        &#x2F;&#x2F; 获取当前事件处理器
        StateProcessor&lt;T&gt; stateProcessor &#x3D; this.getStateProcessor(context);
        &#x2F;&#x2F; 执行处理逻辑
        return stateProcessor.action(context);
    &#125;
    private &lt;T&gt; StateProcessor&lt;T, ?&gt; getStateProcessor(StateContext&lt;?&gt; context) &#123;
        OrderStateEvent stateEvent &#x3D; context.getOrderStateEvent();
        FsmOrder fsmOrder &#x3D; context.getFsmOrder();
        &#x2F;&#x2F; 根据状态+事件对象获取所对应的业务处理器集合
        List&lt;AbstractStateProcessor&gt; processorList &#x3D; stateProcessorRegistry.acquireStateProcess(fsmOrder.getOrderState(),
                stateEvent.getEventType(), fsmOrder.bizCode(), fsmOrder.sceneId());
        if (processorList &#x3D;&#x3D; null) &#123;
            &#x2F;&#x2F; 订单状态发生改变
            if (!Objects.isNull(stateEvent.orderState()) &amp;&amp; !stateEvent.orderState().equals(fsmOrder.getOrderState())) &#123;
                throw new FsmException(ErrorCodeEnum.ORDER_STATE_NOT_MATCH);
            &#125;
            throw new FsmException(ErrorCodeEnum.NOT_FOUND_PROCESSOR);
        &#125;
        if (CollectionUtils.isEmpty(processorResult)) &#123;
            throw new FsmException(ErrorCodeEnum.NOT_FOUND_PROCESSOR);
        &#125;
        if (processorResult.size() &gt; 1) &#123;
            throw new FsmException(ErrorCodeEnum.FOUND_MORE_PROCESSOR);
        &#125;
        return processorResult.get(0);
    &#125;
    private StateContext&lt;?&gt; getStateContext(OrderStateEvent orderStateEvent, FsmOrder fsmOrder) &#123;
        StateContext&lt;?&gt; context &#x3D; new StateContext(orderStateEvent, fsmOrder);
        return context;
    &#125;
&#125;</code></pre>

<p>检测到多个状态执行器怎么处理<br>有一点要说明，有可能根据 state+event+bizCode+sceneId 信息获取到的是多个状态处理器 processor，有可能确实业务需要单纯依赖 bizCode 和 sceneId 两个属性无法有效识别和定位唯一 processor，那么我们这里给业务开一个口、由业务决定从多个处理器中选一个适合当前上下文的，具体做法是业务 processor 通过 filter 方法根据当前 context 来判断是否符合调用条件。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">private &lt;T&gt; StateProcessor&lt;T, ?&gt; getStateProcessor(StateContext&lt;?&gt; context) &#123;
    &#x2F;&#x2F; 根据状态+事件对象获取所对应的业务处理器集合
    List&lt;AbstractStateProcessor&gt; processorList &#x3D; ...
    ......

    List&lt;AbstractStateProcessor&gt; processorResult &#x3D; new ArrayList&lt;&gt;(processorList.size());
    &#x2F;&#x2F; 根据上下文获取唯一的业务处理器
    for (AbstractStateProcessor processor : processorList) &#123;
        if (processor.filter(context)) &#123;
            processorResult.add(processor);
        &#125;
    &#125;
    ......
&#125;</code></pre>

<p>filter 在具体状态处理器 processor 中的使用举例：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">@OrderProcessor(state &#x3D; OrderStateEnum.INIT, event &#x3D; OrderEventEnum.CREATE, bizCode &#x3D; &quot;BUSINESS&quot;)
public class OrderCreatedProcessor extends AbstractStateProcessor&lt;String, CreateOrderContext&gt; &#123;
    ......
    @Override
    public boolean filter(StateContext&lt;CreateOrderContext&gt; context) &#123;
        OrderInfo orderInfo &#x3D; (OrderInfo) context.getFsmOrder();
        if (orderInfo.getServiceType() &#x3D;&#x3D; ServiceType.TAKEOFF_CAR) &#123;
            return true;
        &#125;
        return false;
    &#125;
    ......
&#125;</code></pre>

<p>当然，如果最终经过业务 filter 之后，还是有多个状态处理器符合条件，那么这里只能抛异常处理了。这个需要在开发时，对状态和多维度处理器有详细规划。</p>
<h3 id="4、状态机引擎执行总结"><a href="#4、状态机引擎执行总结" class="headerlink" title="4、状态机引擎执行总结"></a>4、状态机引擎执行总结</h3><p>状态机引擎处理流程<br>简易的状态机引擎的执行流程整理，主要介绍运行时的状态机执行过程。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122549592-582b0835-d20b-4889-ba86-306067eb9431.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u25544e7f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=801&originWidth=987&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=282340&status=done&style=none&taskId=uda26ed97-04ee-45c0-b393-a754e73870f&title=" alt="image.png"><br>状态处理器的原理<br>简易的状态机处理器的原理和依赖整理，主要介绍状态处理器的流程和细节。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/104130/1662122549670-166d5f84-6331-4825-ad55-018e84b50e54.png#clientId=u37e13d9a-1760-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5e8f7ddb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=575&originWidth=1080&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=288965&status=done&style=none&taskId=uf5cbc2d9-5897-49a3-8483-98a024b0046&title=" alt="image.png"></p>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><p>还有其他问题么，想一下。</p>
<h3 id="1、状态流转并发问题怎么处理？"><a href="#1、状态流转并发问题怎么处理？" class="headerlink" title="1、状态流转并发问题怎么处理？"></a>1、状态流转并发问题怎么处理？</h3><p>如果一个订单当前是状态 A、此刻从不同的维度或入口分别发起了不同的事件请求，此时怎么处理？<br>比如当前订单是新创建完成状态，用户发起了取消同时客服也发起了取消，在或者订单是待支付状态、系统发起了免密支付同时客服或者用户发起了改价。这些场景不管是系统照成的并发还是业务操作造成的并发，并发是真实存在的。对于这种情况、原则是同一时刻一个订单只能有一个状态变更事件可进行，其他的请求要么排队、要么返回由上游进行处理或重试等。<br>我们的做法是：</p>
<ul>
<li>在状态机 OrderFsmEngine 的 sendEvent 入口处，针对同一个订单维度加锁（redis 分布式锁）、同一时间只允许有一个状态变更操作进行，其他请求则进行排队等待。</li>
<li>在数据库层对当前 state 做校验、类似与乐观锁方式。最终是将其他请求抛错、由上游业务进行处理。</li>
</ul>
<h3 id="2、能不能动态实现状态流程的切换和编排？"><a href="#2、能不能动态实现状态流程的切换和编排？" class="headerlink" title="2、能不能动态实现状态流程的切换和编排？"></a>2、能不能动态实现状态流程的切换和编排？</h3><p>最开始我们有一个版本，状态处理器的定义不是由注解方式实现、而是将 state、event、bizCode、sceneId、processor 这些通过数据库表来保存，初始化时从数据库加载后进行处理器的装载。同时通过一个后台可以动态的调整 state、event、bizCode、sceneId、processor 对应关系、以此来达到动态灵活配置流程的效果，但是随着业务的上线，基本从来没有进行动态变更过，其实也不敢操作，毕竟状态流转事十分核心的业务、一旦因变更导致故障是不可想象的。</p>
<h3 id="3、通用性的问题"><a href="#3、通用性的问题" class="headerlink" title="3、通用性的问题"></a>3、通用性的问题</h3><p>其实不仅仅订单系统、甚至不仅是状态机逻辑可以用上面讲的这些思路处理，很多日常中其他一些多维度的业务都可以采取这些方案进行处理。<br>其实这套状态机引擎还是比较简单的、对于业务扩展点处的定义也不是十分友好，需要从执行具体扩展点实现的角度出发，达到标准流程和具体业务逻辑分离的效果。当然不管那种方案，扩展点的定义是业务需要核心关心和友好封装的事情。</p>

</div>
<footer class="post-meta">
    <span class="post-tag">
        
        <span class="post-meta-item-icon">
                <i class="fa far fa-folder-open"></i>
            </span>
        
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                <a href="/tags/Architecture/" itemprop="url" rel="index">
                  <span itemprop="name">Architecture</span>
                </a>
            </span>
        
        
    </span>
</footer>

<div class="author">
    <!--个人信息-->
    
    <img class="author-image qrcode" itemprop="image"
         src="https://cdn.alicharles.com/static/images/mp_qrcode.jpg"
         alt="https://cdn.alicharles.com/static/images/mp_qrcode.jpg"/>
    
</div>


<div class="post-nav">
    <div class="post-nav-next post-nav-item">
        
        <a href="/article/ddd/explicit-architecture/" rel="next" title="DDD（六）清晰架构">
            <i class="fa far fa-chevron-left"></i> DDD（六）清晰架构
        </a>
        
    </div>
    <span class="post-nav-divider"></span>
    <div class="post-nav-prev post-nav-item">
        
    </div>
</div>

        </section>
    </div>
    <div id="post-toc" class="post-toc">
        <div class="post-toc-title">文章目录</div>
        <div class="post-toc-content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF"><span class="toc-text">一、背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-text">二、实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BA%B5%E5%90%91%E8%A7%A3%E5%86%B3%E4%B8%9A%E5%8A%A1%E9%9A%94%E7%A6%BB%E5%92%8C%E6%B5%81%E7%A8%8B%E7%BC%96%E6%8E%92"><span class="toc-text">1、纵向解决业务隔离和流程编排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A8%AA%E5%90%91%E8%A7%A3%E5%86%B3%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E6%89%A9%E5%B1%95"><span class="toc-text">2、横向解决逻辑复用和实现业务扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%E6%B5%81%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">3、状态迁移流程的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%8A%B6%E6%80%81%E6%9C%BA%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%80%BB%E7%BB%93"><span class="toc-text">4、状态机引擎执行总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-text">三、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">1、状态流转并发问题怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%83%BD%E4%B8%8D%E8%83%BD%E5%8A%A8%E6%80%81%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E5%92%8C%E7%BC%96%E6%8E%92%EF%BC%9F"><span class="toc-text">2、能不能动态实现状态流程的切换和编排？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%80%9A%E7%94%A8%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3、通用性的问题</span></a></li></ol></li></ol>
        </div>
    </div>
    
</div>

  <!-- footer -->
  <div class="footer">
    <div class="container justify-content-center py-4">
        Charles &copy;2022 &nbsp <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备14035515号-1</a></span> &nbsp
        <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253510913'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1253510913%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
    </div>

    <!-- scrollTop -->
    <div class="go-top">
        <i class="fas fa-arrow-up"></i>
    </div>

    <!-- js -->
    <script src="//cdn.alicharles.com/static/lib/jquery/jquery.min.js"></script>
    <script src="//cdn.alicharles.com/static/lib/popper.js/popper.js"></script>
    <script src="//cdn.alicharles.com/static/lib/bootstrap/js/bootstrap.min.js"></script>
    <script src="//cdn.alicharles.com/static/lib/prism/js/prism.js"></script>
    <script src="//cdn.alicharles.com/static/js/app.js"></script>

    
</div>
</body>

</html>
