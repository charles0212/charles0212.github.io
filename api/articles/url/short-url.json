{"title":"短链生成","slug":"yuque/短链生成","date":"2019-06-20T16:00:00.000Z","updated":"2022-05-15T04:19:28.496Z","comments":true,"path":"api/articles/url/short-url.json","excerpt":"背景当前短地址发号使用 hbase 的increament 指令,每个转短请求都会做一次操作, 当 qps超过 1k 时, 会造成 hbase机器报警, 需要减少 hbase 的increament 指令调用方案修改为每个请求在本地取号,当本地无号可取时请求 hbase 发号,每次在 hbase 中调用increament 时取 100个号, 回到本地具体代码流程 * 加全局锁,   所有转短请求在取号前通过全局锁串行 * 尝试本地取号, 如果不成功, 去   hbase 取号 100 个,   放入本地缓存 * 解锁, 并继续原有转短流程","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1646818360387-c606b10f-0666-4543-a76d-19919097f615.png#clientId=ubd7c2cee-e4f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=44&id=u6e000831&margin=%5Bobject%20Object%5D&name=image.png&originHeight=44&originWidth=541&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9956&status=done&style=none&taskId=u07c03a37-7e88-4869-af19-704523d54b4&title=&width=541","https://cdn.nlark.com/yuque/0/2022/png/104130/1646818507763-fd691c4a-0b77-4895-9286-20aa70fbe593.png#clientId=ubd7c2cee-e4f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=ue2bfc6fe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=267&originWidth=297&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=21991&status=done&style=none&taskId=uab6c0ba0-3092-49fb-acc0-a061e2ea13a&title=&width=297"],"content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>当前短地址发号使用 hbase 的 increament 指令, 每个转短请求都会做一次操作, 当 qps 超过 1k 时, 会造成 hbase 机器报警, 需要减少 hbase 的 increament 指令调用</p>\n<h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>修改为每个请求在本地取号, 当本地无号可取时请求 hbase 发号, 每次在 hbase 中调用 increament 时取 100 个号, 回到本地</p>\n<h2 id=\"具体代码流程\"><a href=\"#具体代码流程\" class=\"headerlink\" title=\"具体代码流程\"></a>具体代码流程</h2><ul>\n<li>加全局锁, 所有转短请求在取号前通过全局锁串行</li>\n<li>尝试本地取号, 如果不成功, 去 hbase 取号 100 个, 放入本地缓存</li>\n<li>解锁, 并继续原有转短流程</li>\n</ul>\n<p>待确认的点，全局锁是否需要公平 公平锁的性能是否满足需求</p>\n<h2 id=\"修改背景\"><a href=\"#修改背景\" class=\"headerlink\" title=\"修改背景\"></a>修改背景</h2><p>商家有需求需要定制自己的域名不使用有赞的默认域名。<br>定制的过程涉及到一个 VIP 域名的发布，这个发布涉及到前端，后端，运维的一个 VIP 域名的维护，现在是 iron，node，后端，运维都维护了一个 VIP 名单，存储的位置也是各自维护的，之前发布过程每次发布都会有白名单不同步问题导致 VIP 商户的功能挂掉。<br>上午讨论的结果同步：<br>上午和前端，后端，运维的同事讨论了下，使用 apollo 统一维护一份域名，每次更改这份配置将自动同步到其他不同的端，保证数据的维护的一致性。</p>\n<ul>\n<li>短地址修改方案</li>\n</ul>\n<p>短地址白名单修改为由动态白名单和静态白名单合并得到，动态白名单从 apollo 中获取，静态白名单在启动时配置。<br>apollo 配置格式为 json 格式，数据结构为 map，key 为 kdtid，value 为对应域名</p>\n<ul>\n<li>可能影响的场景<ul>\n<li>静态白名单的有效性<ul>\n<li>静态白名单中配置的域名应该始终可以成功进行转短链</li>\n</ul>\n</li>\n<li>动态白名单的有效性<ul>\n<li>动态白名单中配置的域名应该可以成功转短链</li>\n<li>当 apollo 中配置的动态白名单添加域名后，新增加的域名应该可以成功转短链</li>\n<li>当 apollo 中配置的动态白名单减少部分域名后，如减少的域名不在静态白名单中，则该域名应该转短链失败</li>\n<li>当 apollo 中配置的动态白名单减少部分域名后，如减少的域名在静态白名单中，则该域名应该可以成功转短链</li>\n<li>当 apollo 中白名单配置为空时，应该只有静态白名单中的域名可以成功转短链</li>\n</ul>\n</li>\n<li>动态白名单无法获取或是失效场景<ul>\n<li>当 apollo 中配置的动态白名单不符合 json 的 map 格式时，视为动态白名单配空，与 2.e 场景一致</li>\n<li>当 apollo 无法正常读取到白名单配置项时，将最后一次成功读取的值视为动态白名单的值，该值保存在 apollo-config.json 文件中</li>\n</ul>\n</li>\n<li>短转长的场景<ul>\n<li>经产品确认，该场景不受白名单限制，无论域名是否还在白名单中，短转长都应该正常进行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"主要的方案有两种\"><a href=\"#主要的方案有两种\" class=\"headerlink\" title=\"主要的方案有两种\"></a>主要的方案有两种</h2><ol>\n<li>hash 算法: hash 长地址得到一个短地址</li>\n<li>发号器：通过发号器得到一个整数，再转为 62 进制</li>\n</ol>\n<h2 id=\"两种方案的优缺点\"><a href=\"#两种方案的优缺点\" class=\"headerlink\" title=\"两种方案的优缺点\"></a>两种方案的优缺点</h2><ol>\n<li><p>hash 方案的优点: 生成的短链不可遍历</p>\n</li>\n<li><p>hash 方案的缺点：位数较短时，生成的短链容易冲突，碰撞的概率可由如下公式得出：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646818360387-c606b10f-0666-4543-a76d-19919097f615.png#clientId=ubd7c2cee-e4f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=44&id=u6e000831&margin=%5Bobject%20Object%5D&name=image.png&originHeight=44&originWidth=541&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9956&status=done&style=none&taskId=u07c03a37-7e88-4869-af19-704523d54b4&title=&width=541\" alt=\"image.png\"><br>当生成的短链为 8 位，且为 62 进制时，在 hash 了 3kw 次时，碰撞的概率为 1&#x2F;2, 我们要求生成的短链接为 6 位，且目前每日的增长量为 200w，显然不符合我们的要求</p>\n</li>\n<li><p>发号器的优点：生成的短链必定不会碰撞</p>\n</li>\n<li><p>发号器的缺点：同一个 url 分两次不同的时间，生成结果不一致，且 url 容易被遍历</p>\n</li>\n</ol>\n<h2 id=\"最终采取的方案\"><a href=\"#最终采取的方案\" class=\"headerlink\" title=\"最终采取的方案\"></a>最终采取的方案</h2><p>选择发号器，且做了一些方案上的优化解决了发号器的缺点：</p>\n<ol>\n<li>预先生成一亿个短链接，并随机打乱插入到 mysql，这样通过发号器拿到的 id 去更新数据库的对应主键短链，解决了短链容易被遍历，且为将来的横向扩展做了准备，当数据量即将一亿时，再重新准备插入一亿的纪录到新的 mysql 实例</li>\n<li>用 redis 缓存了最近一天的长链，每次生成短链先去 redis 查，这样同一个长链接在一天内反复生成的短链相同，并且每次查询成功时，更新 key 的过期时间，所以热门的短链很大可能上生成的都是同一个短链。</li>\n</ol>\n<h2 id=\"短地址店铺隔离改造\"><a href=\"#短地址店铺隔离改造\" class=\"headerlink\" title=\"短地址店铺隔离改造\"></a>短地址店铺隔离改造</h2><ul>\n<li>改造背景：为规避腾讯风控，短地址改为不同商家使用不同的域名访问，同时增加对不同调用方的接入管理</li>\n<li>改造方案：<ul>\n<li>长转短：<ul>\n<li>接口输入参数为 长地址，访问限制域名，调用方 app_name，版本号</li>\n<li>按照原有方案生成短地址，将短地址和长地址以及对应域名的关系存入 hbase，以供短转长时校验</li>\n</ul>\n</li>\n<li>短转长：<ul>\n<li>接口输入参数为短地址，调用方 app_name， 版本号</li>\n<li>hbase 中查询到长地址和访问限制域名，校验 hbase 中的访问限制域名与参数中短地址访问的域名是否一致，如一致，按原流程返回，否则报错</li>\n</ul>\n</li>\n<li>接入管理：<ul>\n<li>前期先通过人工接入，后续改造接入 ops</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"短地址监控\"><a href=\"#短地址监控\" class=\"headerlink\" title=\"短地址监控\"></a>短地址监控</h2><p>监控接口 curl -H “Host: <a href=\"http://kdt.im/\">kdt.im</a>“ “<a href=\"http://127.0.0.1/shorturl_status\">http://127.0.0.1/shorturl_status</a><br>监控分四个维度:</p>\n<ul>\n<li>redis<br>a. hit: 缓存的命中次数<br>b. miss：缓存的 miss 次数，当 miss 上升时需引起注意<br>c. error：error 次数，任何非正常情况下的错误，当 error 上升时，需要立刻查看日志排查问题</li>\n<li>mysql<br>a. update: 短链的更新次数<br>b. select: 缓存失效，数据库查询的次数，当次数上升时需关注<br>c. error: error 次数，任何非正常情况下的错误，当 error 上升时，需要立刻查看日志排查问题</li>\n<li>lock<br>a. get: 缓存失效时，获取的锁，当次数上升时需关注<br>b. error: 任何非正常情况下的错误，当 error 上升时，需要立刻查看日志排查问题</li>\n<li>发号器<br>a. current: 发号器当前的号，当发号即将达到预设的一亿、二亿时，需要进行扩容<br>b. error: 任何非正常情况下的错误，当 error 上升时，需要立刻查看日志排查问题</li>\n</ul>\n<h2 id=\"短地址部署容量\"><a href=\"#短地址部署容量\" class=\"headerlink\" title=\"短地址部署容量\"></a>短地址部署容量</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646818507763-fd691c4a-0b77-4895-9286-20aa70fbe593.png#clientId=ubd7c2cee-e4f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=ue2bfc6fe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=267&originWidth=297&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=21991&status=done&style=none&taskId=uab6c0ba0-3092-49fb-acc0-a061e2ea13a&title=&width=297\" alt=\"image.png\"><br>nginx 的 qps 单机过万，umem 的 qps 单机过万，只有 udb 的 tps 单机只有 800， 目前整个系统的瓶颈在 udb</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># &#x2F;opt&#x2F;wrk&#x2F;bin&#x2F;wrk -t 4 -c 4 -d 3600s --script get.lua http:&#x2F;&#x2F;127.0.0.1\nRunning 60m test @ http:&#x2F;&#x2F;127.0.0.1\n4 threads and 4 connections\nThread Stats   Avg      Stdev     Max   +&#x2F;- Stdev\nLatency    19.86ms   62.22ms   1.00s    93.87%\nReq&#x2F;Sec   198.29     59.82   474.00     84.81%\n2714028 requests in 60.00m, 832.96MB read\nRequests&#x2F;sec:    753.88\nTransfer&#x2F;sec:    236.93KB</code></pre>\n\n<p>&#x2F;data&#x2F;shorturl&#x2F;src&#x2F;config.lua<br>因为没有配置解析器，不要配置有域名，直接换成 ip，tengine 要换成 openresty</p>\n<p>短链链接使用 6 位字符，62^6 &#x3D; 568 亿，a-zA-Z0-9 这 62 位取 6 位组合,可产生 500 多亿个组合数量。把数字和字符组合做一定的映射，就可以产生唯一的字符串，如第 62 个组合就是 aaaaa9，第 63 个组合就是 aaaaba，再利用洗牌算法，把原字符串打乱后保存，那么对应位置的组合字符串就会是无序的组合。</p>\n<p>把长网址存入数据库，取返回的 id，找出对应的字符串，例如返回 ID 为 1，那么对应上面的字符串组合就是 bbb，同理 ID 为 2 时，字符串组合为 bba，依次类推，直至到达 64 种组合后才会出现重复的可能，所以如果用上面的 62 个字符，任意取 6 个字符组合成字符串的话，你的数据存量达到 500 多亿后才会出现重复的可能。</p>\n","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>当前短地址发号使用 hbase 的 increament 指令, 每个转短请求都会做一次操作, 当 qps 超过 1k 时, 会造成 hbase 机器报警, 需要减少 hbase 的 increament 指令调用</p>\n<h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>修改为每个请求在本地取号, 当本地无号可取时请求 hbase 发号, 每次在 hbase 中调用 increament 时取 100 个号, 回到本地</p>\n<h2 id=\"具体代码流程\"><a href=\"#具体代码流程\" class=\"headerlink\" title=\"具体代码流程\"></a>具体代码流程</h2><ul>\n<li>加全局锁, 所有转短请求在取号前通过全局锁串行</li>\n<li>尝试本地取号, 如果不成功, 去 hbase 取号 100 个, 放入本地缓存</li>\n<li>解锁, 并继续原有转短流程</li>\n</ul>\n<p>待确认的点，全局锁是否需要公平 公平锁的性能是否满足需求</p>\n<h2 id=\"修改背景\"><a href=\"#修改背景\" class=\"headerlink\" title=\"修改背景\"></a>修改背景</h2><p>商家有需求需要定制自己的域名不使用有赞的默认域名。<br>定制的过程涉及到一个 VIP 域名的发布，这个发布涉及到前端，后端，运维的一个 VIP 域名的维护，现在是 iron，node，后端，运维都维护了一个 VIP 名单，存储的位置也是各自维护的，之前发布过程每次发布都会有白名单不同步问题导致 VIP 商户的功能挂掉。<br>上午讨论的结果同步：<br>上午和前端，后端，运维的同事讨论了下，使用 apollo 统一维护一份域名，每次更改这份配置将自动同步到其他不同的端，保证数据的维护的一致性。</p>\n<ul>\n<li>短地址修改方案</li>\n</ul>\n<p>短地址白名单修改为由动态白名单和静态白名单合并得到，动态白名单从 apollo 中获取，静态白名单在启动时配置。<br>apollo 配置格式为 json 格式，数据结构为 map，key 为 kdtid，value 为对应域名</p>\n<ul>\n<li>可能影响的场景<ul>\n<li>静态白名单的有效性<ul>\n<li>静态白名单中配置的域名应该始终可以成功进行转短链</li>\n</ul>\n</li>\n<li>动态白名单的有效性<ul>\n<li>动态白名单中配置的域名应该可以成功转短链</li>\n<li>当 apollo 中配置的动态白名单添加域名后，新增加的域名应该可以成功转短链</li>\n<li>当 apollo 中配置的动态白名单减少部分域名后，如减少的域名不在静态白名单中，则该域名应该转短链失败</li>\n<li>当 apollo 中配置的动态白名单减少部分域名后，如减少的域名在静态白名单中，则该域名应该可以成功转短链</li>\n<li>当 apollo 中白名单配置为空时，应该只有静态白名单中的域名可以成功转短链</li>\n</ul>\n</li>\n<li>动态白名单无法获取或是失效场景<ul>\n<li>当 apollo 中配置的动态白名单不符合 json 的 map 格式时，视为动态白名单配空，与 2.e 场景一致</li>\n<li>当 apollo 无法正常读取到白名单配置项时，将最后一次成功读取的值视为动态白名单的值，该值保存在 apollo-config.json 文件中</li>\n</ul>\n</li>\n<li>短转长的场景<ul>\n<li>经产品确认，该场景不受白名单限制，无论域名是否还在白名单中，短转长都应该正常进行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"主要的方案有两种\"><a href=\"#主要的方案有两种\" class=\"headerlink\" title=\"主要的方案有两种\"></a>主要的方案有两种</h2><ol>\n<li>hash 算法: hash 长地址得到一个短地址</li>\n<li>发号器：通过发号器得到一个整数，再转为 62 进制</li>\n</ol>\n<h2 id=\"两种方案的优缺点\"><a href=\"#两种方案的优缺点\" class=\"headerlink\" title=\"两种方案的优缺点\"></a>两种方案的优缺点</h2><ol>\n<li><p>hash 方案的优点: 生成的短链不可遍历</p>\n</li>\n<li><p>hash 方案的缺点：位数较短时，生成的短链容易冲突，碰撞的概率可由如下公式得出：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646818360387-c606b10f-0666-4543-a76d-19919097f615.png#clientId=ubd7c2cee-e4f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=44&id=u6e000831&margin=%5Bobject%20Object%5D&name=image.png&originHeight=44&originWidth=541&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9956&status=done&style=none&taskId=u07c03a37-7e88-4869-af19-704523d54b4&title=&width=541\" alt=\"image.png\"><br>当生成的短链为 8 位，且为 62 进制时，在 hash 了 3kw 次时，碰撞的概率为 1&#x2F;2, 我们要求生成的短链接为 6 位，且目前每日的增长量为 200w，显然不符合我们的要求</p>\n</li>\n<li><p>发号器的优点：生成的短链必定不会碰撞</p>\n</li>\n<li><p>发号器的缺点：同一个 url 分两次不同的时间，生成结果不一致，且 url 容易被遍历</p>\n</li>\n</ol>\n<h2 id=\"最终采取的方案\"><a href=\"#最终采取的方案\" class=\"headerlink\" title=\"最终采取的方案\"></a>最终采取的方案</h2><p>选择发号器，且做了一些方案上的优化解决了发号器的缺点：</p>\n<ol>\n<li>预先生成一亿个短链接，并随机打乱插入到 mysql，这样通过发号器拿到的 id 去更新数据库的对应主键短链，解决了短链容易被遍历，且为将来的横向扩展做了准备，当数据量即将一亿时，再重新准备插入一亿的纪录到新的 mysql 实例</li>\n<li>用 redis 缓存了最近一天的长链，每次生成短链先去 redis 查，这样同一个长链接在一天内反复生成的短链相同，并且每次查询成功时，更新 key 的过期时间，所以热门的短链很大可能上生成的都是同一个短链。</li>\n</ol>\n<h2 id=\"短地址店铺隔离改造\"><a href=\"#短地址店铺隔离改造\" class=\"headerlink\" title=\"短地址店铺隔离改造\"></a>短地址店铺隔离改造</h2><ul>\n<li>改造背景：为规避腾讯风控，短地址改为不同商家使用不同的域名访问，同时增加对不同调用方的接入管理</li>\n<li>改造方案：<ul>\n<li>长转短：<ul>\n<li>接口输入参数为 长地址，访问限制域名，调用方 app_name，版本号</li>\n<li>按照原有方案生成短地址，将短地址和长地址以及对应域名的关系存入 hbase，以供短转长时校验</li>\n</ul>\n</li>\n<li>短转长：<ul>\n<li>接口输入参数为短地址，调用方 app_name， 版本号</li>\n<li>hbase 中查询到长地址和访问限制域名，校验 hbase 中的访问限制域名与参数中短地址访问的域名是否一致，如一致，按原流程返回，否则报错</li>\n</ul>\n</li>\n<li>接入管理：<ul>\n<li>前期先通过人工接入，后续改造接入 ops</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"短地址监控\"><a href=\"#短地址监控\" class=\"headerlink\" title=\"短地址监控\"></a>短地址监控</h2><p>监控接口 curl -H “Host: <a href=\"http://kdt.im/\">kdt.im</a>“ “<a href=\"http://127.0.0.1/shorturl_status\">http://127.0.0.1/shorturl_status</a><br>监控分四个维度:</p>\n<ul>\n<li>redis<br>a. hit: 缓存的命中次数<br>b. miss：缓存的 miss 次数，当 miss 上升时需引起注意<br>c. error：error 次数，任何非正常情况下的错误，当 error 上升时，需要立刻查看日志排查问题</li>\n<li>mysql<br>a. update: 短链的更新次数<br>b. select: 缓存失效，数据库查询的次数，当次数上升时需关注<br>c. error: error 次数，任何非正常情况下的错误，当 error 上升时，需要立刻查看日志排查问题</li>\n<li>lock<br>a. get: 缓存失效时，获取的锁，当次数上升时需关注<br>b. error: 任何非正常情况下的错误，当 error 上升时，需要立刻查看日志排查问题</li>\n<li>发号器<br>a. current: 发号器当前的号，当发号即将达到预设的一亿、二亿时，需要进行扩容<br>b. error: 任何非正常情况下的错误，当 error 上升时，需要立刻查看日志排查问题</li>\n</ul>\n<h2 id=\"短地址部署容量\"><a href=\"#短地址部署容量\" class=\"headerlink\" title=\"短地址部署容量\"></a>短地址部署容量</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646818507763-fd691c4a-0b77-4895-9286-20aa70fbe593.png#clientId=ubd7c2cee-e4f0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=ue2bfc6fe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=267&originWidth=297&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=21991&status=done&style=none&taskId=uab6c0ba0-3092-49fb-acc0-a061e2ea13a&title=&width=297\" alt=\"image.png\"><br>nginx 的 qps 单机过万，umem 的 qps 单机过万，只有 udb 的 tps 单机只有 800， 目前整个系统的瓶颈在 udb</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># &#x2F;opt&#x2F;wrk&#x2F;bin&#x2F;wrk -t 4 -c 4 -d 3600s --script get.lua http:&#x2F;&#x2F;127.0.0.1\nRunning 60m test @ http:&#x2F;&#x2F;127.0.0.1\n4 threads and 4 connections\nThread Stats   Avg      Stdev     Max   +&#x2F;- Stdev\nLatency    19.86ms   62.22ms   1.00s    93.87%\nReq&#x2F;Sec   198.29     59.82   474.00     84.81%\n2714028 requests in 60.00m, 832.96MB read\nRequests&#x2F;sec:    753.88\nTransfer&#x2F;sec:    236.93KB</code></pre>\n\n<p>&#x2F;data&#x2F;shorturl&#x2F;src&#x2F;config.lua<br>因为没有配置解析器，不要配置有域名，直接换成 ip，tengine 要换成 openresty</p>\n<p>短链链接使用 6 位字符，62^6 &#x3D; 568 亿，a-zA-Z0-9 这 62 位取 6 位组合,可产生 500 多亿个组合数量。把数字和字符组合做一定的映射，就可以产生唯一的字符串，如第 62 个组合就是 aaaaa9，第 63 个组合就是 aaaaba，再利用洗牌算法，把原字符串打乱后保存，那么对应位置的组合字符串就会是无序的组合。</p>\n<p>把长网址存入数据库，取返回的 id，找出对应的字符串，例如返回 ID 为 1，那么对应上面的字符串组合就是 bbb，同理 ID 为 2 时，字符串组合为 bba，依次类推，直至到达 64 种组合后才会出现重复的可能，所以如果用上面的 62 个字符，任意取 6 个字符组合成字符串的话，你的数据存量达到 500 多亿后才会出现重复的可能。</p>\n","categories":[{"name":"short-url","path":"api/categories/short-url.json"}],"tags":[{"name":"ShortUrl","path":"api/tags/ShortUrl.json"}]}