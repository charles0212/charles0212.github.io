{"title":"Redis（八）Zset结构和跳表SkipList","slug":"yuque/Redis（八）Zset结构和跳表SkipList","date":"2020-07-27T16:00:00.000Z","updated":"2022-09-09T13:07:16.843Z","comments":true,"path":"api/articles/redis/redis-zset.json","excerpt":"zset 是 redis中一种有序、不重复的数据类型，每个元素都有一个分值，它可用于实现排行榜单，其底层采用压缩表ziplist 或跳表 skiplist的数据结构实现Zset 的两种数据结构压缩表 ziplist当 redis插入第一个元素时，同时满足以下条件，就会以ziplist 创建跳表 1. 节点数量<128 （可通过    server.zset_max_ziplist_entries    设置） 2. 节点的长度<64（可通过    server.zset_max_ziplist_value    设置）当选择用 ziplist 实现 ","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1650878212810-ddb1db61-8c5d-47c8-ac3a-e30457666c03.png#clientId=uea216351-f775-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u739a6637&margin=%5Bobject%20Object%5D&name=image.png&originHeight=336&originWidth=631&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=149505&status=done&style=none&taskId=u61305bee-da14-4bcd-8e91-277a09a8e21&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1650878213036-208043fc-90e4-4488-9f5a-f34c509d4da0.png#clientId=uea216351-f775-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud81fee3f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=844&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=303815&status=done&style=none&taskId=ufcbbd68e-b657-41d6-8b58-9f316527db1&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1650878212874-468dd1ea-91cb-4de3-ad77-c50e53f6b687.png#clientId=uea216351-f775-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc4457562&margin=%5Bobject%20Object%5D&name=image.png&originHeight=222&originWidth=704&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=90372&status=done&style=none&taskId=uc93f278f-d867-40f2-ba7b-1a90e738d29&title="],"content":"<p>zset 是 redis 中一种有序、不重复的数据类型，<strong>每个元素都有一个分值，它可用于实现排行榜单</strong>，其底层采用压缩表 ziplist 或跳表 skiplist 的数据结构实现</p>\n<h2 id=\"Zset-的两种数据结构\"><a href=\"#Zset-的两种数据结构\" class=\"headerlink\" title=\"Zset 的两种数据结构\"></a>Zset 的两种数据结构</h2><h3 id=\"压缩表-ziplist\"><a href=\"#压缩表-ziplist\" class=\"headerlink\" title=\"压缩表 ziplist\"></a>压缩表 ziplist</h3><p>当 redis 插入第一个元素时，同时满足以下条件，就会以 ziplist 创建跳表</p>\n<ol>\n<li>节点数量&lt;128 （可通过 server.zset_max_ziplist_entries 设置）</li>\n<li>节点的长度&lt;64（可通过 server.zset_max_ziplist_value 设置）</li>\n</ol>\n<p>当选择用 ziplist 实现 zset 后，以后插入的节点若不满足以上任一个条件，就会转为 skiplist</p>\n<h3 id=\"跳表-skiplist\"><a href=\"#跳表-skiplist\" class=\"headerlink\" title=\"跳表 skiplist\"></a>跳表 skiplist</h3><p>跳表的本质是一个多层链表，它能快速地查询、插入、删除【时间复杂度均为 O(logn)】，所以它的查询速度媲美平衡二叉树，而且它的数据结构比平衡二叉树简单，结构示意图如下:</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1650878212810-ddb1db61-8c5d-47c8-ac3a-e30457666c03.png#clientId=uea216351-f775-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u739a6637&margin=%5Bobject%20Object%5D&name=image.png&originHeight=336&originWidth=631&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=149505&status=done&style=none&taskId=u61305bee-da14-4bcd-8e91-277a09a8e21&title=\" alt=\"image.png\"><br>特点：</p>\n<ul>\n<li>跳表的最底层拥有所有的元素</li>\n<li>跳表每一层都是一个链表，除了最底层是原始链表，层次逐渐往上可分别划分为一级索引层、二级索引层…</li>\n<li>跳表插入元素时，会先随机生成出一个“层次数字”，然后元素会插入到这个层次的所有底层，直到原始链表层</li>\n<li>如果一个元素存在与某个索引层，那么这个元素也会存在于低于它的所有索引下层，如元素在第 99 索引层，那么由上到下从 99 索引层直到原始链表层都会存在该元素</li>\n<li>空间换时间，跳表查找变快了，但是要存储许多索引层，故空间开销变大了</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 产生节点的高度。使用抛硬币\n *\n * @return\n *&#x2F;\nprivate int getRandomLevel() &#123;\n  &#x2F;&#x2F; 可知，元素的插入层次i从1开始自增，随机到哪一层的概率就像抛硬币一样，都是50%，故i越往后，其概率越小(每次都*0.5)\n  &#x2F;&#x2F; 第一层概率：0.5，第二层0.5*0.5&#x3D;0.25，...\n  int lev &#x3D; 1;\n  while (random.nextInt() % 2 &#x3D;&#x3D; 0) &#123;\n    lev++;\n  &#125;\n  &#x2F;&#x2F; MAX_LEVEL为跳表的最大层级\n  return lev &gt; MAX_LEVEL ? MAX_LEVEL : lev;\n&#125;</code></pre>\n\n<ul>\n<li>插入节点</li>\n<li>插入的时间复杂度为 O(logn)，每次插入都会先查找到要插入的位置（查找的时间复杂度就已经是【O(logn)】了，找到后直接插入【O(1)】，所以总的为【O(logn)】），删除也是同理为 O(logn)</li>\n<li>每个节点的插入层次是通过 getRandomLevel()随机出来的，插入层次互不影响<br>以下模拟节点插入：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1650878213036-208043fc-90e4-4488-9f5a-f34c509d4da0.png#clientId=uea216351-f775-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud81fee3f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=844&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=303815&status=done&style=none&taskId=ufcbbd68e-b657-41d6-8b58-9f316527db1&title=\" alt=\"image.png\"></p>\n<ul>\n<li>查找</li>\n</ul>\n<p>查找节点时，从高索引层往低索引层查找：<br>一开始元素在高层从链表由前往后查找，直到要查找的目标元素在该层的某两个相邻元素之间，就会往下跳到下层的同一个位置，继续从同一位置向链表尾方向遍历查询-&gt;重复上面的过程，直到查找到目标元素<br>查找时每一层都跳过部分元素，进而加快了查找效率，以下模拟节点查找：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1650878212874-468dd1ea-91cb-4de3-ad77-c50e53f6b687.png#clientId=uea216351-f775-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc4457562&margin=%5Bobject%20Object%5D&name=image.png&originHeight=222&originWidth=704&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=90372&status=done&style=none&taskId=uc93f278f-d867-40f2-ba7b-1a90e738d29&title=\" alt=\"image.png\"></p>\n<h2 id=\"跳表简单实现\"><a href=\"#跳表简单实现\" class=\"headerlink\" title=\"跳表简单实现\"></a>跳表简单实现</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.Random;\n\npublic class SkipList &#123;\n    private static final int MAX_LEVEL &#x3D; 16;\n    private int levelCount &#x3D; 1;\n    private Node head &#x3D; new Node();\n    private Random random &#x3D; new Random();\n\n    public Node find(int value)&#123;\n        Node p &#x3D; head;\n        for(int i &#x3D; levelCount - 1; i &gt;&#x3D; 0; i--)&#123;\n            &#x2F;&#x2F;如果在这一个level上存在下一个数据节点且下一个数据节点的值小于value，p往后挪一个\n            &#x2F;&#x2F;直到这一个level走完或者值在区间内，切换下一个层级\n            while(p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value)&#123;\n                p &#x3D; p.forwards[i];\n            &#125;\n        &#125;\n        &#x2F;&#x2F;到最下层依照上面的索引找到的位置往后找一位即可判断\n        if(p.forwards[0] !&#x3D; null &amp;&amp; p.forwards[0].data &#x3D;&#x3D; value) return p.forwards[0];\n        return null;\n    &#125;\n\n    public void insert(int value)&#123;\n        Node p &#x3D; head;\n        int level &#x3D; randomLevel();\n        Node node &#x3D; new Node();\n        node.data &#x3D; value;\n        node.maxLevel &#x3D; level;\n        &#x2F;&#x2F;记录要更新的node\n        Node update[] &#x3D; new Node[level];\n        &#x2F;&#x2F;插入一个新的node，主要目标更新保存的forwards\n        for(int i &#x3D; level; i &gt;&#x3D; 0; i--)&#123;\n            &#x2F;&#x2F;在计算得到的level中依次找适合的位置\n            while(p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value)&#123;\n                p &#x3D; p.forwards[i];\n            &#125;\n            update[i] &#x3D; p;\n        &#125;\n        &#x2F;&#x2F;更新指向\n        for(int i &#x3D; 0; i &lt; level; i++)&#123;\n            node.forwards[i] &#x3D; update[i].forwards[i];\n            update[i].forwards[i] &#x3D; node;\n        &#125;\n        if(levelCount &lt; level) levelCount &#x3D; level;\n    &#125;\n\n    public void delete(int value)&#123;\n        Node[] deleteNode &#x3D; new Node[MAX_LEVEL];\n        Node p &#x3D; head;\n        for(int i &#x3D; levelCount - 1; i &gt;&#x3D;0; i--)&#123;\n            &#x2F;&#x2F;确定每个层级中要删除的value对应的node\n            while(p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value)&#123;\n                p &#x3D; p.forwards[i];\n            &#125;\n            &#x2F;&#x2F;当前level中要删除的p，更新到node数组中\n            deleteNode[i] &#x3D; p;\n        &#125;\n        &#x2F;&#x2F;从底层扫，每层删除\n        if(p.forwards[0] !&#x3D; null &amp;&amp; p.forwards[0].data &#x3D;&#x3D; value)&#123;\n            &#x2F;&#x2F;根据上面deleteNode[]中保存的要删除的node，更新前后的指向\n            for(int i &#x3D; levelCount - 1; i &gt;&#x3D; 0; i--)&#123;\n                if(deleteNode[i] !&#x3D; null &amp;&amp; deleteNode[i].forwards[i].data &#x3D;&#x3D; value)&#123;\n                    deleteNode[i].forwards[i] &#x3D; deleteNode[i].forwards[i].forwards[i];\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    public void printAll()&#123;\n        Node p &#x3D; head;\n        while(p.forwards[0] !&#x3D; null)&#123;\n            System.out.print(p.forwards[0] + &quot; &quot;);\n            p &#x3D; p.forwards[0];\n        &#125;\n        System.out.println();\n    &#125;\n\n    private int randomLevel() &#123;\n        int level &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; MAX_LEVEL; i++)&#123;\n            if(random.nextInt()%2 &#x3D;&#x3D; 1)&#123;\n                level++;\n            &#125;\n        &#125;\n        return level;\n    &#125;\n\n    class Node&#123;\n        private int data;\n        &#x2F;&#x2F;核心在这个forwards数组，他存放了各个level索引的下一个数据节点\n        private Node[] forwards &#x3D; new Node[MAX_LEVEL];\n        private int maxLevel;\n\n        public String toString()&#123;\n            StringBuilder sb &#x3D; new StringBuilder();\n            sb.append(&quot;&#123;data: &quot;);\n            sb.append(data);\n            sb.append(&quot;; level: &quot;);\n            sb.append(maxLevel);\n            sb.append(&quot; &#125;&quot;);\n            return sb.toString();\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n","more":"<p>zset 是 redis 中一种有序、不重复的数据类型，<strong>每个元素都有一个分值，它可用于实现排行榜单</strong>，其底层采用压缩表 ziplist 或跳表 skiplist 的数据结构实现</p>\n<h2 id=\"Zset-的两种数据结构\"><a href=\"#Zset-的两种数据结构\" class=\"headerlink\" title=\"Zset 的两种数据结构\"></a>Zset 的两种数据结构</h2><h3 id=\"压缩表-ziplist\"><a href=\"#压缩表-ziplist\" class=\"headerlink\" title=\"压缩表 ziplist\"></a>压缩表 ziplist</h3><p>当 redis 插入第一个元素时，同时满足以下条件，就会以 ziplist 创建跳表</p>\n<ol>\n<li>节点数量&lt;128 （可通过 server.zset_max_ziplist_entries 设置）</li>\n<li>节点的长度&lt;64（可通过 server.zset_max_ziplist_value 设置）</li>\n</ol>\n<p>当选择用 ziplist 实现 zset 后，以后插入的节点若不满足以上任一个条件，就会转为 skiplist</p>\n<h3 id=\"跳表-skiplist\"><a href=\"#跳表-skiplist\" class=\"headerlink\" title=\"跳表 skiplist\"></a>跳表 skiplist</h3><p>跳表的本质是一个多层链表，它能快速地查询、插入、删除【时间复杂度均为 O(logn)】，所以它的查询速度媲美平衡二叉树，而且它的数据结构比平衡二叉树简单，结构示意图如下:</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1650878212810-ddb1db61-8c5d-47c8-ac3a-e30457666c03.png#clientId=uea216351-f775-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u739a6637&margin=%5Bobject%20Object%5D&name=image.png&originHeight=336&originWidth=631&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=149505&status=done&style=none&taskId=u61305bee-da14-4bcd-8e91-277a09a8e21&title=\" alt=\"image.png\"><br>特点：</p>\n<ul>\n<li>跳表的最底层拥有所有的元素</li>\n<li>跳表每一层都是一个链表，除了最底层是原始链表，层次逐渐往上可分别划分为一级索引层、二级索引层…</li>\n<li>跳表插入元素时，会先随机生成出一个“层次数字”，然后元素会插入到这个层次的所有底层，直到原始链表层</li>\n<li>如果一个元素存在与某个索引层，那么这个元素也会存在于低于它的所有索引下层，如元素在第 99 索引层，那么由上到下从 99 索引层直到原始链表层都会存在该元素</li>\n<li>空间换时间，跳表查找变快了，但是要存储许多索引层，故空间开销变大了</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 产生节点的高度。使用抛硬币\n *\n * @return\n *&#x2F;\nprivate int getRandomLevel() &#123;\n  &#x2F;&#x2F; 可知，元素的插入层次i从1开始自增，随机到哪一层的概率就像抛硬币一样，都是50%，故i越往后，其概率越小(每次都*0.5)\n  &#x2F;&#x2F; 第一层概率：0.5，第二层0.5*0.5&#x3D;0.25，...\n  int lev &#x3D; 1;\n  while (random.nextInt() % 2 &#x3D;&#x3D; 0) &#123;\n    lev++;\n  &#125;\n  &#x2F;&#x2F; MAX_LEVEL为跳表的最大层级\n  return lev &gt; MAX_LEVEL ? MAX_LEVEL : lev;\n&#125;</code></pre>\n\n<ul>\n<li>插入节点</li>\n<li>插入的时间复杂度为 O(logn)，每次插入都会先查找到要插入的位置（查找的时间复杂度就已经是【O(logn)】了，找到后直接插入【O(1)】，所以总的为【O(logn)】），删除也是同理为 O(logn)</li>\n<li>每个节点的插入层次是通过 getRandomLevel()随机出来的，插入层次互不影响<br>以下模拟节点插入：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1650878213036-208043fc-90e4-4488-9f5a-f34c509d4da0.png#clientId=uea216351-f775-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud81fee3f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=844&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=303815&status=done&style=none&taskId=ufcbbd68e-b657-41d6-8b58-9f316527db1&title=\" alt=\"image.png\"></p>\n<ul>\n<li>查找</li>\n</ul>\n<p>查找节点时，从高索引层往低索引层查找：<br>一开始元素在高层从链表由前往后查找，直到要查找的目标元素在该层的某两个相邻元素之间，就会往下跳到下层的同一个位置，继续从同一位置向链表尾方向遍历查询-&gt;重复上面的过程，直到查找到目标元素<br>查找时每一层都跳过部分元素，进而加快了查找效率，以下模拟节点查找：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1650878212874-468dd1ea-91cb-4de3-ad77-c50e53f6b687.png#clientId=uea216351-f775-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc4457562&margin=%5Bobject%20Object%5D&name=image.png&originHeight=222&originWidth=704&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=90372&status=done&style=none&taskId=uc93f278f-d867-40f2-ba7b-1a90e738d29&title=\" alt=\"image.png\"></p>\n<h2 id=\"跳表简单实现\"><a href=\"#跳表简单实现\" class=\"headerlink\" title=\"跳表简单实现\"></a>跳表简单实现</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.Random;\n\npublic class SkipList &#123;\n    private static final int MAX_LEVEL &#x3D; 16;\n    private int levelCount &#x3D; 1;\n    private Node head &#x3D; new Node();\n    private Random random &#x3D; new Random();\n\n    public Node find(int value)&#123;\n        Node p &#x3D; head;\n        for(int i &#x3D; levelCount - 1; i &gt;&#x3D; 0; i--)&#123;\n            &#x2F;&#x2F;如果在这一个level上存在下一个数据节点且下一个数据节点的值小于value，p往后挪一个\n            &#x2F;&#x2F;直到这一个level走完或者值在区间内，切换下一个层级\n            while(p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value)&#123;\n                p &#x3D; p.forwards[i];\n            &#125;\n        &#125;\n        &#x2F;&#x2F;到最下层依照上面的索引找到的位置往后找一位即可判断\n        if(p.forwards[0] !&#x3D; null &amp;&amp; p.forwards[0].data &#x3D;&#x3D; value) return p.forwards[0];\n        return null;\n    &#125;\n\n    public void insert(int value)&#123;\n        Node p &#x3D; head;\n        int level &#x3D; randomLevel();\n        Node node &#x3D; new Node();\n        node.data &#x3D; value;\n        node.maxLevel &#x3D; level;\n        &#x2F;&#x2F;记录要更新的node\n        Node update[] &#x3D; new Node[level];\n        &#x2F;&#x2F;插入一个新的node，主要目标更新保存的forwards\n        for(int i &#x3D; level; i &gt;&#x3D; 0; i--)&#123;\n            &#x2F;&#x2F;在计算得到的level中依次找适合的位置\n            while(p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value)&#123;\n                p &#x3D; p.forwards[i];\n            &#125;\n            update[i] &#x3D; p;\n        &#125;\n        &#x2F;&#x2F;更新指向\n        for(int i &#x3D; 0; i &lt; level; i++)&#123;\n            node.forwards[i] &#x3D; update[i].forwards[i];\n            update[i].forwards[i] &#x3D; node;\n        &#125;\n        if(levelCount &lt; level) levelCount &#x3D; level;\n    &#125;\n\n    public void delete(int value)&#123;\n        Node[] deleteNode &#x3D; new Node[MAX_LEVEL];\n        Node p &#x3D; head;\n        for(int i &#x3D; levelCount - 1; i &gt;&#x3D;0; i--)&#123;\n            &#x2F;&#x2F;确定每个层级中要删除的value对应的node\n            while(p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value)&#123;\n                p &#x3D; p.forwards[i];\n            &#125;\n            &#x2F;&#x2F;当前level中要删除的p，更新到node数组中\n            deleteNode[i] &#x3D; p;\n        &#125;\n        &#x2F;&#x2F;从底层扫，每层删除\n        if(p.forwards[0] !&#x3D; null &amp;&amp; p.forwards[0].data &#x3D;&#x3D; value)&#123;\n            &#x2F;&#x2F;根据上面deleteNode[]中保存的要删除的node，更新前后的指向\n            for(int i &#x3D; levelCount - 1; i &gt;&#x3D; 0; i--)&#123;\n                if(deleteNode[i] !&#x3D; null &amp;&amp; deleteNode[i].forwards[i].data &#x3D;&#x3D; value)&#123;\n                    deleteNode[i].forwards[i] &#x3D; deleteNode[i].forwards[i].forwards[i];\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    public void printAll()&#123;\n        Node p &#x3D; head;\n        while(p.forwards[0] !&#x3D; null)&#123;\n            System.out.print(p.forwards[0] + &quot; &quot;);\n            p &#x3D; p.forwards[0];\n        &#125;\n        System.out.println();\n    &#125;\n\n    private int randomLevel() &#123;\n        int level &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; MAX_LEVEL; i++)&#123;\n            if(random.nextInt()%2 &#x3D;&#x3D; 1)&#123;\n                level++;\n            &#125;\n        &#125;\n        return level;\n    &#125;\n\n    class Node&#123;\n        private int data;\n        &#x2F;&#x2F;核心在这个forwards数组，他存放了各个level索引的下一个数据节点\n        private Node[] forwards &#x3D; new Node[MAX_LEVEL];\n        private int maxLevel;\n\n        public String toString()&#123;\n            StringBuilder sb &#x3D; new StringBuilder();\n            sb.append(&quot;&#123;data: &quot;);\n            sb.append(data);\n            sb.append(&quot;; level: &quot;);\n            sb.append(maxLevel);\n            sb.append(&quot; &#125;&quot;);\n            return sb.toString();\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n","categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]}