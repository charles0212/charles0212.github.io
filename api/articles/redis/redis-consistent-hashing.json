{"title":"Redis（二）ShardedJedis一致性哈希","slug":"yuque/Redis（二）ShardedJedis一致性哈希","date":"2020-06-23T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/redis/redis-consistent-hashing.json","excerpt":"本文主要介绍一致性哈希的概念，以及在Redis 中的ShardedJedis一致性哈希实现原理1、非一致性哈希在讨论一致性哈希之前，先认识下”非一致性哈希”，例如HashMap。当使用 HashMap 时，key被均匀地映射到数组之上，映射方法就是利用key 的 hash与数组长度取模(通过&运算)。当 put 的数据超过负载因子loadFactor×2Len时，HashMap 会按照 2被的容量扩容。新 put进来的数据会通过与新数组的长度取模的方式进行映射。那之前已经映射的数据该怎么办？通过查看 HashMap 代码的resize方法会发现，每次","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648982930385-16ad72be-62d7-4f89-a727-d5e14dfb9ca2.png#clientId=u019c0c6b-a681-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub18ca8ff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=410&originWidth=688&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=38474&status=done&style=none&taskId=u747618ef-6aa3-4345-b95e-8c3dcb18635&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648982930200-543d6cdd-b007-4653-afdc-3de50a477aae.png#clientId=u019c0c6b-a681-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud990d154&margin=%5Bobject%20Object%5D&name=image.png&originHeight=371&originWidth=569&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=19894&status=done&style=none&taskId=ue4304c8e-087b-48f0-95eb-2c81cb47c88&title="],"content":"<p>本文主要介绍一致性哈希的概念，以及在 Redis 中的 ShardedJedis 一致性哈希实现原理</p>\n<h2 id=\"1、非一致性哈希\"><a href=\"#1、非一致性哈希\" class=\"headerlink\" title=\"1、非一致性哈希\"></a>1、非一致性哈希</h2><p>在讨论一致性哈希之前，先认识下”非一致性哈希”，例如 HashMap。<br>当使用 HashMap 时，key 被均匀地映射到数组之上，映射方法就是利用 key 的 hash 与数组长度取模(通过&amp;运算)。<br>当 put 的数据超过负载因子 loadFactor×2Len 时，HashMap 会按照 2 被的容量扩容。<br>新 put 进来的数据会通过与新数组的长度取模的方式进行映射。那之前已经映射的数据该怎么办？<br>通过查看 HashMap 代码的 resize 方法会发现，每次扩容都会把之前的 key 重新映射。<br>所以对 HashMap 而言要想获得较好的性能必须要提前估计所放数据集合的大小，以设计合适的初始化容量和负载因子。</p>\n<h2 id=\"2、一致性哈希\"><a href=\"#2、一致性哈希\" class=\"headerlink\" title=\"2、一致性哈希\"></a>2、一致性哈希</h2><p>不是每个场景都像 HashMap 这么简单，比如在大型的 P2P 网络中存在上百万台 Server，资源与 Server 的关系是以 Key 的形式映射而成，也就是说是一个大的 HashMap，维护着每个 Key 在哪个 Server 之上，如果有新的节点加入或退出 P2P 网络，跟 HashMap 一样，也会导致映射关系的变化，显然不可能把所有的 Key 与 Server 的映射关系都调整一遍。这就需要一种方法，在哈希项发生变化是，不需要调整所有的节点，而达到继续维护哈希映射的关系。下面来看下<a href=\"%5Bhttp://en.wikipedia.org/wiki/Consistent_hashing\">一致性</a>的定义。](<a href=\"http://en.wikipedia.org/wiki/Consistent_hashing)%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%82\">http://en.wikipedia.org/wiki/Consistent_hashing)%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%82</a>)</p>\n<blockquote>\n<p>Consistent hashing is a special kind of hashing such that when a hash table is resized, only K&#x2F;n keys need to be remapped on average, where K is the number of keys, and n is the number of slots. In contrast, in most traditional hash tables, a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and the slots is defined by a modular operation.</p>\n</blockquote>\n<p>一致性哈希是一种特殊类型的的哈希，当哈希表改变大小的时候，平均只有 K&#x2F;n 的 keys 需要被重新映射，其中 k 为 keys 的数量，n 为槽 slots 的数量。相比之下，在传统的哈希表中，因为 key 和 slot 的映射是通过取模操作定义的，槽 slot 的数量改变会引起几乎所有的 key 都被重新映射。一致性哈希当节点加入、退出时，只影响加入退出的节点和其邻居节点或者其他节点只有少量的 Key 受影响，需要满足下面几个条件：</p>\n<ul>\n<li>平衡性(Balance)：就是指哈希算法要均匀分布，不能有明显的映射规律，这对一般的哈希实现也是必须的；</li>\n<li>单调性(Monotonicity)：就是指有新节点加入时，已经存在的映射关系不能发生变化；</li>\n<li>分散性(Spread)：就是避免不同的内容映射到相同的位置和相同的内容映射到不同的位置。</li>\n</ul>\n<p>其实一致性哈希（哈希）有个明显的优点就是负载均衡，只要哈希函数设计得当，每个点就是对等的可以均匀地分布系统负载。</p>\n<h2 id=\"3、ShardedJedis-一致性哈希\"><a href=\"#3、ShardedJedis-一致性哈希\" class=\"headerlink\" title=\"3、ShardedJedis 一致性哈希\"></a>3、ShardedJedis 一致性哈希</h2><p>Shared 一致性哈希采用以下方案：</p>\n<ol>\n<li>Redis 服务器节点划分：将每台服务器节点采用 hash 算法划分为 160 个虚拟节点(可以配置划分权重)</li>\n<li>将划分虚拟节点采用 TreeMap 存储</li>\n<li>对每个 Redis 服务器的物理连接采用 LinkedHashMap 存储</li>\n<li>对 Key or KeyTag 采用同样的 hash 算法，然后从 TreeMap 获取大于等于键 hash 值得节点，取最邻近节点存储；</li>\n</ol>\n<p>当 key 的 hash 值大于虚拟节点 hash 值得最大值时，存入第一个虚拟节点。<br>Sharded 采用的 hash 算法：MD5 和 MurmurHash 两种；默认采用 64 位的 MurmurHash 算法，<br>Sharded 类维护了一致性哈希后的物理机器和虚拟节点的映射关系。<img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648982930385-16ad72be-62d7-4f89-a727-d5e14dfb9ca2.png#clientId=u019c0c6b-a681-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub18ca8ff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=410&originWidth=688&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=38474&status=done&style=none&taskId=u747618ef-6aa3-4345-b95e-8c3dcb18635&title=\" alt=\"image.png\"></p>\n<h3 id=\"3-1-Sharded-的实现定义\"><a href=\"#3-1-Sharded-的实现定义\" class=\"headerlink\" title=\"3.1 Sharded 的实现定义\"></a>3.1 Sharded 的实现定义</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public class Sharded&lt;R, S extends ShardInfo&lt;R&gt;&gt; &#123;\n\n    public static final int DEFAULT_WEIGHT &#x3D; 1;\n    private TreeMap&lt;Long, S&gt; nodes;\n    private final Hashing algo;\n    private final Map&lt;ShardInfo&lt;R&gt;, R&gt; resources &#x3D; new LinkedHashMap&lt;ShardInfo&lt;R&gt;, R&gt;();\n\n    &#x2F;**\n     * The default pattern used for extracting a key tag. The pattern must have a group (between\n     * parenthesis), which delimits the tag to be hashed. A null pattern avoids applying the regular\n     * expression for each lookup, improving performance a little bit is key tags aren&#39;t being used.\n     *&#x2F;\n    private Pattern tagPattern &#x3D; null;\n    &#x2F;&#x2F; the tag is anything between &#123;&#125;\n    public static final Pattern DEFAULT_KEY_TAG_PATTERN &#x3D; Pattern.compile(&quot;\\\\&#123;(.+?)\\\\&#125;&quot;);\n    ......\n\n&#125;</code></pre>\n\n<p>其中 TreeMap&lt;Long, S&gt; nodes，存储的是虚拟节点和 key 的映射关系。有了虚拟节点，还要找到真正的存储位置。<br>Map&lt;ShardInfo<R>, R&gt; resources 维护了虚拟节点和真正的存储位置的映射关系。<br>也是说，hash(key) → virtual node → real node;<br>jedis 划分虚拟节点的逻辑代码，在 Sharded 类中，方法是 initialize。这是在实例化对象池 ShardedJedisPool 过程中执行的划分虚拟节点。<br>其中 ShardedJedis、BinaryShardedJedis 和 Sharded 的关系如下图所示。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648982930200-543d6cdd-b007-4653-afdc-3de50a477aae.png#clientId=u019c0c6b-a681-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud990d154&margin=%5Bobject%20Object%5D&name=image.png&originHeight=371&originWidth=569&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=19894&status=done&style=none&taskId=ue4304c8e-087b-48f0-95eb-2c81cb47c88&title=\" alt=\"image.png\"></div></p>\n<h3 id=\"3-2-ShardedJedis-初始化\"><a href=\"#3-2-ShardedJedis-初始化\" class=\"headerlink\" title=\"3.2 ShardedJedis 初始化\"></a>3.2 ShardedJedis 初始化</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public ShardedJedis(List&lt;JedisShardInfo&gt; shards) &#123;\n    super(shards);\n&#125;\n\npublic BinaryShardedJedis(List&lt;JedisShardInfo&gt; shards, Hashing algo) &#123;\n    super(shards, algo);\n&#125;\n\npublic Sharded(List&lt;S&gt; shards) &#123;\n    this(shards, Hashing.MURMUR_HASH); &#x2F;&#x2F; MD5 is really not good as we works\n    &#x2F;&#x2F; with 64-bits not 128\n&#125;\n\npublic Sharded(List&lt;S&gt; shards, Hashing algo) &#123;\n    this.algo &#x3D; algo;\n    initialize(shards);\n&#125;</code></pre>\n\n<p>通过 initialize 来看，节点的划分和初始化</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">private void initialize(List&lt;S&gt; shards) &#123;\n    nodes &#x3D; new TreeMap&lt;Long, S&gt;();\n\n    for (int i &#x3D; 0; i !&#x3D; shards.size(); ++i) &#123;\n        final S shardInfo &#x3D; shards.get(i);\n        if (shardInfo.getName() &#x3D;&#x3D; null) for (int n &#x3D; 0; n &lt;160 * shardInfo.getWeight(); n++) &#123;\n            nodes.put(this.algo.hash(&quot;SHARD-&quot; + i + &quot;-NODE-&quot; + n), shardInfo);\n        &#125;\n        else for (int n &#x3D; 0; n &lt;160 * shardInfo.getWeight(); n++) &#123;\n            nodes.put(this.algo.hash(shardInfo.getName() + &quot;*&quot; + shardInfo.getWeight() + n), shardInfo);\n        &#125;\n        resources.put(shardInfo, shardInfo.createResource());\n    &#125;\n&#125;</code></pre>\n\n<p>以上代码就是 Sharded 划分虚拟节点的逻辑，初始化 TreeMap&lt;Long, S&gt; nodes 虚拟节点和 key 的映射关系，以及 Map&lt;ShardInfo<R>, R&gt; resources 虚拟节点和真正的存储位置的映射关系。</p>\n<h3 id=\"3-3-ShardedJedis-中的-set-和-get-操作\"><a href=\"#3-3-ShardedJedis-中的-set-和-get-操作\" class=\"headerlink\" title=\"3.3 ShardedJedis 中的 set 和 get 操作\"></a>3.3 ShardedJedis 中的 set 和 get 操作</h3><p>先看 ShardedJedis 的 set 操作（get 操作类似）</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public String set(String key, String value) &#123;\n    &#x2F;&#x2F; 1、获取ShardedJedis的实例\n    Jedis j &#x3D; getShard(key);\n    return j.set(key, value);\n&#125;\n\npublic R getShard(String key) &#123;\n    &#x2F;&#x2F; 2、首先需要通过getShardInfo(key)的获取到JedisShardInfo信息，通过resources.get获取到ShardedJedis实例\n    return resources.get(getShardInfo(key));\n&#125;\n\npublic S getShardInfo(String key) &#123;\n    &#x2F;&#x2F; 3、SafeEncoder.encode(getKeyTag(key))获取hash后的byte[]\n    &#x2F;&#x2F; 4、通过getShardInfo(byte[] key)获取到JedisShardInfo信息\n    return getShardInfo(SafeEncoder.encode(getKeyTag(key)));\n&#125;\n\npublic S getShardInfo(byte[] key) &#123;\n    &#x2F;&#x2F; 5、获取大于等于当前algo.hash(key)的升序SortedMap\n    SortedMap&lt;Long, S&gt; tail &#x3D; nodes.tailMap(algo.hash(key));\n    if (tail.isEmpty()) &#123;\n        &#x2F;&#x2F; 6、为空，说明当前的hash值比所有的都大，返回nodes的第一个ShardInfo\n        return nodes.get(nodes.firstKey());\n    &#125;\n    &#x2F;&#x2F; 7、否则返回大于等于当前hash值的第一个ShardInfo\n    return tail.get(tail.firstKey());\n&#125;</code></pre>\n\n<p>上面的代码中大体的逻辑，首先通过 key 得到 ShardInfo，然后通过 ShardInfo 得到泛型 Jedis 客户端实例，进行 set 和 get 操作。通过上面的代码保证了 redis 的哈希一致性。</p>\n","more":"<p>本文主要介绍一致性哈希的概念，以及在 Redis 中的 ShardedJedis 一致性哈希实现原理</p>\n<h2 id=\"1、非一致性哈希\"><a href=\"#1、非一致性哈希\" class=\"headerlink\" title=\"1、非一致性哈希\"></a>1、非一致性哈希</h2><p>在讨论一致性哈希之前，先认识下”非一致性哈希”，例如 HashMap。<br>当使用 HashMap 时，key 被均匀地映射到数组之上，映射方法就是利用 key 的 hash 与数组长度取模(通过&amp;运算)。<br>当 put 的数据超过负载因子 loadFactor×2Len 时，HashMap 会按照 2 被的容量扩容。<br>新 put 进来的数据会通过与新数组的长度取模的方式进行映射。那之前已经映射的数据该怎么办？<br>通过查看 HashMap 代码的 resize 方法会发现，每次扩容都会把之前的 key 重新映射。<br>所以对 HashMap 而言要想获得较好的性能必须要提前估计所放数据集合的大小，以设计合适的初始化容量和负载因子。</p>\n<h2 id=\"2、一致性哈希\"><a href=\"#2、一致性哈希\" class=\"headerlink\" title=\"2、一致性哈希\"></a>2、一致性哈希</h2><p>不是每个场景都像 HashMap 这么简单，比如在大型的 P2P 网络中存在上百万台 Server，资源与 Server 的关系是以 Key 的形式映射而成，也就是说是一个大的 HashMap，维护着每个 Key 在哪个 Server 之上，如果有新的节点加入或退出 P2P 网络，跟 HashMap 一样，也会导致映射关系的变化，显然不可能把所有的 Key 与 Server 的映射关系都调整一遍。这就需要一种方法，在哈希项发生变化是，不需要调整所有的节点，而达到继续维护哈希映射的关系。下面来看下<a href=\"%5Bhttp://en.wikipedia.org/wiki/Consistent_hashing\">一致性</a>的定义。](<a href=\"http://en.wikipedia.org/wiki/Consistent_hashing)%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%82\">http://en.wikipedia.org/wiki/Consistent_hashing)%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%82</a>)</p>\n<blockquote>\n<p>Consistent hashing is a special kind of hashing such that when a hash table is resized, only K&#x2F;n keys need to be remapped on average, where K is the number of keys, and n is the number of slots. In contrast, in most traditional hash tables, a change in the number of array slots causes nearly all keys to be remapped because the mapping between the keys and the slots is defined by a modular operation.</p>\n</blockquote>\n<p>一致性哈希是一种特殊类型的的哈希，当哈希表改变大小的时候，平均只有 K&#x2F;n 的 keys 需要被重新映射，其中 k 为 keys 的数量，n 为槽 slots 的数量。相比之下，在传统的哈希表中，因为 key 和 slot 的映射是通过取模操作定义的，槽 slot 的数量改变会引起几乎所有的 key 都被重新映射。一致性哈希当节点加入、退出时，只影响加入退出的节点和其邻居节点或者其他节点只有少量的 Key 受影响，需要满足下面几个条件：</p>\n<ul>\n<li>平衡性(Balance)：就是指哈希算法要均匀分布，不能有明显的映射规律，这对一般的哈希实现也是必须的；</li>\n<li>单调性(Monotonicity)：就是指有新节点加入时，已经存在的映射关系不能发生变化；</li>\n<li>分散性(Spread)：就是避免不同的内容映射到相同的位置和相同的内容映射到不同的位置。</li>\n</ul>\n<p>其实一致性哈希（哈希）有个明显的优点就是负载均衡，只要哈希函数设计得当，每个点就是对等的可以均匀地分布系统负载。</p>\n<h2 id=\"3、ShardedJedis-一致性哈希\"><a href=\"#3、ShardedJedis-一致性哈希\" class=\"headerlink\" title=\"3、ShardedJedis 一致性哈希\"></a>3、ShardedJedis 一致性哈希</h2><p>Shared 一致性哈希采用以下方案：</p>\n<ol>\n<li>Redis 服务器节点划分：将每台服务器节点采用 hash 算法划分为 160 个虚拟节点(可以配置划分权重)</li>\n<li>将划分虚拟节点采用 TreeMap 存储</li>\n<li>对每个 Redis 服务器的物理连接采用 LinkedHashMap 存储</li>\n<li>对 Key or KeyTag 采用同样的 hash 算法，然后从 TreeMap 获取大于等于键 hash 值得节点，取最邻近节点存储；</li>\n</ol>\n<p>当 key 的 hash 值大于虚拟节点 hash 值得最大值时，存入第一个虚拟节点。<br>Sharded 采用的 hash 算法：MD5 和 MurmurHash 两种；默认采用 64 位的 MurmurHash 算法，<br>Sharded 类维护了一致性哈希后的物理机器和虚拟节点的映射关系。<img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648982930385-16ad72be-62d7-4f89-a727-d5e14dfb9ca2.png#clientId=u019c0c6b-a681-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub18ca8ff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=410&originWidth=688&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=38474&status=done&style=none&taskId=u747618ef-6aa3-4345-b95e-8c3dcb18635&title=\" alt=\"image.png\"></p>\n<h3 id=\"3-1-Sharded-的实现定义\"><a href=\"#3-1-Sharded-的实现定义\" class=\"headerlink\" title=\"3.1 Sharded 的实现定义\"></a>3.1 Sharded 的实现定义</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public class Sharded&lt;R, S extends ShardInfo&lt;R&gt;&gt; &#123;\n\n    public static final int DEFAULT_WEIGHT &#x3D; 1;\n    private TreeMap&lt;Long, S&gt; nodes;\n    private final Hashing algo;\n    private final Map&lt;ShardInfo&lt;R&gt;, R&gt; resources &#x3D; new LinkedHashMap&lt;ShardInfo&lt;R&gt;, R&gt;();\n\n    &#x2F;**\n     * The default pattern used for extracting a key tag. The pattern must have a group (between\n     * parenthesis), which delimits the tag to be hashed. A null pattern avoids applying the regular\n     * expression for each lookup, improving performance a little bit is key tags aren&#39;t being used.\n     *&#x2F;\n    private Pattern tagPattern &#x3D; null;\n    &#x2F;&#x2F; the tag is anything between &#123;&#125;\n    public static final Pattern DEFAULT_KEY_TAG_PATTERN &#x3D; Pattern.compile(&quot;\\\\&#123;(.+?)\\\\&#125;&quot;);\n    ......\n\n&#125;</code></pre>\n\n<p>其中 TreeMap&lt;Long, S&gt; nodes，存储的是虚拟节点和 key 的映射关系。有了虚拟节点，还要找到真正的存储位置。<br>Map&lt;ShardInfo<R>, R&gt; resources 维护了虚拟节点和真正的存储位置的映射关系。<br>也是说，hash(key) → virtual node → real node;<br>jedis 划分虚拟节点的逻辑代码，在 Sharded 类中，方法是 initialize。这是在实例化对象池 ShardedJedisPool 过程中执行的划分虚拟节点。<br>其中 ShardedJedis、BinaryShardedJedis 和 Sharded 的关系如下图所示。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648982930200-543d6cdd-b007-4653-afdc-3de50a477aae.png#clientId=u019c0c6b-a681-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud990d154&margin=%5Bobject%20Object%5D&name=image.png&originHeight=371&originWidth=569&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=19894&status=done&style=none&taskId=ue4304c8e-087b-48f0-95eb-2c81cb47c88&title=\" alt=\"image.png\"></div></p>\n<h3 id=\"3-2-ShardedJedis-初始化\"><a href=\"#3-2-ShardedJedis-初始化\" class=\"headerlink\" title=\"3.2 ShardedJedis 初始化\"></a>3.2 ShardedJedis 初始化</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public ShardedJedis(List&lt;JedisShardInfo&gt; shards) &#123;\n    super(shards);\n&#125;\n\npublic BinaryShardedJedis(List&lt;JedisShardInfo&gt; shards, Hashing algo) &#123;\n    super(shards, algo);\n&#125;\n\npublic Sharded(List&lt;S&gt; shards) &#123;\n    this(shards, Hashing.MURMUR_HASH); &#x2F;&#x2F; MD5 is really not good as we works\n    &#x2F;&#x2F; with 64-bits not 128\n&#125;\n\npublic Sharded(List&lt;S&gt; shards, Hashing algo) &#123;\n    this.algo &#x3D; algo;\n    initialize(shards);\n&#125;</code></pre>\n\n<p>通过 initialize 来看，节点的划分和初始化</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">private void initialize(List&lt;S&gt; shards) &#123;\n    nodes &#x3D; new TreeMap&lt;Long, S&gt;();\n\n    for (int i &#x3D; 0; i !&#x3D; shards.size(); ++i) &#123;\n        final S shardInfo &#x3D; shards.get(i);\n        if (shardInfo.getName() &#x3D;&#x3D; null) for (int n &#x3D; 0; n &lt;160 * shardInfo.getWeight(); n++) &#123;\n            nodes.put(this.algo.hash(&quot;SHARD-&quot; + i + &quot;-NODE-&quot; + n), shardInfo);\n        &#125;\n        else for (int n &#x3D; 0; n &lt;160 * shardInfo.getWeight(); n++) &#123;\n            nodes.put(this.algo.hash(shardInfo.getName() + &quot;*&quot; + shardInfo.getWeight() + n), shardInfo);\n        &#125;\n        resources.put(shardInfo, shardInfo.createResource());\n    &#125;\n&#125;</code></pre>\n\n<p>以上代码就是 Sharded 划分虚拟节点的逻辑，初始化 TreeMap&lt;Long, S&gt; nodes 虚拟节点和 key 的映射关系，以及 Map&lt;ShardInfo<R>, R&gt; resources 虚拟节点和真正的存储位置的映射关系。</p>\n<h3 id=\"3-3-ShardedJedis-中的-set-和-get-操作\"><a href=\"#3-3-ShardedJedis-中的-set-和-get-操作\" class=\"headerlink\" title=\"3.3 ShardedJedis 中的 set 和 get 操作\"></a>3.3 ShardedJedis 中的 set 和 get 操作</h3><p>先看 ShardedJedis 的 set 操作（get 操作类似）</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public String set(String key, String value) &#123;\n    &#x2F;&#x2F; 1、获取ShardedJedis的实例\n    Jedis j &#x3D; getShard(key);\n    return j.set(key, value);\n&#125;\n\npublic R getShard(String key) &#123;\n    &#x2F;&#x2F; 2、首先需要通过getShardInfo(key)的获取到JedisShardInfo信息，通过resources.get获取到ShardedJedis实例\n    return resources.get(getShardInfo(key));\n&#125;\n\npublic S getShardInfo(String key) &#123;\n    &#x2F;&#x2F; 3、SafeEncoder.encode(getKeyTag(key))获取hash后的byte[]\n    &#x2F;&#x2F; 4、通过getShardInfo(byte[] key)获取到JedisShardInfo信息\n    return getShardInfo(SafeEncoder.encode(getKeyTag(key)));\n&#125;\n\npublic S getShardInfo(byte[] key) &#123;\n    &#x2F;&#x2F; 5、获取大于等于当前algo.hash(key)的升序SortedMap\n    SortedMap&lt;Long, S&gt; tail &#x3D; nodes.tailMap(algo.hash(key));\n    if (tail.isEmpty()) &#123;\n        &#x2F;&#x2F; 6、为空，说明当前的hash值比所有的都大，返回nodes的第一个ShardInfo\n        return nodes.get(nodes.firstKey());\n    &#125;\n    &#x2F;&#x2F; 7、否则返回大于等于当前hash值的第一个ShardInfo\n    return tail.get(tail.firstKey());\n&#125;</code></pre>\n\n<p>上面的代码中大体的逻辑，首先通过 key 得到 ShardInfo，然后通过 ShardInfo 得到泛型 Jedis 客户端实例，进行 set 和 get 操作。通过上面的代码保证了 redis 的哈希一致性。</p>\n","categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]}