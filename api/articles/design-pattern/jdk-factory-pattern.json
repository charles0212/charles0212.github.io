{"title":"JDK设计模式（二）工厂模式","slug":"yuque/JDK设计模式（二）工厂模式","date":"2015-01-18T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-factory-pattern.json","excerpt":"工厂模式是我们最常用的实例化对象模式，使用工厂方法代替new操作的一种模式，使用工厂模式，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。1、简单工厂模式简单工厂模式是属于创建型模式，又叫做静态工厂方法（StaticFactoryMethod）模式，但不属于 23 种GOF 设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。使","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731635-85e6872e-a94b-4693-830f-b39271c2bc1f.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf16bdcdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=483&originWidth=1233&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=117127&status=done&style=none&taskId=u92c2d22b-1a22-4b5d-b1c7-49c1d7f8ce9&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731140-a0aafa90-5a80-4dad-83e7-8265c691ab22.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9d6bd374&margin=%5Bobject%20Object%5D&name=image.png&originHeight=518&originWidth=1295&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=110790&status=done&style=none&taskId=u60536269-8e5a-478a-b7d3-8a2a9efe199&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731595-301d90a5-6b5f-4da8-8e32-96d19bfb3c30.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub322c434&margin=%5Bobject%20Object%5D&name=image.png&originHeight=625&originWidth=1320&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=125791&status=done&style=none&taskId=ued59f856-7188-425b-87c9-9141719760d&title="],"content":"<p>工厂模式是我们最常用的实例化对象模式，使用工厂方法代替 new 操作的一种模式，使用工厂模式，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。</p>\n<h2 id=\"1、简单工厂模式\"><a href=\"#1、简单工厂模式\" class=\"headerlink\" title=\"1、简单工厂模式\"></a>1、简单工厂模式</h2><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于 23 种 GOF 设计模式之一。<br>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731635-85e6872e-a94b-4693-830f-b39271c2bc1f.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf16bdcdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=483&originWidth=1233&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=117127&status=done&style=none&taskId=u92c2d22b-1a22-4b5d-b1c7-49c1d7f8ce9&title=\" alt=\"image.png\"><br>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。<br><strong>使用场景</strong><br>1、工厂类负责创建的对象比较少；<br>2、客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；<br>3、由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。<br><strong>JDK 中使用的简单工厂</strong><br>代替构造函数创建对象，方法名比构造函数清晰<br>如 Integer.valueOf，Class.forName 等方法</p>\n<h2 id=\"2、工厂方法模式\"><a href=\"#2、工厂方法模式\" class=\"headerlink\" title=\"2、工厂方法模式\"></a>2、工厂方法模式</h2><p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法把类的实例化推迟到子类。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731140-a0aafa90-5a80-4dad-83e7-8265c691ab22.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9d6bd374&margin=%5Bobject%20Object%5D&name=image.png&originHeight=518&originWidth=1295&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=110790&status=done&style=none&taskId=u60536269-8e5a-478a-b7d3-8a2a9efe199&title=\" alt=\"image.png\"><br>JDK 中使用的工厂方法<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312730182-cf689595-714c-4d36-8359-78781ffe975a.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud9b44865&margin=%5Bobject%20Object%5D&name=image.png&originHeight=607&originWidth=958&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=83226&status=done&style=none&taskId=u664da234-c8ab-48e4-a706-67dc9fdb7a3&title=\" alt=\"image.png\"><br>如上图所示，ArrayList 和 LinkedList 使用具体的工厂类的 iterator 方法，分别创建实现 Iterator 接口类的 ArrayList$Itr和ArrayList$ListItr,以及 LinkedList$ListItr 的具体产品类。</p>\n<h2 id=\"3、抽象工厂模式\"><a href=\"#3、抽象工厂模式\" class=\"headerlink\" title=\"3、抽象工厂模式\"></a>3、抽象工厂模式</h2><p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。<br>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。<br>抽象工厂的方法经常以工厂方法的方式实现，抽象工厂的任务是定义一个负责创建一组产品的接口。这个接口内的每个方法都负责创建一个具体产品，<br>同时利用实现抽象工厂的子类来提供这些具体的做法，所以在抽象工厂中利用工厂实现生产方法是相当自然在做法。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731595-301d90a5-6b5f-4da8-8e32-96d19bfb3c30.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub322c434&margin=%5Bobject%20Object%5D&name=image.png&originHeight=625&originWidth=1320&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=125791&status=done&style=none&taskId=ued59f856-7188-425b-87c9-9141719760d&title=\" alt=\"image.png\"><br>JDK 中使用的抽象工厂<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731132-e60e3a16-5f75-49b0-b0d8-cd2a4ed4c76e.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u846d3d23&margin=%5Bobject%20Object%5D&name=image.png&originHeight=595&originWidth=986&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=61956&status=done&style=none&taskId=ue613c9e6-bb5a-47d7-b26c-15db9431332&title=\" alt=\"image.png\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1、 所有的工厂都是用来封装对象的创建。<br>2、 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦。<br>3、 工厂方法，使用继承，把对象的创建委托给子类，由子类来实现工厂方法来创建对象。<br>4、 抽象工厂，使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。</p>\n","more":"<p>工厂模式是我们最常用的实例化对象模式，使用工厂方法代替 new 操作的一种模式，使用工厂模式，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。</p>\n<h2 id=\"1、简单工厂模式\"><a href=\"#1、简单工厂模式\" class=\"headerlink\" title=\"1、简单工厂模式\"></a>1、简单工厂模式</h2><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，但不属于 23 种 GOF 设计模式之一。<br>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731635-85e6872e-a94b-4693-830f-b39271c2bc1f.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf16bdcdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=483&originWidth=1233&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=117127&status=done&style=none&taskId=u92c2d22b-1a22-4b5d-b1c7-49c1d7f8ce9&title=\" alt=\"image.png\"><br>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。<br><strong>使用场景</strong><br>1、工厂类负责创建的对象比较少；<br>2、客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；<br>3、由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。<br><strong>JDK 中使用的简单工厂</strong><br>代替构造函数创建对象，方法名比构造函数清晰<br>如 Integer.valueOf，Class.forName 等方法</p>\n<h2 id=\"2、工厂方法模式\"><a href=\"#2、工厂方法模式\" class=\"headerlink\" title=\"2、工厂方法模式\"></a>2、工厂方法模式</h2><p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法把类的实例化推迟到子类。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731140-a0aafa90-5a80-4dad-83e7-8265c691ab22.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9d6bd374&margin=%5Bobject%20Object%5D&name=image.png&originHeight=518&originWidth=1295&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=110790&status=done&style=none&taskId=u60536269-8e5a-478a-b7d3-8a2a9efe199&title=\" alt=\"image.png\"><br>JDK 中使用的工厂方法<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312730182-cf689595-714c-4d36-8359-78781ffe975a.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud9b44865&margin=%5Bobject%20Object%5D&name=image.png&originHeight=607&originWidth=958&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=83226&status=done&style=none&taskId=u664da234-c8ab-48e4-a706-67dc9fdb7a3&title=\" alt=\"image.png\"><br>如上图所示，ArrayList 和 LinkedList 使用具体的工厂类的 iterator 方法，分别创建实现 Iterator 接口类的 ArrayList$Itr和ArrayList$ListItr,以及 LinkedList$ListItr 的具体产品类。</p>\n<h2 id=\"3、抽象工厂模式\"><a href=\"#3、抽象工厂模式\" class=\"headerlink\" title=\"3、抽象工厂模式\"></a>3、抽象工厂模式</h2><p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。<br>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。<br>抽象工厂的方法经常以工厂方法的方式实现，抽象工厂的任务是定义一个负责创建一组产品的接口。这个接口内的每个方法都负责创建一个具体产品，<br>同时利用实现抽象工厂的子类来提供这些具体的做法，所以在抽象工厂中利用工厂实现生产方法是相当自然在做法。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731595-301d90a5-6b5f-4da8-8e32-96d19bfb3c30.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub322c434&margin=%5Bobject%20Object%5D&name=image.png&originHeight=625&originWidth=1320&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=125791&status=done&style=none&taskId=ued59f856-7188-425b-87c9-9141719760d&title=\" alt=\"image.png\"><br>JDK 中使用的抽象工厂<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312731132-e60e3a16-5f75-49b0-b0d8-cd2a4ed4c76e.png#clientId=u31449aae-d0c8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u846d3d23&margin=%5Bobject%20Object%5D&name=image.png&originHeight=595&originWidth=986&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=61956&status=done&style=none&taskId=ue613c9e6-bb5a-47d7-b26c-15db9431332&title=\" alt=\"image.png\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1、 所有的工厂都是用来封装对象的创建。<br>2、 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦。<br>3、 工厂方法，使用继承，把对象的创建委托给子类，由子类来实现工厂方法来创建对象。<br>4、 抽象工厂，使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}