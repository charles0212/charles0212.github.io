{"title":"JDK设计模式（一）单例模式","slug":"yuque/JDK设计模式（一）单例模式","date":"2015-01-17T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-singleton-pattern.json","excerpt":"单例模式确保一个类只有一个实例，并提供一个全局访问点。其类图如下所示。本文主要从饿汉式，懒汉式，懒汉式改进，来讲解单例模式。1、饿汉式单例饿汉式单例类是在 Java语言里实现得最为简便的单例类。在类被加载时，就会将自己实例化。public class Singleton {    private static Singleton uniqueInstance = new Singleton();    private Singleton() {        // Exists only to defeat instantiation.    }    publ","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648312497129-b46ae00b-ed09-43d2-b1ed-52150a27aad2.png#clientId=u071cfa4a-1edc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ueae36114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=332&originWidth=874&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=78397&status=done&style=none&taskId=u12f2e13d-ba01-4d4a-838c-6d2c02a4a69&title="],"content":"<p>单例模式确保一个类只有一个实例，并提供一个全局访问点。<br>其类图如下所示。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312497129-b46ae00b-ed09-43d2-b1ed-52150a27aad2.png#clientId=u071cfa4a-1edc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ueae36114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=332&originWidth=874&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=78397&status=done&style=none&taskId=u12f2e13d-ba01-4d4a-838c-6d2c02a4a69&title=\" alt=\"image.png\"><br>本文主要从饿汉式，懒汉式，懒汉式改进，来讲解单例模式。</p>\n<h2 id=\"1、饿汉式单例\"><a href=\"#1、饿汉式单例\" class=\"headerlink\" title=\"1、饿汉式单例\"></a><strong>1、饿汉式单例</strong></h2><p>饿汉式单例类是在 Java 语言里实现得最为简便的单例类。在类被加载时，就会将自己实例化。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    private static Singleton uniqueInstance &#x3D; new Singleton();\n    private Singleton() &#123;\n        &#x2F;&#x2F; Exists only to defeat instantiation.\n    &#125;\n    public static Singleton getInstance() &#123;\n        return uniqueInstance;\n    &#125;\n    &#x2F;&#x2F; other methods...\n&#125;</code></pre>\n\n<h2 id=\"2、懒汉式（双重加锁）\"><a href=\"#2、懒汉式（双重加锁）\" class=\"headerlink\" title=\"2、懒汉式（双重加锁）\"></a><strong>2、懒汉式（双重加锁）</strong></h2><p>通过 synchronized 关键字，同步不同线程对 getInstance()的访问。这就是所谓的懒汉模式。与饿汉式单例类不同的是，懒汉式单例类在第一次被引用时将自己实例化。这种简单实现的问题在于，每次访问 getInstance()都需要同步操作，而事实上同步只在第一次访问时有意义。为了避免不必要的同步操作，在 JDK1.5 以后可以使用一种双重检查加锁的方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    &#x2F;&#x2F; volatile is very important for uniqueInstance consistency.\n    private volatile static Singleton uniqueInstance &#x3D; null;\n    private Singleton() &#123;\n       &#x2F;&#x2F; Exists only to defeat instantiation.\n    &#125;\n    public static Singleton getInstance() &#123;\n       &#x2F;&#x2F; first check no need to synchronize.\n       if (uniqueInstance &#x3D;&#x3D; null) &#123;\n           &#x2F;&#x2F; second check need to synchronize, but only run limit times.\n           synchronized (Singleton.class) &#123;\n              if (uniqueInstance &#x3D;&#x3D; null) &#123;\n                  uniqueInstance &#x3D; new Singleton();\n              &#125;\n           &#125;\n       &#125;\n       return uniqueInstance;\n    &#125;\n    &#x2F;&#x2F; Other methods...\n&#125;</code></pre>\n\n<p>volatile 确保 uniqueInstance 被初始化为单例后的改变对所有线程可见，多线程能够正确处理 uniqueInstance 变量。getInstance()中包含两次判空操作，第一次判空每次访问都会执行，而第二次判空只在初始访问存在大量并发的情况下出现。通过两次判空避免了不必要的线程同步。之所以限制必须在 JDK1.5 后使用是因为，之前的 Java 存储模型不能保证 volatile 语义的完全正确实现。</p>\n<h2 id=\"3、懒汉式改进\"><a href=\"#3、懒汉式改进\" class=\"headerlink\" title=\"3、懒汉式改进\"></a>3、懒汉式改进</h2><p>为了突破这种限制《Effective Java》中给出了一种精妙的解决方法，充分利用了 Java 虚拟机的特性。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    &#x2F;&#x2F; an inner class holder the uniqueInstance.\n    private static class SingletonHolder &#123;\n       static final Singleton uniqueInstance &#x3D; new Singleton();\n    &#125;\n    private Singleton() &#123;\n       &#x2F;&#x2F; Exists only to defeat instantiation.\n    &#125;\n    public static Singleton getInstance() &#123;\n       return SingletonHolder.uniqueInstance;\n    &#125;\n    &#x2F;&#x2F; Other methods...\n&#125;</code></pre>\n\n<p>当 getInstance 方法第一次被调用时，在第一次调用 SingletonHolder.uniqueInstance，初始化 SingletonHolder 类，这种用法的优雅之处在于 getInstance 方法不需要同步，执行只有一个字段访问，因此惰性初始化对实际的访问没有任何额外的代价。VM 同步字段访问，只需要初始化 SingletonHolder 类，一旦被初始化，后续的字段访问不会涉及到任何判断和同步。<br>JDK 中使用单例模式的有 Runtime、NumberFormat 等类。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>单件模式确保程序中一个类最多只有一个实例，提供访问实例的全局点。</li>\n<li>在 Java 中实现单件模式需要私有的构造器，一个静态方法和一个静态变量。</li>\n<li>确定在性能和资源上的限制，使用适当的方案解决多线程问题</li>\n<li>使用多个类加载器，可能会导致单件失效而产生多个实例</li>\n</ol>\n","more":"<p>单例模式确保一个类只有一个实例，并提供一个全局访问点。<br>其类图如下所示。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312497129-b46ae00b-ed09-43d2-b1ed-52150a27aad2.png#clientId=u071cfa4a-1edc-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ueae36114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=332&originWidth=874&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=78397&status=done&style=none&taskId=u12f2e13d-ba01-4d4a-838c-6d2c02a4a69&title=\" alt=\"image.png\"><br>本文主要从饿汉式，懒汉式，懒汉式改进，来讲解单例模式。</p>\n<h2 id=\"1、饿汉式单例\"><a href=\"#1、饿汉式单例\" class=\"headerlink\" title=\"1、饿汉式单例\"></a><strong>1、饿汉式单例</strong></h2><p>饿汉式单例类是在 Java 语言里实现得最为简便的单例类。在类被加载时，就会将自己实例化。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    private static Singleton uniqueInstance &#x3D; new Singleton();\n    private Singleton() &#123;\n        &#x2F;&#x2F; Exists only to defeat instantiation.\n    &#125;\n    public static Singleton getInstance() &#123;\n        return uniqueInstance;\n    &#125;\n    &#x2F;&#x2F; other methods...\n&#125;</code></pre>\n\n<h2 id=\"2、懒汉式（双重加锁）\"><a href=\"#2、懒汉式（双重加锁）\" class=\"headerlink\" title=\"2、懒汉式（双重加锁）\"></a><strong>2、懒汉式（双重加锁）</strong></h2><p>通过 synchronized 关键字，同步不同线程对 getInstance()的访问。这就是所谓的懒汉模式。与饿汉式单例类不同的是，懒汉式单例类在第一次被引用时将自己实例化。这种简单实现的问题在于，每次访问 getInstance()都需要同步操作，而事实上同步只在第一次访问时有意义。为了避免不必要的同步操作，在 JDK1.5 以后可以使用一种双重检查加锁的方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    &#x2F;&#x2F; volatile is very important for uniqueInstance consistency.\n    private volatile static Singleton uniqueInstance &#x3D; null;\n    private Singleton() &#123;\n       &#x2F;&#x2F; Exists only to defeat instantiation.\n    &#125;\n    public static Singleton getInstance() &#123;\n       &#x2F;&#x2F; first check no need to synchronize.\n       if (uniqueInstance &#x3D;&#x3D; null) &#123;\n           &#x2F;&#x2F; second check need to synchronize, but only run limit times.\n           synchronized (Singleton.class) &#123;\n              if (uniqueInstance &#x3D;&#x3D; null) &#123;\n                  uniqueInstance &#x3D; new Singleton();\n              &#125;\n           &#125;\n       &#125;\n       return uniqueInstance;\n    &#125;\n    &#x2F;&#x2F; Other methods...\n&#125;</code></pre>\n\n<p>volatile 确保 uniqueInstance 被初始化为单例后的改变对所有线程可见，多线程能够正确处理 uniqueInstance 变量。getInstance()中包含两次判空操作，第一次判空每次访问都会执行，而第二次判空只在初始访问存在大量并发的情况下出现。通过两次判空避免了不必要的线程同步。之所以限制必须在 JDK1.5 后使用是因为，之前的 Java 存储模型不能保证 volatile 语义的完全正确实现。</p>\n<h2 id=\"3、懒汉式改进\"><a href=\"#3、懒汉式改进\" class=\"headerlink\" title=\"3、懒汉式改进\"></a>3、懒汉式改进</h2><p>为了突破这种限制《Effective Java》中给出了一种精妙的解决方法，充分利用了 Java 虚拟机的特性。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    &#x2F;&#x2F; an inner class holder the uniqueInstance.\n    private static class SingletonHolder &#123;\n       static final Singleton uniqueInstance &#x3D; new Singleton();\n    &#125;\n    private Singleton() &#123;\n       &#x2F;&#x2F; Exists only to defeat instantiation.\n    &#125;\n    public static Singleton getInstance() &#123;\n       return SingletonHolder.uniqueInstance;\n    &#125;\n    &#x2F;&#x2F; Other methods...\n&#125;</code></pre>\n\n<p>当 getInstance 方法第一次被调用时，在第一次调用 SingletonHolder.uniqueInstance，初始化 SingletonHolder 类，这种用法的优雅之处在于 getInstance 方法不需要同步，执行只有一个字段访问，因此惰性初始化对实际的访问没有任何额外的代价。VM 同步字段访问，只需要初始化 SingletonHolder 类，一旦被初始化，后续的字段访问不会涉及到任何判断和同步。<br>JDK 中使用单例模式的有 Runtime、NumberFormat 等类。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>单件模式确保程序中一个类最多只有一个实例，提供访问实例的全局点。</li>\n<li>在 Java 中实现单件模式需要私有的构造器，一个静态方法和一个静态变量。</li>\n<li>确定在性能和资源上的限制，使用适当的方案解决多线程问题</li>\n<li>使用多个类加载器，可能会导致单件失效而产生多个实例</li>\n</ol>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}