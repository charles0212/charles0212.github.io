{"title":"JDK设计模式（十二）策略模式","slug":"yuque/JDK设计模式（十二）策略模式","date":"2015-04-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-strategy-pattern.json","excerpt":"1、定义策略模式，又叫算法簇模式，就是定义了不同的算法族，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。2、解决的问题可以动态的改变对象的行为。3、模式中的角色1、环境对象(context)：该类中实现了对抽象策略中定义的接口或者抽象类的引用。2、抽象策略对象(Strategy)：它可由接口或抽象类来实现。3、具体策略对象(ConcreteStrategy)：它封装了实现同不功能的不同算法。利用策略模式构建应用程序，可以根据用户配置等内容，选择不同有算法来实现应用程序的功能。具体的选择有环境对象来完成。采用这种方式可以避免由于使用条件语句而带来的代","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648395476139-64516c7e-b11f-47ef-af62-edb91ca34f0d.png#clientId=u75c7c9d0-edfe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u80c3b1a9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=335&originWidth=715&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=29670&status=done&style=none&taskId=u165b42e2-0a1b-42ba-8995-32d349ffe78&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648395476131-a9f3b2d0-e0b6-4617-98b8-e9b8d6edf16c.png#clientId=u75c7c9d0-edfe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7fb060e4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=271&originWidth=1112&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=29427&status=done&style=none&taskId=uc650afc0-cc5d-4e5c-a49d-ed0d4bb79c5&title="],"content":"<h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><p>策略模式，又叫算法簇模式，就是定义了不同的算法族，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>可以动态的改变对象的行为。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>1、环境对象(context)：该类中实现了对抽象策略中定义的接口或者抽象类的引用。<br>2、抽象策略对象(Strategy)：它可由接口或抽象类来实现。<br>3、具体策略对象(ConcreteStrategy)：它封装了实现同不功能的不同算法。<br>利用策略模式构建应用程序，可以根据用户配置等内容，选择不同有算法来实现应用程序的功能。具体的选择有环境对象来完成。采用这种方式可以避免由于使用条件语句而带来的代码混乱，提高应用程序的灵活性与条理性。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>策略模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395476139-64516c7e-b11f-47ef-af62-edb91ca34f0d.png#clientId=u75c7c9d0-edfe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u80c3b1a9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=335&originWidth=715&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=29670&status=done&style=none&taskId=u165b42e2-0a1b-42ba-8995-32d349ffe78&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395476131-a9f3b2d0-e0b6-4617-98b8-e9b8d6edf16c.png#clientId=u75c7c9d0-edfe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7fb060e4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=271&originWidth=1112&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=29427&status=done&style=none&taskId=uc650afc0-cc5d-4e5c-a49d-ed0d4bb79c5&title=\" alt=\"image.png\"><br>ThreadPoolExecutor 的 4 中线程池拒绝策略，也可以自定义实现 RejectedExecutionHandler 进行扩展<br>AbortPolicy，无法处理任务任务的时候，直接抛出异常，<br>DiscardPolicy 丢弃当前将要加入队列的任务本身<br>DiscardOldestPolicy 丢弃任务队列中最旧任务<br>CallerRunsPolicy 由调用者线程去执行，在任务提交速度过快的情况，可减少任务提交的速度，同时可以保证任务的执行。</p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换。<br>2、易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展。<br>3、避免使用多重条件，如果不使用策略模式，对于所有的算法，必须使用条件语句进行连接，通过条件判断来决定使用哪一种算法，在上一篇文章中我们已经提到，使用多重条件判断是非常不容易维护的。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、维护各个策略类会给开发带来额外开销，可能大家在这方面都有经验：一般来说，策略类的数量超过 5 个，就比较令人头疼了。<br>2、必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、多个类只区别在表现行为不同，可以使用 Strategy 模式，在运行时动态选择具体要执行的行为。<br>2、需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。<br>3、对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</p>\n","more":"<h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><p>策略模式，又叫算法簇模式，就是定义了不同的算法族，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>可以动态的改变对象的行为。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>1、环境对象(context)：该类中实现了对抽象策略中定义的接口或者抽象类的引用。<br>2、抽象策略对象(Strategy)：它可由接口或抽象类来实现。<br>3、具体策略对象(ConcreteStrategy)：它封装了实现同不功能的不同算法。<br>利用策略模式构建应用程序，可以根据用户配置等内容，选择不同有算法来实现应用程序的功能。具体的选择有环境对象来完成。采用这种方式可以避免由于使用条件语句而带来的代码混乱，提高应用程序的灵活性与条理性。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>策略模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395476139-64516c7e-b11f-47ef-af62-edb91ca34f0d.png#clientId=u75c7c9d0-edfe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u80c3b1a9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=335&originWidth=715&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=29670&status=done&style=none&taskId=u165b42e2-0a1b-42ba-8995-32d349ffe78&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395476131-a9f3b2d0-e0b6-4617-98b8-e9b8d6edf16c.png#clientId=u75c7c9d0-edfe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7fb060e4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=271&originWidth=1112&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=29427&status=done&style=none&taskId=uc650afc0-cc5d-4e5c-a49d-ed0d4bb79c5&title=\" alt=\"image.png\"><br>ThreadPoolExecutor 的 4 中线程池拒绝策略，也可以自定义实现 RejectedExecutionHandler 进行扩展<br>AbortPolicy，无法处理任务任务的时候，直接抛出异常，<br>DiscardPolicy 丢弃当前将要加入队列的任务本身<br>DiscardOldestPolicy 丢弃任务队列中最旧任务<br>CallerRunsPolicy 由调用者线程去执行，在任务提交速度过快的情况，可减少任务提交的速度，同时可以保证任务的执行。</p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换。<br>2、易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展。<br>3、避免使用多重条件，如果不使用策略模式，对于所有的算法，必须使用条件语句进行连接，通过条件判断来决定使用哪一种算法，在上一篇文章中我们已经提到，使用多重条件判断是非常不容易维护的。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、维护各个策略类会给开发带来额外开销，可能大家在这方面都有经验：一般来说，策略类的数量超过 5 个，就比较令人头疼了。<br>2、必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、多个类只区别在表现行为不同，可以使用 Strategy 模式，在运行时动态选择具体要执行的行为。<br>2、需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。<br>3、对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}