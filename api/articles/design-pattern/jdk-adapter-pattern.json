{"title":"JDK设计模式（五）适配器模式","slug":"yuque/JDK设计模式（五）适配器模式","date":"2015-04-12T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-adapter-pattern.json","excerpt":"1、定义将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。2、解决的问题即 Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。3、模式中的角色目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。需要适配的类（Adaptee）：需要适配的类或适配者类。适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。4、模式解读在 GoF的设计模式中，对适配器模式讲了两种类型，类适配器模式和对象适配器模式。由于","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648394415478-ce34ebc6-c75e-495c-a027-99fcaad03f52.png#clientId=udc1a5ed7-d307-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc724e000&margin=%5Bobject%20Object%5D&name=image.png&originHeight=456&originWidth=861&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=53638&status=done&style=none&taskId=u2ad79016-5006-42e5-b81f-69fc567e84e&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648394415547-22152ac8-e1bd-4b87-b5f8-2bb14a6d93c9.png#clientId=udc1a5ed7-d307-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua9a7001b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=382&originWidth=882&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57629&status=done&style=none&taskId=u3ef724bd-031e-44d5-bcdf-12f0cb083d3&title="],"content":"<h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><p>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>即 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。<br>需要适配的类（Adaptee）：需要适配的类或适配者类。<br>适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>在 GoF 的设计模式中，对适配器模式讲了两种类型，类适配器模式和对象适配器模式。由于类适配器模式通过多重继承对一个接口与另一个接口进行匹配，而 C&#x3D;、java 等语言都不支持多重继承，因而这里只是介绍对象适配器。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394415478-ce34ebc6-c75e-495c-a027-99fcaad03f52.png#clientId=udc1a5ed7-d307-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc724e000&margin=%5Bobject%20Object%5D&name=image.png&originHeight=456&originWidth=861&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=53638&status=done&style=none&taskId=u2ad79016-5006-42e5-b81f-69fc567e84e&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>InputStreamReader 类实现面向字节的输入输出向面向字符的输入输出的转换，使用适配器模式，以字符的方式从输入流中读取。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394415547-22152ac8-e1bd-4b87-b5f8-2bb14a6d93c9.png#clientId=udc1a5ed7-d307-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua9a7001b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=382&originWidth=882&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57629&status=done&style=none&taskId=u3ef724bd-031e-44d5-bcdf-12f0cb083d3&title=\" alt=\"image.png\"></p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、 通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。<br>2、 复用了现存的类，解决了现存类和复用环境要求不一致的问题。<br>3、将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。<br>4、 一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>对于对象适配器来说，更换适配器的实现过程比较复杂。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、 系统需要使用现有的类，而这些类的接口不符合系统的接口。<br>2、 想要建立一个可以重用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。<br>3、 两个类所做的事情相同或相似，但是具有不同接口的时候。<br>4、 旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候。<br>5、 使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能。</p>\n","more":"<h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><p>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>即 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。<br>需要适配的类（Adaptee）：需要适配的类或适配者类。<br>适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>在 GoF 的设计模式中，对适配器模式讲了两种类型，类适配器模式和对象适配器模式。由于类适配器模式通过多重继承对一个接口与另一个接口进行匹配，而 C&#x3D;、java 等语言都不支持多重继承，因而这里只是介绍对象适配器。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394415478-ce34ebc6-c75e-495c-a027-99fcaad03f52.png#clientId=udc1a5ed7-d307-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc724e000&margin=%5Bobject%20Object%5D&name=image.png&originHeight=456&originWidth=861&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=53638&status=done&style=none&taskId=u2ad79016-5006-42e5-b81f-69fc567e84e&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>InputStreamReader 类实现面向字节的输入输出向面向字符的输入输出的转换，使用适配器模式，以字符的方式从输入流中读取。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394415547-22152ac8-e1bd-4b87-b5f8-2bb14a6d93c9.png#clientId=udc1a5ed7-d307-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua9a7001b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=382&originWidth=882&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57629&status=done&style=none&taskId=u3ef724bd-031e-44d5-bcdf-12f0cb083d3&title=\" alt=\"image.png\"></p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、 通过适配器，客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑。<br>2、 复用了现存的类，解决了现存类和复用环境要求不一致的问题。<br>3、将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。<br>4、 一个对象适配器可以把多个不同的适配者类适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>对于对象适配器来说，更换适配器的实现过程比较复杂。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、 系统需要使用现有的类，而这些类的接口不符合系统的接口。<br>2、 想要建立一个可以重用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。<br>3、 两个类所做的事情相同或相似，但是具有不同接口的时候。<br>4、 旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改原有类的时候。<br>5、 使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}