{"title":"JDK设计模式（九）外观模式","slug":"yuque/JDK设计模式（九）外观模式","date":"2015-04-12T03:00:00.000Z","updated":"2022-05-15T04:19:28.492Z","comments":true,"path":"api/articles/design-pattern/jdk-facade-pattern.json","excerpt":"1、定义提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易访问。2、解决的问题通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，降低应用程序的复杂度，并且提高了程序的可维护性。封装一组交互类，一致地对外提供接口，简化子系统调用。3、模式中的角色1、外观角色（Facade）：是模式的核心，他被客户client角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订几种功能组合。2、子系统角色（Subsystemclasses）：实现子系统的功能，并处理由Facade对象指派的任务。对子系统而言，fa","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648394983121-feeb0507-eb88-4d2a-b5a9-9c959efd7d9b.png#clientId=u813378e4-b28a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u413bc06c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=503&originWidth=823&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=48939&status=done&style=none&taskId=ufff6c00b-9d5f-4730-900d-4fd0fd5f185&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648394983169-ecfea32a-3754-4df3-83b5-475b9a8b522b.png#clientId=u813378e4-b28a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u455cbf3f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=966&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=64242&status=done&style=none&taskId=ueb1b7ca3-c96b-4f9a-985d-a44567dff77&title="],"content":"<h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><p>提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易访问。</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，降低应用程序的复杂度，并且提高了程序的可维护性。封装一组交互类，一致地对外提供接口，简化子系统调用。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>1、外观角色（Facade）：是模式的核心，他被客户 client 角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订几种功能组合。<br>2、子系统角色（Subsystem classes）：实现子系统的功能，并处理由 Facade 对象指派的任务。对子系统而言，facade 和 client 角色是未知的，没有 Facade 的任何相关信息；即没有指向 Facade 的实例。<br>3、 客户角色（client）：调用 facade 角色获得完成相应的功能。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>外观模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394983121-feeb0507-eb88-4d2a-b5a9-9c959efd7d9b.png#clientId=u813378e4-b28a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u413bc06c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=503&originWidth=823&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=48939&status=done&style=none&taskId=ufff6c00b-9d5f-4730-900d-4fd0fd5f185&title=\" alt=\"image.png\"><br>Facade 外观类负责将客户的请求代理给适当的子类系统，子系统类负责处理由 Facade 对象指派的任务。对子系统而言，facade 和 client 角色是未知的，没有 Facade 的任何相关信息；没有指向 Facade 的实例。</p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 日志框架主要包括如下几个部件：<br>Logger：日志记录对象。用于记录日志信息。<br>Handler：用于处理日志信息的输出。在 Handler 类中，可以决定日志是输出到文件中还是控制台中（相当于 log4j 中的 appender）。<br>Filter：用于过滤日志。在 Filter 类中，可以根据日志级别或者某种条件来决定是否输出该日志。这样达到去除冗余信息的目的。<br>Formatter：用于格式化日志信息。该类可以将日志文本格式化成 XML 或者 HTML 的格式，这完全依赖于具体的实现。<br>Level：用于表示日志的级别。 JDK 日志框架默认有如下级别：SEVERE（最高值） 、WARNING 、INFO 、CONFIG 、FINE 、FINER 、FINEST（最低值）、ALL(记录所有信息) OFF(不记录任何级别信息)。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394983169-ecfea32a-3754-4df3-83b5-475b9a8b522b.png#clientId=u813378e4-b28a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u455cbf3f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=966&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=64242&status=done&style=none&taskId=ueb1b7ca3-c96b-4f9a-985d-a44567dff77&title=\" alt=\"image.png\"><br>使用 LogManager.getLogger 获取 Logger，然后通过 logger.info 等接口记录日志。</p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。<br>2、实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。<br>3、降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。<br>4、只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。<strong>**</strong></p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。<br>2、 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过 facade 层。<br>2、客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性 和可移植性。<br>3、当你需要构建一个层次结构的子系统时，使用 facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过 facade 进行通讯，从而简化了它们之间的依赖关系。</p>\n","more":"<h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><p>提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易访问。</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，降低应用程序的复杂度，并且提高了程序的可维护性。封装一组交互类，一致地对外提供接口，简化子系统调用。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>1、外观角色（Facade）：是模式的核心，他被客户 client 角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订几种功能组合。<br>2、子系统角色（Subsystem classes）：实现子系统的功能，并处理由 Facade 对象指派的任务。对子系统而言，facade 和 client 角色是未知的，没有 Facade 的任何相关信息；即没有指向 Facade 的实例。<br>3、 客户角色（client）：调用 facade 角色获得完成相应的功能。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>外观模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394983121-feeb0507-eb88-4d2a-b5a9-9c959efd7d9b.png#clientId=u813378e4-b28a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u413bc06c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=503&originWidth=823&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=48939&status=done&style=none&taskId=ufff6c00b-9d5f-4730-900d-4fd0fd5f185&title=\" alt=\"image.png\"><br>Facade 外观类负责将客户的请求代理给适当的子类系统，子系统类负责处理由 Facade 对象指派的任务。对子系统而言，facade 和 client 角色是未知的，没有 Facade 的任何相关信息；没有指向 Facade 的实例。</p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 日志框架主要包括如下几个部件：<br>Logger：日志记录对象。用于记录日志信息。<br>Handler：用于处理日志信息的输出。在 Handler 类中，可以决定日志是输出到文件中还是控制台中（相当于 log4j 中的 appender）。<br>Filter：用于过滤日志。在 Filter 类中，可以根据日志级别或者某种条件来决定是否输出该日志。这样达到去除冗余信息的目的。<br>Formatter：用于格式化日志信息。该类可以将日志文本格式化成 XML 或者 HTML 的格式，这完全依赖于具体的实现。<br>Level：用于表示日志的级别。 JDK 日志框架默认有如下级别：SEVERE（最高值） 、WARNING 、INFO 、CONFIG 、FINE 、FINER 、FINEST（最低值）、ALL(记录所有信息) OFF(不记录任何级别信息)。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394983169-ecfea32a-3754-4df3-83b5-475b9a8b522b.png#clientId=u813378e4-b28a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u455cbf3f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=966&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=64242&status=done&style=none&taskId=ueb1b7ca3-c96b-4f9a-985d-a44567dff77&title=\" alt=\"image.png\"><br>使用 LogManager.getLogger 获取 Logger，然后通过 logger.info 等接口记录日志。</p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。<br>2、实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。<br>3、降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。<br>4、只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。<strong>**</strong></p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。<br>2、 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过 facade 层。<br>2、客户程序与抽象类的实现部分之间存在着很大的依赖性。引入 facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性 和可移植性。<br>3、当你需要构建一个层次结构的子系统时，使用 facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过 facade 进行通讯，从而简化了它们之间的依赖关系。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}