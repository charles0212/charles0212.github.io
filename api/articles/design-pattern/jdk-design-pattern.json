{"title":"JDK中的设计模式","slug":"yuque/JDK中的设计模式","date":"2015-01-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.493Z","comments":true,"path":"api/articles/design-pattern/jdk-design-pattern.json","excerpt":"本文主要是归纳了 JDK中所包含的设计模式，包括作用和其设计类图。一、设计模式的作用 1. 反复出现问题的解决方案 2. 增强软件的灵活性 3. 适应软件不断变化二、设计模式的七大原则 1. 开闭原则 OCP（Open Close    Principle），一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 2. 里氏代换原则 LSP（Liskov    Substitution    Principle），子类可以扩展父类的功能，但不能改变父类原有的功能 3. 依赖倒转原则    DIP（Dependence    Inversion    ","covers":["/images/c3.jpg"],"content":"<p>本文主要是归纳了 JDK 中所包含的设计模式，包括作用和其设计类图。</p>\n<h2 id=\"一、设计模式的作用\"><a href=\"#一、设计模式的作用\" class=\"headerlink\" title=\"一、设计模式的作用\"></a>一、设计模式的作用</h2><ol>\n<li>反复出现问题的解决方案</li>\n<li>增强软件的灵活性</li>\n<li>适应软件不断变化</li>\n</ol>\n<h2 id=\"二、设计模式的七大原则\"><a href=\"#二、设计模式的七大原则\" class=\"headerlink\" title=\"二、设计模式的七大原则\"></a>二、设计模式的七大原则</h2><ol>\n<li><strong>开闭原则 OCP</strong>（Open Close Principle），一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</li>\n<li><strong>里氏代换原则 LSP</strong>（Liskov Substitution Principle），子类可以扩展父类的功能，但不能改变父类原有的功能</li>\n<li><strong>依赖倒转原则 DIP</strong>（Dependence Inversion Principle），面向接口编程，依赖于抽象而不依赖于具体。</li>\n<li><strong>接口隔离原则 ISP</strong>（Interface Segregation Principle），建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</li>\n<li><strong>合成复用原则 CRP</strong>（Composite Reuse Principle），要尽量的使用合成和聚合，而不是继承关系达到复用的目的</li>\n<li><strong>迪米特法则 LOD</strong>（Law Of Demeter），也叫最少知识原则 LKP(Least Knowledge Principle)，一个对象应该对其他对象保持最少的了解。</li>\n<li><strong>单一职责原则 SRP</strong>（Single Responsibility Principle），一个类只负责一项职责，应该仅有一个引起它变化的原因</li>\n</ol>\n<h2 id=\"三、JDK-中使用到的设计模式以及分析\"><a href=\"#三、JDK-中使用到的设计模式以及分析\" class=\"headerlink\" title=\"三、JDK 中使用到的设计模式以及分析\"></a>三、JDK 中使用到的设计模式以及分析</h2><h3 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a><strong>创建型模式</strong></h3><ol>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-singleton-pattern/\">单例模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-factory-pattern/\">简单工厂、工厂方法、抽象工厂模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-builder-pattern/\">建造者模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-prototype-pattern/\">原型模式</a></li>\n</ol>\n<h3 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a><strong>结构型模式</strong></h3><ol>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-adapter-pattern/\">适配器模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-bridge-pattern/\">桥接模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-composite-pattern/\">组合模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-decorator-pattern/\">装饰模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-facade-pattern/\">外观模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-flyweight-pattern/\">享元模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-proxy-pattern/\">代理模式</a></li>\n</ol>\n<h3 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a><strong>行为型模式</strong></h3><ol>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-strategy-pattern/\">策略模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-template-method-pattern/\">模板方法模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-observer-pattern/\">观察者模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-iterator-pattern/\">迭代器模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-responsibility-pattern/\">责任链模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-command-pattern/\">命令模式</a></li>\n<li>访问者模式</li>\n<li>状态模式</li>\n<li>备忘录模式</li>\n<li>中介者模式</li>\n<li>解释器模式</li>\n</ol>\n","more":"<p>本文主要是归纳了 JDK 中所包含的设计模式，包括作用和其设计类图。</p>\n<h2 id=\"一、设计模式的作用\"><a href=\"#一、设计模式的作用\" class=\"headerlink\" title=\"一、设计模式的作用\"></a>一、设计模式的作用</h2><ol>\n<li>反复出现问题的解决方案</li>\n<li>增强软件的灵活性</li>\n<li>适应软件不断变化</li>\n</ol>\n<h2 id=\"二、设计模式的七大原则\"><a href=\"#二、设计模式的七大原则\" class=\"headerlink\" title=\"二、设计模式的七大原则\"></a>二、设计模式的七大原则</h2><ol>\n<li><strong>开闭原则 OCP</strong>（Open Close Principle），一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</li>\n<li><strong>里氏代换原则 LSP</strong>（Liskov Substitution Principle），子类可以扩展父类的功能，但不能改变父类原有的功能</li>\n<li><strong>依赖倒转原则 DIP</strong>（Dependence Inversion Principle），面向接口编程，依赖于抽象而不依赖于具体。</li>\n<li><strong>接口隔离原则 ISP</strong>（Interface Segregation Principle），建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</li>\n<li><strong>合成复用原则 CRP</strong>（Composite Reuse Principle），要尽量的使用合成和聚合，而不是继承关系达到复用的目的</li>\n<li><strong>迪米特法则 LOD</strong>（Law Of Demeter），也叫最少知识原则 LKP(Least Knowledge Principle)，一个对象应该对其他对象保持最少的了解。</li>\n<li><strong>单一职责原则 SRP</strong>（Single Responsibility Principle），一个类只负责一项职责，应该仅有一个引起它变化的原因</li>\n</ol>\n<h2 id=\"三、JDK-中使用到的设计模式以及分析\"><a href=\"#三、JDK-中使用到的设计模式以及分析\" class=\"headerlink\" title=\"三、JDK 中使用到的设计模式以及分析\"></a>三、JDK 中使用到的设计模式以及分析</h2><h3 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a><strong>创建型模式</strong></h3><ol>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-singleton-pattern/\">单例模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-factory-pattern/\">简单工厂、工厂方法、抽象工厂模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-builder-pattern/\">建造者模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-prototype-pattern/\">原型模式</a></li>\n</ol>\n<h3 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a><strong>结构型模式</strong></h3><ol>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-adapter-pattern/\">适配器模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-bridge-pattern/\">桥接模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-composite-pattern/\">组合模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-decorator-pattern/\">装饰模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-facade-pattern/\">外观模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-flyweight-pattern/\">享元模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-proxy-pattern/\">代理模式</a></li>\n</ol>\n<h3 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a><strong>行为型模式</strong></h3><ol>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-strategy-pattern/\">策略模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-template-method-pattern/\">模板方法模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-observer-pattern/\">观察者模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-iterator-pattern/\">迭代器模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-responsibility-pattern/\">责任链模式</a></li>\n<li><a href=\"https://www.alicharles.com/article/design-pattern/jdk-command-pattern/\">命令模式</a></li>\n<li>访问者模式</li>\n<li>状态模式</li>\n<li>备忘录模式</li>\n<li>中介者模式</li>\n<li>解释器模式</li>\n</ol>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}