{"title":"JDK设计模式（十五）迭代器模式","slug":"yuque/JDK设计模式（十五）迭代器模式","date":"2015-11-12T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-iterator-pattern.json","excerpt":"1. 概述迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。2. 解决的问题把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所。3. 模式中的角色1、抽象迭代器(Iterator)：定义出遍历元素所需的接口。2、具体迭代器(ConcreteIterator)：实现Iterator接口，并保持迭代过程中的游标位置。3、聚集(Aggregate)：给出创建迭代器(Iterator)对象的接口。4、具体聚集(ConcreteAggregate)：实现创建迭代器(Iterator)对象的接口，返回一个合适","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648395894327-847aa1b6-af5b-4f37-8b7a-752a17d0efb1.png#clientId=u2fe704bb-ed5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udb7d5c2f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=564&originWidth=807&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=100567&status=done&style=none&taskId=u0d4646e4-1889-4b8b-b81e-5609f74859b&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648395894174-a01b1c2a-f150-4234-9c87-f25309b4074c.png#clientId=u2fe704bb-ed5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9bc52632&margin=%5Bobject%20Object%5D&name=image.png&originHeight=536&originWidth=889&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57544&status=done&style=none&taskId=udc2a284f-8950-4fd0-a394-9a2d34e2069&title="],"content":"<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p>\n<h2 id=\"2-解决的问题\"><a href=\"#2-解决的问题\" class=\"headerlink\" title=\"2. 解决的问题\"></a>2. 解决的问题</h2><p>把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所。</p>\n<h2 id=\"3-模式中的角色\"><a href=\"#3-模式中的角色\" class=\"headerlink\" title=\"3. 模式中的角色\"></a>3. 模式中的角色</h2><p>1、抽象迭代器(Iterator)：定义出遍历元素所需的接口。<br>2、具体迭代器(ConcreteIterator)：实现 Iterator 接口，并保持迭代过程中的游标位置。<br>3、聚集(Aggregate)：给出创建迭代器(Iterator)对象的接口。<br>4、具体聚集(ConcreteAggregate)：实现创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。<br>5、客户端(Client)：持有对聚集及其迭代子对象的引用，调用迭代器对象的迭代接口。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>迭代器模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395894327-847aa1b6-af5b-4f37-8b7a-752a17d0efb1.png#clientId=u2fe704bb-ed5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udb7d5c2f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=564&originWidth=807&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=100567&status=done&style=none&taskId=u0d4646e4-1889-4b8b-b81e-5609f74859b&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 中 Iterator 和 Collection<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395894174-a01b1c2a-f150-4234-9c87-f25309b4074c.png#clientId=u2fe704bb-ed5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9bc52632&margin=%5Bobject%20Object%5D&name=image.png&originHeight=536&originWidth=889&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57544&status=done&style=none&taskId=udc2a284f-8950-4fd0-a394-9a2d34e2069&title=\" alt=\"image.png\"><br>ArrayList 为具体聚合对象，创建了具体的 ArrayList$Itr和ArrayList$ListItr 的具体迭代器类。</p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、迭代器模式简化了聚集的界面。<br>2、因为每一个聚集对象可以有多个迭代器对象，每个迭代器状态是独立的。<br>3、由于遍历算法被封装在迭代器角色里面，因此迭代的算法可以独立于聚集角色变化。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、迭代器模式给客户端一个聚集被顺序化的感觉。<br>2、迭代器给出的聚集元素没有类型特征。</p>\n","more":"<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p>\n<h2 id=\"2-解决的问题\"><a href=\"#2-解决的问题\" class=\"headerlink\" title=\"2. 解决的问题\"></a>2. 解决的问题</h2><p>把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所。</p>\n<h2 id=\"3-模式中的角色\"><a href=\"#3-模式中的角色\" class=\"headerlink\" title=\"3. 模式中的角色\"></a>3. 模式中的角色</h2><p>1、抽象迭代器(Iterator)：定义出遍历元素所需的接口。<br>2、具体迭代器(ConcreteIterator)：实现 Iterator 接口，并保持迭代过程中的游标位置。<br>3、聚集(Aggregate)：给出创建迭代器(Iterator)对象的接口。<br>4、具体聚集(ConcreteAggregate)：实现创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。<br>5、客户端(Client)：持有对聚集及其迭代子对象的引用，调用迭代器对象的迭代接口。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>迭代器模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395894327-847aa1b6-af5b-4f37-8b7a-752a17d0efb1.png#clientId=u2fe704bb-ed5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udb7d5c2f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=564&originWidth=807&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=100567&status=done&style=none&taskId=u0d4646e4-1889-4b8b-b81e-5609f74859b&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 中 Iterator 和 Collection<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395894174-a01b1c2a-f150-4234-9c87-f25309b4074c.png#clientId=u2fe704bb-ed5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9bc52632&margin=%5Bobject%20Object%5D&name=image.png&originHeight=536&originWidth=889&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57544&status=done&style=none&taskId=udc2a284f-8950-4fd0-a394-9a2d34e2069&title=\" alt=\"image.png\"><br>ArrayList 为具体聚合对象，创建了具体的 ArrayList$Itr和ArrayList$ListItr 的具体迭代器类。</p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、迭代器模式简化了聚集的界面。<br>2、因为每一个聚集对象可以有多个迭代器对象，每个迭代器状态是独立的。<br>3、由于遍历算法被封装在迭代器角色里面，因此迭代的算法可以独立于聚集角色变化。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、迭代器模式给客户端一个聚集被顺序化的感觉。<br>2、迭代器给出的聚集元素没有类型特征。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}