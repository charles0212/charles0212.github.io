{"title":"JDK设计模式（十一）代理模式","slug":"yuque/JDK设计模式（十一）代理模式","date":"2015-04-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.492Z","comments":true,"path":"api/articles/design-pattern/jdk-proxy-pattern.json","excerpt":"1、定义为另一个对象提供一个替身或占位符以控制对这个对象的访问。2、解决的问题在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，提供额外的处理或者不同的操作。3、模式中的角色1、抽象主题角色(Subject)：声明真实对象和代理对象的共同接口；2、代理角色(Proxy)：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。3、真实主题角色(RealSub","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648395324883-e19f0053-40d6-415f-abf1-de1c35f0557e.png#clientId=uba13fbea-375f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6d5192e9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=520&originWidth=875&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=105629&status=done&style=none&taskId=u6861b05b-2a4a-4ffe-8557-370a66eead0&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648395324726-dbbb19a3-b928-4c9c-8d78-3fc7c61b62ba.png#clientId=uba13fbea-375f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc20650f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=851&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=32275&status=done&style=none&taskId=u3a378490-f6e9-47bf-92bb-bac29aec279&title="],"content":"<h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><p>为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，提供额外的处理或者不同的操作。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>1、抽象主题角色(Subject)：声明真实对象和代理对象的共同接口；<br>2、 代理角色(Proxy)：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。<br>3、真实主题角色(RealSubject)：代理角色所代表的真实对象，是我们最终要引用的对象。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>代理模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395324883-e19f0053-40d6-415f-abf1-de1c35f0557e.png#clientId=uba13fbea-375f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6d5192e9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=520&originWidth=875&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=105629&status=done&style=none&taskId=u6861b05b-2a4a-4ffe-8557-370a66eead0&title=\" alt=\"image.png\"><br>RealSubject 通常是真正做事的对象，proxy 会控制对 RealSubject 的访问。Proxy 持有 Subject 的引用，所以必要时它可以将请求转发给 Subject，在某些例子中，Proxy 还负责 RealSubject 的创建和销毁。Procy 和 RealSubject 都实现了 Subject 接口，任何用到 RealSubject 的地方都可以使用 Proxy 对象取代。</p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 中体现：动态代理和远程方法调用 RMI，以动态代理为例。所谓 Dynamic Proxy 是这样一种 class，它是在运行时生成的 class，在生成它时你必须提供一组 interface 给它，然后该 class 就宣称它实现了这些 interface。你当然可以把该 class 的实例当作这些 interface 中的任何一个来用。当然啦，这个 Dynamic Proxy 其实就是一个 Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个 handler，由它接管实际的工作，类图如下所示。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395324726-dbbb19a3-b928-4c9c-8d78-3fc7c61b62ba.png#clientId=uba13fbea-375f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc20650f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=851&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=32275&status=done&style=none&taskId=u3a378490-f6e9-47bf-92bb-bac29aec279&title=\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;抽象角色(之前是抽象类，此处应改为接口)：\n\npublic interface Subject&#123;\n    public void request();\n&#125;\n\n&#x2F;&#x2F;具体角色RealSubject：实现了Subject接口的request()方法。\npublic class RealSubject implements Subject &#123;\n    public RealSubject() &#123;\n\n    &#125;\n\n    public void request() &#123;\n        System.out.println(&quot;From real subject.&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;代理角色：\nimport java.lang.reflect.Method;\nimport java.lang.reflect.InvocationHandler;\n\npublic class DynamicSubject implements InvocationHandler &#123;\n\n    private Object sub;\n    public DynamicSubject(Object sub) &#123;\n        this.sub &#x3D; sub;\n    &#125;\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        System.out.println(&quot;before calling &quot; + method);\n        method.invoke(sub,args);\n        System.out.println(&quot;after calling &quot; + method);\n        return null;\n    &#125;\n\n&#125;</code></pre>\n\n<p>该代理类的内部属性为 Object 类，实际使用时通过该类的构造函数 DynamicSubject(Object sub)对其赋值；此外，在该类还实现了 invoke 方法，该方法中的”method.invoke(sub,args)” 其实就是调用被代理对象的将要被执行的方法，方法参数 sub 是实际的被代理对象，args 为执行被代理对象相应操作所需的参数。通过动态代理类，我们可以在调用之前或之后执行一些相关操作。<br>客户端代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\npublic class Client &#123;\n    public static void main(String[] args) throws Throwable &#123;\n        RealSubject realSubject &#x3D; new RealSubject(); &#x2F;&#x2F;在这里指定被代理类\n        InvocationHandler handler &#x3D; new DynamicSubject(realSubject); &#x2F;&#x2F;初始化代理类\n        Class clazz &#x3D; realSubject.getClass();\n        Subject subject &#x3D; (Subject) Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),handler);\n        subject.request();\n    &#125;\n&#125;</code></pre>\n\n<p>通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject 接口)可以在运行时改变，控制的方式(DynamicSubject 类)也可以动态改变，从而实现了非常灵活的动态代理关系。</p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><p>与其他模式比较<br>1、适配器 Adapter 为它所适配的对象提供了一个不同的接口。相反，代理提供了与它的实体相同的接口。然而，用于访问保护的代理可能会拒绝执行实体的操作，因此，它的接口实际上可能只是实体接口的一个子集。<br>2、装饰器模式 Decorator：尽管 Decorator 的实现部分与代理相似，但 Decorator 的目的不一样。Decorator 为对象添加一个或多个功能，而代理则控制对对象的访问。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、透明调用被代理对象，无须知道复杂实现细节<br>2、 增加被代理类的功能</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、远程代理(RemoteProxy)，可以隐藏一个对象存在于不同地址空间的事实。也使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。<br>2、虚拟代理(VirtualProxy)，允许内存开销较大的对象在需要的时候创建。只有我们真正需要这个对象的时候才创建。<br>3、写入时复制代理(Copy-On-Write Proxy)，用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。是虚拟代理的一个变体。<br>4、保护代理(Protection-AccessProxy)，为不同的客户提供不同级别的目标对象访问权限<br>5、缓存代理(CacheProxy)，为开销大的运算结果提供暂时存储，它允许多个客户共享结果，以减少计算或网络延迟。<br>6、防火墙代理(Firewall Proxy)，控制网络资源的访问，保护主题免于恶意客户的侵害。<br>7、同步代理(SynchronizationProxy)，在多线程的情况下为主题提供安全的访问。<br>8、智能引用代理(Smar ReferenceProxy)，当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。<br>9、复杂隐藏代理(ComplexityHidingProxy)，用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也称为外观代理(Façade Proxy)，这不难理解。复杂隐藏代理和外观模式是不一样的，因为代理控制访问，而外观模式是不一样的，因为代理控制访问，而外观模式只提供另一组接口。</p>\n","more":"<h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><p>为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，提供额外的处理或者不同的操作。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>1、抽象主题角色(Subject)：声明真实对象和代理对象的共同接口；<br>2、 代理角色(Proxy)：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。<br>3、真实主题角色(RealSubject)：代理角色所代表的真实对象，是我们最终要引用的对象。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>代理模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395324883-e19f0053-40d6-415f-abf1-de1c35f0557e.png#clientId=uba13fbea-375f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6d5192e9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=520&originWidth=875&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=105629&status=done&style=none&taskId=u6861b05b-2a4a-4ffe-8557-370a66eead0&title=\" alt=\"image.png\"><br>RealSubject 通常是真正做事的对象，proxy 会控制对 RealSubject 的访问。Proxy 持有 Subject 的引用，所以必要时它可以将请求转发给 Subject，在某些例子中，Proxy 还负责 RealSubject 的创建和销毁。Procy 和 RealSubject 都实现了 Subject 接口，任何用到 RealSubject 的地方都可以使用 Proxy 对象取代。</p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 中体现：动态代理和远程方法调用 RMI，以动态代理为例。所谓 Dynamic Proxy 是这样一种 class，它是在运行时生成的 class，在生成它时你必须提供一组 interface 给它，然后该 class 就宣称它实现了这些 interface。你当然可以把该 class 的实例当作这些 interface 中的任何一个来用。当然啦，这个 Dynamic Proxy 其实就是一个 Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个 handler，由它接管实际的工作，类图如下所示。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395324726-dbbb19a3-b928-4c9c-8d78-3fc7c61b62ba.png#clientId=uba13fbea-375f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc20650f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=851&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=32275&status=done&style=none&taskId=u3a378490-f6e9-47bf-92bb-bac29aec279&title=\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;抽象角色(之前是抽象类，此处应改为接口)：\n\npublic interface Subject&#123;\n    public void request();\n&#125;\n\n&#x2F;&#x2F;具体角色RealSubject：实现了Subject接口的request()方法。\npublic class RealSubject implements Subject &#123;\n    public RealSubject() &#123;\n\n    &#125;\n\n    public void request() &#123;\n        System.out.println(&quot;From real subject.&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;代理角色：\nimport java.lang.reflect.Method;\nimport java.lang.reflect.InvocationHandler;\n\npublic class DynamicSubject implements InvocationHandler &#123;\n\n    private Object sub;\n    public DynamicSubject(Object sub) &#123;\n        this.sub &#x3D; sub;\n    &#125;\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        System.out.println(&quot;before calling &quot; + method);\n        method.invoke(sub,args);\n        System.out.println(&quot;after calling &quot; + method);\n        return null;\n    &#125;\n\n&#125;</code></pre>\n\n<p>该代理类的内部属性为 Object 类，实际使用时通过该类的构造函数 DynamicSubject(Object sub)对其赋值；此外，在该类还实现了 invoke 方法，该方法中的”method.invoke(sub,args)” 其实就是调用被代理对象的将要被执行的方法，方法参数 sub 是实际的被代理对象，args 为执行被代理对象相应操作所需的参数。通过动态代理类，我们可以在调用之前或之后执行一些相关操作。<br>客户端代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\npublic class Client &#123;\n    public static void main(String[] args) throws Throwable &#123;\n        RealSubject realSubject &#x3D; new RealSubject(); &#x2F;&#x2F;在这里指定被代理类\n        InvocationHandler handler &#x3D; new DynamicSubject(realSubject); &#x2F;&#x2F;初始化代理类\n        Class clazz &#x3D; realSubject.getClass();\n        Subject subject &#x3D; (Subject) Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(),handler);\n        subject.request();\n    &#125;\n&#125;</code></pre>\n\n<p>通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject 接口)可以在运行时改变，控制的方式(DynamicSubject 类)也可以动态改变，从而实现了非常灵活的动态代理关系。</p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><p>与其他模式比较<br>1、适配器 Adapter 为它所适配的对象提供了一个不同的接口。相反，代理提供了与它的实体相同的接口。然而，用于访问保护的代理可能会拒绝执行实体的操作，因此，它的接口实际上可能只是实体接口的一个子集。<br>2、装饰器模式 Decorator：尽管 Decorator 的实现部分与代理相似，但 Decorator 的目的不一样。Decorator 为对象添加一个或多个功能，而代理则控制对对象的访问。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、透明调用被代理对象，无须知道复杂实现细节<br>2、 增加被代理类的功能</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、远程代理(RemoteProxy)，可以隐藏一个对象存在于不同地址空间的事实。也使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。<br>2、虚拟代理(VirtualProxy)，允许内存开销较大的对象在需要的时候创建。只有我们真正需要这个对象的时候才创建。<br>3、写入时复制代理(Copy-On-Write Proxy)，用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。是虚拟代理的一个变体。<br>4、保护代理(Protection-AccessProxy)，为不同的客户提供不同级别的目标对象访问权限<br>5、缓存代理(CacheProxy)，为开销大的运算结果提供暂时存储，它允许多个客户共享结果，以减少计算或网络延迟。<br>6、防火墙代理(Firewall Proxy)，控制网络资源的访问，保护主题免于恶意客户的侵害。<br>7、同步代理(SynchronizationProxy)，在多线程的情况下为主题提供安全的访问。<br>8、智能引用代理(Smar ReferenceProxy)，当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。<br>9、复杂隐藏代理(ComplexityHidingProxy)，用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也称为外观代理(Façade Proxy)，这不难理解。复杂隐藏代理和外观模式是不一样的，因为代理控制访问，而外观模式是不一样的，因为代理控制访问，而外观模式只提供另一组接口。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}