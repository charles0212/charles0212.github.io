{"title":"JDK设计模式（十三）模板方法模式","slug":"yuque/JDK设计模式（十三）模板方法模式","date":"2015-10-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.492Z","comments":true,"path":"api/articles/design-pattern/jdk-template-method-pattern.json","excerpt":"1、概述定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。2、模式中的角色抽象模板类（AbstractTemplate）：实现了模板方法，定义了算法的骨架。具体模板类（ConcreteTemplate)：实现抽象类中的抽象方法，已完成完整的算法。3、模式解读模板方式模式的类图如下所示模板方法中的方法可以分为两大类：模板方法和基本方法。模板方法，一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648395550490-8058e515-fe25-457f-9654-69c2d8e3fbe9.png#clientId=ue10b6c59-eefb-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucc44435c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=489&originWidth=778&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=73747&status=done&style=none&taskId=u00e60f97-cfd3-4616-abb2-617f62ff3f9&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648395550359-db679185-db41-4acb-8e60-d668a708003d.png#clientId=ue10b6c59-eefb-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u211064e1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=341&originWidth=642&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=30227&status=done&style=none&taskId=ue02a812c-e9d1-495b-a216-779df7e9f5f&title="],"content":"<h2 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h2><p>定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</p>\n<h2 id=\"2、模式中的角色\"><a href=\"#2、模式中的角色\" class=\"headerlink\" title=\"2、模式中的角色\"></a>2、模式中的角色</h2><p>抽象模板类（AbstractTemplate）：实现了模板方法，定义了算法的骨架。<br>具体模板类（ConcreteTemplate)：实现抽象类中的抽象方法，已完成完整的算法。</p>\n<h2 id=\"3、模式解读\"><a href=\"#3、模式解读\" class=\"headerlink\" title=\"3、模式解读\"></a>3、模式解读</h2><p>模板方式模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395550490-8058e515-fe25-457f-9654-69c2d8e3fbe9.png#clientId=ue10b6c59-eefb-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucc44435c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=489&originWidth=778&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=73747&status=done&style=none&taskId=u00e60f97-cfd3-4616-abb2-617f62ff3f9&title=\" alt=\"image.png\"><br>模板方法中的方法可以分为两大类：模板方法和基本方法。<br>模板方法，一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。<br>基本方法，又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。<br>抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在 Java 语言里抽象方法以 abstract 关键字标示。<br>具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。<br>钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。<br>抽象模板角色类，abstractMethod()、hookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由 templateMethod()方法代表。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractTemplate &#123;\n    &#x2F;**\n     * 模板方法\n     *&#x2F;\n    public void templateMethod()&#123;\n        &#x2F;&#x2F;调用基本方法\n        abstractMethod();\n        hookMethod();\n        concreteMethod();\n    &#125;\n    &#x2F;**\n     * 基本方法的声明（由子类实现）\n     *&#x2F;\n    protected abstract void abstractMethod();\n    &#x2F;**\n     * 基本方法(空方法)\n     *&#x2F;\n    protected void hookMethod()&#123;&#125;\n    &#x2F;**\n     * 基本方法（已经实现）\n     *&#x2F;\n    private final void concreteMethod()&#123;\n        &#x2F;&#x2F;业务相关的代码\n    &#125;\n&#125;</code></pre>\n\n<p>具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而 hookMethod()方法是可选择实现的逻辑，不是必须实现的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ConcreteTemplate extends AbstractTemplate&#123;\n    &#x2F;&#x2F;基本方法的实现\n    @Override\n    public void abstractMethod() &#123;\n        &#x2F;&#x2F;业务相关的代码\n    &#125;\n    &#x2F;&#x2F;重写父类的方法\n    @Override\n    public void hookMethod() &#123;\n        &#x2F;&#x2F;业务相关的代码\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的例子中，AbstractTemplate 是一个抽象类，它带有三个方法。其中 abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。默认钩子方法，一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。显然，这种默认钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认的空实现，从而使得缺省适配类的子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。</p>\n<h2 id=\"4、JDK-涉及到的设计模式\"><a href=\"#4、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"4、JDK 涉及到的设计模式\"></a>4、JDK 涉及到的设计模式</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395550359-db679185-db41-4acb-8e60-d668a708003d.png#clientId=ue10b6c59-eefb-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u211064e1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=341&originWidth=642&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=30227&status=done&style=none&taskId=ue02a812c-e9d1-495b-a216-779df7e9f5f&title=\" alt=\"image.png\"><br>ThreadPoolExecutor 中在模板方法中 runWorker 中提供基本方法 beforeExecute 和 afterExecute 供子类实现。</p>\n<h2 id=\"5、模式总结\"><a href=\"#5、模式总结\" class=\"headerlink\" title=\"5、模式总结\"></a>5、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。<br>子类实现算法的某些细节，有助于算法的扩展。<br>通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>在某些类的算法中，用了相同的方法，造成代码的重复。<br>控制子类扩展，子类必须遵守算法规则。</p>\n","more":"<h2 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h2><p>定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</p>\n<h2 id=\"2、模式中的角色\"><a href=\"#2、模式中的角色\" class=\"headerlink\" title=\"2、模式中的角色\"></a>2、模式中的角色</h2><p>抽象模板类（AbstractTemplate）：实现了模板方法，定义了算法的骨架。<br>具体模板类（ConcreteTemplate)：实现抽象类中的抽象方法，已完成完整的算法。</p>\n<h2 id=\"3、模式解读\"><a href=\"#3、模式解读\" class=\"headerlink\" title=\"3、模式解读\"></a>3、模式解读</h2><p>模板方式模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395550490-8058e515-fe25-457f-9654-69c2d8e3fbe9.png#clientId=ue10b6c59-eefb-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucc44435c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=489&originWidth=778&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=73747&status=done&style=none&taskId=u00e60f97-cfd3-4616-abb2-617f62ff3f9&title=\" alt=\"image.png\"><br>模板方法中的方法可以分为两大类：模板方法和基本方法。<br>模板方法，一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。<br>基本方法，又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。<br>抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在 Java 语言里抽象方法以 abstract 关键字标示。<br>具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。<br>钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。<br>抽象模板角色类，abstractMethod()、hookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由 templateMethod()方法代表。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractTemplate &#123;\n    &#x2F;**\n     * 模板方法\n     *&#x2F;\n    public void templateMethod()&#123;\n        &#x2F;&#x2F;调用基本方法\n        abstractMethod();\n        hookMethod();\n        concreteMethod();\n    &#125;\n    &#x2F;**\n     * 基本方法的声明（由子类实现）\n     *&#x2F;\n    protected abstract void abstractMethod();\n    &#x2F;**\n     * 基本方法(空方法)\n     *&#x2F;\n    protected void hookMethod()&#123;&#125;\n    &#x2F;**\n     * 基本方法（已经实现）\n     *&#x2F;\n    private final void concreteMethod()&#123;\n        &#x2F;&#x2F;业务相关的代码\n    &#125;\n&#125;</code></pre>\n\n<p>具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而 hookMethod()方法是可选择实现的逻辑，不是必须实现的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ConcreteTemplate extends AbstractTemplate&#123;\n    &#x2F;&#x2F;基本方法的实现\n    @Override\n    public void abstractMethod() &#123;\n        &#x2F;&#x2F;业务相关的代码\n    &#125;\n    &#x2F;&#x2F;重写父类的方法\n    @Override\n    public void hookMethod() &#123;\n        &#x2F;&#x2F;业务相关的代码\n    &#125;\n&#125;</code></pre>\n\n<p>在上面的例子中，AbstractTemplate 是一个抽象类，它带有三个方法。其中 abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。默认钩子方法，一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。显然，这种默认钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认的空实现，从而使得缺省适配类的子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。</p>\n<h2 id=\"4、JDK-涉及到的设计模式\"><a href=\"#4、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"4、JDK 涉及到的设计模式\"></a>4、JDK 涉及到的设计模式</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395550359-db679185-db41-4acb-8e60-d668a708003d.png#clientId=ue10b6c59-eefb-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u211064e1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=341&originWidth=642&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=30227&status=done&style=none&taskId=ue02a812c-e9d1-495b-a216-779df7e9f5f&title=\" alt=\"image.png\"><br>ThreadPoolExecutor 中在模板方法中 runWorker 中提供基本方法 beforeExecute 和 afterExecute 供子类实现。</p>\n<h2 id=\"5、模式总结\"><a href=\"#5、模式总结\" class=\"headerlink\" title=\"5、模式总结\"></a>5、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。<br>子类实现算法的某些细节，有助于算法的扩展。<br>通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>在某些类的算法中，用了相同的方法，造成代码的重复。<br>控制子类扩展，子类必须遵守算法规则。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}