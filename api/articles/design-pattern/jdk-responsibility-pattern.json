{"title":"JDK设计模式（十六）责任链模式","slug":"yuque/JDK设计模式（十六）责任链模式","date":"2015-11-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-responsibility-pattern.json","excerpt":"1、概述责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。2、解决的问题如果有多个对象都有可能接受请求，可以避免请求发送者与接收者耦合在一起。3、模式中的角色1、抽象处理者角色(Handler):定义一个处理请求的接口，和一个后继连接(可选)2、具体处理者角色(ConcreteHandler):处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。3、客户类(Client):向一个链上的具体处理者ConcreteHandler对象提","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648395971572-0bdf5afa-a5dd-4ea0-8366-f3e5f908a066.png#clientId=u45c09cd2-d39b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u36a52fdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=461&originWidth=700&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=47357&status=done&style=none&taskId=ub6ca0213-5d64-4293-99bb-e19d86e5139&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648395971561-e0775992-1222-4769-8af9-357c985a9c50.png#clientId=u45c09cd2-d39b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uef5a2e51&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=952&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=38194&status=done&style=none&taskId=u259428cf-71af-4b3e-9b3e-8201c79cc03&title="],"content":"<h2 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h2><p>责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>如果有多个对象都有可能接受请求，可以避免请求发送者与接收者耦合在一起。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>1、抽象处理者角色(Handler): 定义一个处理请求的接口，和一个后继连接(可选)<br>2、具体处理者角色(ConcreteHandler): 处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。<br>3、客户类(Client): 向一个链上的具体处理者 ConcreteHandler 对象提交请求。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>责任链模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395971572-0bdf5afa-a5dd-4ea0-8366-f3e5f908a066.png#clientId=u45c09cd2-d39b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u36a52fdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=461&originWidth=700&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=47357&status=done&style=none&taskId=ub6ca0213-5d64-4293-99bb-e19d86e5139&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 中体现 ava.util.logging.Logger 会将 log 委托给 parent 的 logger 和 ClassLoader 的委托模型<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395971561-e0775992-1222-4769-8af9-357c985a9c50.png#clientId=u45c09cd2-d39b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uef5a2e51&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=952&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=38194&status=done&style=none&taskId=u259428cf-71af-4b3e-9b3e-8201c79cc03&title=\" alt=\"image.png\"></p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、降低耦合度，该模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道该请求会被“正确”地处理。接收者和发送者都没有对方的明确的信息，且链中的对象不需知道链的结构。<br>2、职责链可简化对象的相互连接，仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。<br>3、增强了给对象指派职责的灵活性，当在对象中分派职责时，职责链给你更多的灵活性。你可以通过在运行时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。你可以将这种机制与静态的特例化处理对象的继承机制结合起来使用。<br>4、增加新的请求处理类很方便</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理。<br>2、系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。<br>2、你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。<br>3、可动态指定一组对象处理请求。</p>\n","more":"<h2 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h2><p>责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>如果有多个对象都有可能接受请求，可以避免请求发送者与接收者耦合在一起。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>1、抽象处理者角色(Handler): 定义一个处理请求的接口，和一个后继连接(可选)<br>2、具体处理者角色(ConcreteHandler): 处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。<br>3、客户类(Client): 向一个链上的具体处理者 ConcreteHandler 对象提交请求。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>责任链模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395971572-0bdf5afa-a5dd-4ea0-8366-f3e5f908a066.png#clientId=u45c09cd2-d39b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u36a52fdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=461&originWidth=700&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=47357&status=done&style=none&taskId=ub6ca0213-5d64-4293-99bb-e19d86e5139&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 中体现 ava.util.logging.Logger 会将 log 委托给 parent 的 logger 和 ClassLoader 的委托模型<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395971561-e0775992-1222-4769-8af9-357c985a9c50.png#clientId=u45c09cd2-d39b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uef5a2e51&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=952&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=38194&status=done&style=none&taskId=u259428cf-71af-4b3e-9b3e-8201c79cc03&title=\" alt=\"image.png\"></p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、降低耦合度，该模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道该请求会被“正确”地处理。接收者和发送者都没有对方的明确的信息，且链中的对象不需知道链的结构。<br>2、职责链可简化对象的相互连接，仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。<br>3、增强了给对象指派职责的灵活性，当在对象中分派职责时，职责链给你更多的灵活性。你可以通过在运行时刻对该链进行动态的增加或修改来增加或改变处理一个请求的那些职责。你可以将这种机制与静态的特例化处理对象的继承机制结合起来使用。<br>4、增加新的请求处理类很方便</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理。<br>2、系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。<br>2、你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。<br>3、可动态指定一组对象处理请求。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}