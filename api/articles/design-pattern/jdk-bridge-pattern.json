{"title":"JDK设计模式（六）桥接模式","slug":"yuque/JDK设计模式（六）桥接模式","date":"2015-04-12T01:00:00.000Z","updated":"2022-05-15T04:19:28.493Z","comments":true,"path":"api/articles/design-pattern/jdk-bridge-pattern.json","excerpt":"1、定义将抽象部分与实现部分分离，使它们都可以独立的变化2、解决的问题某个类具有两个或两个以上的维度变化，如果只是用继承将无法实现这种需要，或者使得设计变得相当臃肿，把变化部分抽象出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要，从达到抽象化、实现化和脱耦。3、模式中的角色1、抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。2、修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。3、实现化(Imple","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648394568658-023fec66-64dd-40b0-a92d-465abcdeb612.png#clientId=u4e992676-b736-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0a35916d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=276&originWidth=671&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=24309&status=done&style=none&taskId=u7766f2c5-8a49-443b-896f-439f0dd0ba1&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648394568695-03ac0b72-df9d-4086-9ba4-3b1abcf8e828.png#clientId=u4e992676-b736-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud0e38123&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=947&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=39579&status=done&style=none&taskId=u058aea6c-7c2b-443f-802d-153506e4e43&title="],"content":"<h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><p>将抽象部分与实现部分分离，使它们都可以独立的变化</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>某个类具有两个或两个以上的维度变化，如果只是用继承将无法实现这种需要，或者使得设计变得相当臃肿，把变化部分抽象出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要，从达到抽象化、实现化和脱耦。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>1、抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。<br>2、修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。<br>3、实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。<br>4、具体实现化(ConcreteImplementor)角色：这个角色给出实现化角色接口的具体实现。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>通过对象组合的方式，Bridge 模式把两个角色之间的继承关系改为了耦合的关系，从而使这两者可以从容自若的各自独立的变化。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394568658-023fec66-64dd-40b0-a92d-465abcdeb612.png#clientId=u4e992676-b736-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0a35916d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=276&originWidth=671&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=24309&status=done&style=none&taskId=u7766f2c5-8a49-443b-896f-439f0dd0ba1&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 中的 java.util.logging 包中的 Handler 和 Formatter，Handler 是一个抽象类，需要根据实际情况创建真正使用的具体 Handler（如 ConsoleHandler、FileHandler 等），实现各自的 publish、flush 以及 close 等方法,负责从 Logger 中取出日志消息并将消息发送出去，比如发送到控制台、文件、网络上的其他日志服务或操作系统日志等。Handler 一个 Handler 具有使用定义好的各种日志级别、自己的过滤器（Filter）、格式化器（Formatter）、错误管理器（ErrorManager）以及编码字符集等。其中 Formatter 也是一个抽象类，可以使用（XMLFormatter，SimpleFormatter）来格式输出日志信息。将 Handler 和 Formatter 通过桥接，将抽象和实现分开。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394568695-03ac0b72-df9d-4086-9ba4-3b1abcf8e828.png#clientId=u4e992676-b736-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud0e38123&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=947&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=39579&status=done&style=none&taskId=u058aea6c-7c2b-443f-802d-153506e4e43&title=\" alt=\"image.png\"></p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><p>桥接模式则把原来的基类的实现化细节抽象出来，在构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度上的独立变化，它很好的符合了开放-封闭原则和优先使用对象，而不是继承这两个面向对象原则。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、分离抽象接口及其实现部分。<br>2、桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。<br>3、桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。<br>4、 实现细节对客户透明，可以对用户隐藏实现细节。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。<br>2、 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。<br>2、抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。<br>3、 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。<br>4、虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。<br>5、 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</p>\n","more":"<h2 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h2><p>将抽象部分与实现部分分离，使它们都可以独立的变化</p>\n<h2 id=\"2、解决的问题\"><a href=\"#2、解决的问题\" class=\"headerlink\" title=\"2、解决的问题\"></a>2、解决的问题</h2><p>某个类具有两个或两个以上的维度变化，如果只是用继承将无法实现这种需要，或者使得设计变得相当臃肿，把变化部分抽象出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要，从达到抽象化、实现化和脱耦。</p>\n<h2 id=\"3、模式中的角色\"><a href=\"#3、模式中的角色\" class=\"headerlink\" title=\"3、模式中的角色\"></a>3、模式中的角色</h2><p>1、抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。<br>2、修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。<br>3、实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。<br>4、具体实现化(ConcreteImplementor)角色：这个角色给出实现化角色接口的具体实现。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>通过对象组合的方式，Bridge 模式把两个角色之间的继承关系改为了耦合的关系，从而使这两者可以从容自若的各自独立的变化。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394568658-023fec66-64dd-40b0-a92d-465abcdeb612.png#clientId=u4e992676-b736-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0a35916d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=276&originWidth=671&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=24309&status=done&style=none&taskId=u7766f2c5-8a49-443b-896f-439f0dd0ba1&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 中的 java.util.logging 包中的 Handler 和 Formatter，Handler 是一个抽象类，需要根据实际情况创建真正使用的具体 Handler（如 ConsoleHandler、FileHandler 等），实现各自的 publish、flush 以及 close 等方法,负责从 Logger 中取出日志消息并将消息发送出去，比如发送到控制台、文件、网络上的其他日志服务或操作系统日志等。Handler 一个 Handler 具有使用定义好的各种日志级别、自己的过滤器（Filter）、格式化器（Formatter）、错误管理器（ErrorManager）以及编码字符集等。其中 Formatter 也是一个抽象类，可以使用（XMLFormatter，SimpleFormatter）来格式输出日志信息。将 Handler 和 Formatter 通过桥接，将抽象和实现分开。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648394568695-03ac0b72-df9d-4086-9ba4-3b1abcf8e828.png#clientId=u4e992676-b736-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud0e38123&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=947&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=39579&status=done&style=none&taskId=u058aea6c-7c2b-443f-802d-153506e4e43&title=\" alt=\"image.png\"></p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><p>桥接模式则把原来的基类的实现化细节抽象出来，在构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度上的独立变化，它很好的符合了开放-封闭原则和优先使用对象，而不是继承这两个面向对象原则。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、分离抽象接口及其实现部分。<br>2、桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。<br>3、桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。<br>4、 实现细节对客户透明，可以对用户隐藏实现细节。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。<br>2、 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。<br>2、抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。<br>3、 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。<br>4、虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。<br>5、 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}