{"title":"JDK设计模式（三）建造者模式","slug":"yuque/JDK设计模式（三）建造者模式","date":"2015-01-19T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-builder-pattern.json","excerpt":"将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心，其类图如下。建造者角色Product :产品类，由多个部件构成。class Product {    List parts = new ArrayList();    public void AddPart(String part) {        parts.add(part);    }    public void sho","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648312892476-cba9f8b3-8fa5-4ac7-a707-c0f2fd798ccb.png#clientId=uf68f83de-da72-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u851a440b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=782&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=22011&status=done&style=none&taskId=u5951e2c5-4c3f-4a6f-aa74-74b51f9198e&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648312892556-a165f083-1405-44fe-a04c-1d4c97a408a6.png#clientId=uf68f83de-da72-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub7ef1453&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=1025&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=46326&status=done&style=none&taskId=u1a3c07a8-89d6-489c-ac04-db27cf7404a&title="],"content":"<p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br>建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心，其类图如下。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312892476-cba9f8b3-8fa5-4ac7-a707-c0f2fd798ccb.png#clientId=uf68f83de-da72-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u851a440b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=782&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=22011&status=done&style=none&taskId=u5951e2c5-4c3f-4a6f-aa74-74b51f9198e&title=\" alt=\"image.png\"></p>\n<h2 id=\"建造者角色\"><a href=\"#建造者角色\" class=\"headerlink\" title=\"建造者角色\"></a>建造者角色</h2><p>Product : 产品类，由多个部件构成。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Product &#123;\n    List&lt;String&gt; parts &#x3D; new ArrayList&lt;String&gt;();\n\n    public void AddPart(String part) &#123;\n        parts.add(part);\n    &#125;\n\n    public void show() &#123;\n        for (String part : parts) &#123;\n            System.out.println(part);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>Builder : 抽象建造者，确定产品由 AB 部件构成，并声明一个得到产品建造后结果的方法 getResult。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">interface Builder &#123;\n    public void buildPartA();\n    public void buildPartB();\n    public Product getResult();\n&#125;</code></pre>\n\n<p>ConcreteBuilder : 实现 Builder 接口中的具体方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class ConcreteBuilder implements Builder &#123;\n    private Product product &#x3D; new Product();\n\n    public void buildPartA() &#123;\n        product.AddPart(&quot;part A&quot;);\n    &#125;\n\n    public void buildPartB() &#123;\n        product.AddPart(&quot;part B&quot;);\n    &#125;\n\n    public Product getResult() &#123;\n        return product;\n    &#125;\n&#125;</code></pre>\n\n<p>Director : 指挥者类，指挥建造 Product 的过程（控制构建各部分组件的顺序）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Director &#123;\n    public void construct(Builder builder) &#123;\n        builder.buildPartA();\n        builder.buildPartB();\n    &#125;\n&#125;</code></pre>\n\n<p>Client : 用户并不需要知道具体的建造过程，只需指定建造 Product 具体类型。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BuilderPattern &#123;\n    public static void main(String[] args) &#123;\n        Director director &#x3D; new Director();\n        Builder builder &#x3D; new ConcreteBuilder();\n\n        director.construct(builder);\n        Product product &#x3D; builder.getResult();\n        product.show();\n    &#125;\n&#125;</code></pre>\n\n<p>与抽象工厂的区别：在建造者模式里，有个指导者，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的建造过程。</p>\n<h2 id=\"JDK-中使用的建造者模式\"><a href=\"#JDK-中使用的建造者模式\" class=\"headerlink\" title=\"JDK 中使用的建造者模式\"></a>JDK 中使用的建造者模式</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312892556-a165f083-1405-44fe-a04c-1d4c97a408a6.png#clientId=uf68f83de-da72-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub7ef1453&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=1025&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=46326&status=done&style=none&taskId=u1a3c07a8-89d6-489c-ac04-db27cf7404a&title=\" alt=\"image.png\"><br>DOMParser 使用 parse 方法建造 Document 对象，使用 getDocument 获取 XML 的 Document 对象。</p>\n<h3 id=\"建造者模式的优点\"><a href=\"#建造者模式的优点\" class=\"headerlink\" title=\"建造者模式的优点\"></a>建造者模式的优点</h3><p>1、建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。<br>2、建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。</p>\n<h3 id=\"建造者模式与工厂模式的区别\"><a href=\"#建造者模式与工厂模式的区别\" class=\"headerlink\" title=\"建造者模式与工厂模式的区别\"></a>建造者模式与工厂模式的区别</h3><p>1、建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。<br>2、与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>建造者模式与工厂模式类似，适用的场景也很相似。一般来说，如果产品的建造很复杂，那么请用工厂模式；如果产品的建造更复杂，那么请用建造者模式。</p>\n","more":"<p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br>建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心，其类图如下。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312892476-cba9f8b3-8fa5-4ac7-a707-c0f2fd798ccb.png#clientId=uf68f83de-da72-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u851a440b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=782&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=22011&status=done&style=none&taskId=u5951e2c5-4c3f-4a6f-aa74-74b51f9198e&title=\" alt=\"image.png\"></p>\n<h2 id=\"建造者角色\"><a href=\"#建造者角色\" class=\"headerlink\" title=\"建造者角色\"></a>建造者角色</h2><p>Product : 产品类，由多个部件构成。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Product &#123;\n    List&lt;String&gt; parts &#x3D; new ArrayList&lt;String&gt;();\n\n    public void AddPart(String part) &#123;\n        parts.add(part);\n    &#125;\n\n    public void show() &#123;\n        for (String part : parts) &#123;\n            System.out.println(part);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>Builder : 抽象建造者，确定产品由 AB 部件构成，并声明一个得到产品建造后结果的方法 getResult。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">interface Builder &#123;\n    public void buildPartA();\n    public void buildPartB();\n    public Product getResult();\n&#125;</code></pre>\n\n<p>ConcreteBuilder : 实现 Builder 接口中的具体方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class ConcreteBuilder implements Builder &#123;\n    private Product product &#x3D; new Product();\n\n    public void buildPartA() &#123;\n        product.AddPart(&quot;part A&quot;);\n    &#125;\n\n    public void buildPartB() &#123;\n        product.AddPart(&quot;part B&quot;);\n    &#125;\n\n    public Product getResult() &#123;\n        return product;\n    &#125;\n&#125;</code></pre>\n\n<p>Director : 指挥者类，指挥建造 Product 的过程（控制构建各部分组件的顺序）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Director &#123;\n    public void construct(Builder builder) &#123;\n        builder.buildPartA();\n        builder.buildPartB();\n    &#125;\n&#125;</code></pre>\n\n<p>Client : 用户并不需要知道具体的建造过程，只需指定建造 Product 具体类型。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BuilderPattern &#123;\n    public static void main(String[] args) &#123;\n        Director director &#x3D; new Director();\n        Builder builder &#x3D; new ConcreteBuilder();\n\n        director.construct(builder);\n        Product product &#x3D; builder.getResult();\n        product.show();\n    &#125;\n&#125;</code></pre>\n\n<p>与抽象工厂的区别：在建造者模式里，有个指导者，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的建造过程。</p>\n<h2 id=\"JDK-中使用的建造者模式\"><a href=\"#JDK-中使用的建造者模式\" class=\"headerlink\" title=\"JDK 中使用的建造者模式\"></a>JDK 中使用的建造者模式</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648312892556-a165f083-1405-44fe-a04c-1d4c97a408a6.png#clientId=uf68f83de-da72-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub7ef1453&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=1025&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=46326&status=done&style=none&taskId=u1a3c07a8-89d6-489c-ac04-db27cf7404a&title=\" alt=\"image.png\"><br>DOMParser 使用 parse 方法建造 Document 对象，使用 getDocument 获取 XML 的 Document 对象。</p>\n<h3 id=\"建造者模式的优点\"><a href=\"#建造者模式的优点\" class=\"headerlink\" title=\"建造者模式的优点\"></a>建造者模式的优点</h3><p>1、建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。<br>2、建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。</p>\n<h3 id=\"建造者模式与工厂模式的区别\"><a href=\"#建造者模式与工厂模式的区别\" class=\"headerlink\" title=\"建造者模式与工厂模式的区别\"></a>建造者模式与工厂模式的区别</h3><p>1、建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。<br>2、与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>建造者模式与工厂模式类似，适用的场景也很相似。一般来说，如果产品的建造很复杂，那么请用工厂模式；如果产品的建造更复杂，那么请用建造者模式。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}