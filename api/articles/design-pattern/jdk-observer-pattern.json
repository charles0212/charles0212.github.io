{"title":"JDK设计模式（十四）观察者模式","slug":"yuque/JDK设计模式（十四）观察者模式","date":"2015-11-06T16:00:00.000Z","updated":"2022-05-15T04:19:28.492Z","comments":true,"path":"api/articles/design-pattern/jdk-observer-pattern.json","excerpt":"1. 概述有时被称作发布/订阅模式，观察者模式定义了对象之间的一对多的依赖关系，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。2. 解决的问题将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。3. 模式中的角色1、抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。2、具体主题（ConcreteS","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648395691496-3449d8d6-1e6c-4098-a65d-750b465b9e79.png#clientId=u97477a4e-217a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u42be28d6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=532&originWidth=886&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=102362&status=done&style=none&taskId=u9a6c5a4f-4fd9-482a-9147-c59b63aa5e0&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648395691319-24bf7a01-959e-4e48-afe9-55dadc9e8ba2.png#clientId=u97477a4e-217a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5c20bcc9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=287&originWidth=618&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=21535&status=done&style=none&taskId=u43d3f0dc-ad40-47a3-a497-5877930d97f&title="],"content":"<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p>有时被称作发布&#x2F;订阅模式，观察者模式定义了对象之间的一对多的依赖关系，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。</p>\n<h2 id=\"2-解决的问题\"><a href=\"#2-解决的问题\" class=\"headerlink\" title=\"2. 解决的问题\"></a>2. 解决的问题</h2><p>将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。</p>\n<h2 id=\"3-模式中的角色\"><a href=\"#3-模式中的角色\" class=\"headerlink\" title=\"3. 模式中的角色\"></a>3. 模式中的角色</h2><p>1、抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。<br>2、具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。<br>3、抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。<br>4、具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>模板方式模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395691496-3449d8d6-1e6c-4098-a65d-750b465b9e79.png#clientId=u97477a4e-217a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u42be28d6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=532&originWidth=886&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=102362&status=done&style=none&taskId=u9a6c5a4f-4fd9-482a-9147-c59b63aa5e0&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 中体现 java.util.Observer 和 Observable<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395691319-24bf7a01-959e-4e48-afe9-55dadc9e8ba2.png#clientId=u97477a4e-217a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5c20bcc9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=287&originWidth=618&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=21535&status=done&style=none&taskId=u43d3f0dc-ad40-47a3-a497-5877930d97f&title=\" alt=\"image.png\"></p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。<br>2、 一个抽象某型有两个方面，当其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p>\n","more":"<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><p>有时被称作发布&#x2F;订阅模式，观察者模式定义了对象之间的一对多的依赖关系，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。</p>\n<h2 id=\"2-解决的问题\"><a href=\"#2-解决的问题\" class=\"headerlink\" title=\"2. 解决的问题\"></a>2. 解决的问题</h2><p>将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。</p>\n<h2 id=\"3-模式中的角色\"><a href=\"#3-模式中的角色\" class=\"headerlink\" title=\"3. 模式中的角色\"></a>3. 模式中的角色</h2><p>1、抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。<br>2、具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。<br>3、抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。<br>4、具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</p>\n<h2 id=\"4、模式解读\"><a href=\"#4、模式解读\" class=\"headerlink\" title=\"4、模式解读\"></a>4、模式解读</h2><p>模板方式模式的类图如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395691496-3449d8d6-1e6c-4098-a65d-750b465b9e79.png#clientId=u97477a4e-217a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u42be28d6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=532&originWidth=886&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=102362&status=done&style=none&taskId=u9a6c5a4f-4fd9-482a-9147-c59b63aa5e0&title=\" alt=\"image.png\"></p>\n<h2 id=\"5、JDK-涉及到的设计模式\"><a href=\"#5、JDK-涉及到的设计模式\" class=\"headerlink\" title=\"5、JDK 涉及到的设计模式\"></a>5、JDK 涉及到的设计模式</h2><p>JDK 中体现 java.util.Observer 和 Observable<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648395691319-24bf7a01-959e-4e48-afe9-55dadc9e8ba2.png#clientId=u97477a4e-217a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5c20bcc9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=287&originWidth=618&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=21535&status=done&style=none&taskId=u43d3f0dc-ad40-47a3-a497-5877930d97f&title=\" alt=\"image.png\"></p>\n<h2 id=\"6、模式总结\"><a href=\"#6、模式总结\" class=\"headerlink\" title=\"6、模式总结\"></a>6、模式总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1、观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1、依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。</p>\n<h3 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h3><p>1、当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。<br>2、 一个抽象某型有两个方面，当其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p>\n","categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}