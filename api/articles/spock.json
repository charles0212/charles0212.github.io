{"title":"Spock 基于BDD测试","slug":"yuque/Spock 基于BDD测试","date":"2018-07-14T16:00:00.000Z","updated":"2022-09-09T13:07:16.842Z","comments":true,"path":"api/articles/spock.json","excerpt":"> Spock 测试框架基于 Groovy> 并吸收了> Junit、TestNG、Mockito> 等测试框架的优点。 Spock> 编写的单元测试层次清晰，代码量少，可读性好，Groovy> 最终会编译为 class> 文件，支持各种集成开发环境（eclipse，Intellij> Ieda）， 尤其是 Intellij> idea 已经集成支持 Groovy> 的插件，也支持> maven-surefire-plugin、jacoco> 等 maven 插件。Spock 官网，必读书籍《JavaTesting with Spock》,如要速成只需要阅读以下","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1649583018000-a421eec4-e140-4dc7-b441-18d73fd6dee8.png#clientId=u8bb98b5c-a46d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua18a10b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=694&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=33048&status=done&style=none&taskId=u04c672d8-be2e-4f25-909f-4cd0c0965e0&title="],"content":"<blockquote>\n<p>Spock 测试框架基于 Groovy 并吸收了 Junit、TestNG、Mockito 等测试框架的优点。 Spock 编写的单元测试层次清晰，代码量少，可读性好，Groovy 最终会编译为 class 文件，支持各种集成开发环境（eclipse，Intellij Ieda）， 尤其是 Intellij idea 已经集成支持 Groovy 的插件，也支持 maven-surefire-plugin、jacoco 等 maven 插件。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649583018000-a421eec4-e140-4dc7-b441-18d73fd6dee8.png#clientId=u8bb98b5c-a46d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua18a10b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=694&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=33048&status=done&style=none&taskId=u04c672d8-be2e-4f25-909f-4cd0c0965e0&title=\" alt=\"image.png\"><br><a href=\"http://spockframework.org/\">Spock 官网</a>，必读书籍《Java Testing with Spock》, 如要速成只需要阅读以下两篇文章</p>\n<ul>\n<li><a href=\"https://learnxinyminutes.com/docs/groovy/\">5 分钟入门 Groovy</a></li>\n<li><a href=\"https://semaphoreci.com/community/tutorials/stubbing-and-mocking-in-java-with-the-spock-testing-framework\">一篇非常详尽的介绍 Spock 的英文教程</a></li>\n</ul>\n<h2 id=\"Spock-实例\"><a href=\"#Spock-实例\" class=\"headerlink\" title=\"Spock 实例\"></a>Spock 实例</h2><p>大多数遵循 TDD 的 Java 开发者均会使用 mockito 或 powermock，但 mockito 和 powermock 均包含了许多样本代码，导致测试代码变得冗长而难以维护。 在测试中引入 Groovy&#x2F;Spock 后，我完全被它们吸引，并转向使用 Groovy&#x2F;Spock 来替代原有的测试框架。</p>\n<h3 id=\"定义-Domain，DAO，Service\"><a href=\"#定义-Domain，DAO，Service\" class=\"headerlink\" title=\"定义 Domain，DAO，Service\"></a>定义 Domain，DAO，Service</h3><p>下面将围绕一个简单例子来讲解 Groovy&#x2F;Spock，例子中将包含一个 service 类，负责处理 domain 对象，以及一个数据访问层。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User &#123;\n    private int id;\n    private String name;\n    private int age;\n    &#x2F;&#x2F; Accessors omitted\n&#125;\n\npublic interface UserDao &#123;\n    public User get(int id);\n&#125;\n\npublic class UserService &#123;\n    private UserDao userDao;\n\n    public UserService(UserDao userDao) &#123;\n        this.userDao &#x3D; userDao;\n    &#125;\n\n    public User findUser(int id)&#123;\n        return userDao.get(id);;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"采用-Groovy-x2F-Spock-针对-UserService-编写测试\"><a href=\"#采用-Groovy-x2F-Spock-针对-UserService-编写测试\" class=\"headerlink\" title=\"采用 Groovy&#x2F;Spock 针对 UserService 编写测试\"></a>采用 Groovy&#x2F;Spock 针对 UserService 编写测试</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class UserTest extends Specification &#123;\n    UserDao dao &#x3D; Mock(UserDao)\n    UserService service &#x3D; new UserService(dao)\n\n    def &quot;it gets a user by id&quot;() &#123;\n        given:\n        1 * dao.get(id) &gt;&gt; new User(id: id, name: name, age: age)\n\n        when:\n        def result &#x3D; service.findUser(id)\n\n        then:\n        result.id &#x3D;&#x3D; userId\n        result.name &#x3D;&#x3D; userName\n        result.age &#x3D;&#x3D; userAge\n\n        where:\n        id | name      | age || userId | userName  | userAge\n        1  | &quot;zhang&quot;   | 18  || 1      | &quot;zhang&quot;   | 18\n        2  | &quot;charles&quot; | 28  || 2      | &quot;charles&quot; | 28\n    &#125;\n&#125;</code></pre>\n\n<p>在 Spock 中创建 mock 对象非常容易，只需要使用 Mock(Class)这样的语句即可。如上所述，mock 后的 DAO 对象被传入 userService 中。 Setup 方法会在每个测试方法运行前被执行。<br>Spock 是一个 BDD 测试框架，因此对于 Spock 中涉及的 given，when，then 样式最简单的理解就是：</p>\n<ul>\n<li>given 给定一些条件</li>\n<li>when 当执行一些操作时</li>\n<li>then 期望得到某个结果</li>\n<li>where 多套测试数据的检测和验证<table><thead><tr>\n<th><strong>分块</strong></th>\n<th><strong>替换</strong></th>\n<th><strong>功能</strong></th>\n<th><strong>限制</strong></th>\n</tr>\n</thead><tbody><tr>\n<td>given</td>\n<td>setup</td>\n<td>初始化函数，mock</td>\n<td>非必要</td>\n</tr>\n<tr>\n<td>when</td>\n<td>expect</td>\n<td>执行待测试的函数</td>\n<td>when 和 then 必须对成出现</td>\n</tr>\n<tr>\n<td>then</td>\n<td>expect</td>\n<td>验证函数结果</td>\n<td>when 和 then 可以被 expect 替换</td>\n</tr>\n<tr>\n<td>where</td>\n<td></td>\n<td>多套测试数据的检测</td>\n<td>spock 的特性功能</td>\n</tr>\n<tr>\n<td>and</td>\n<td></td>\n<td>对其余块进行分隔说明</td>\n<td>非必要</td>\n</tr>\n</tbody></table></li>\n</ul>\n<p>如上述测试方法中 Given，给定 id&#x3D;1，即测试的变量；而在 When 中则是被测试方法，如在上述代码中调用 findUser()； Then 中则是断言，即检查被测试方法的输出结果。<br>上述 Then 中的第一句语句虽然看上去可怕，但实际上却非常容易理解：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">1 * dao.get(id) &gt;&gt; new User(id:id, name:&quot;James&quot;, age:27)</code></pre>\n\n<p>该行表示了对于 mock 对象 dao 的期望值，即期望调用 dao.get()方法 1 次，而“&gt;&gt;”是 spock 的特色，表示“then return”含义。 因此该句翻译过来的意思是：期望调用 1 次 dao.get()方法，当执行该方法后，请返回一个新的 User 对象。 此外在构造方法中使用具名参数也是 groovy 的另一特点。Then 中剩余的代码对 result 对象进行检查。<br>由此测试代码驱动产生的产品代码非常简单，如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserService &#123;\n    private UserDao userDao;\n\n    public UserService(UserDao userDao) &#123;\n        this.userDao &#x3D; userDao;\n    &#125;\n\n    public User findUser(int id)&#123;\n        return userDao.get(id);\n    &#125;\n&#125;</code></pre>\n\n<p>接下来实现创建用户功能，在 UserService 中添加如下代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void createUser(User user) &#123;\n    &#x2F;&#x2F; check name\n    &#x2F;&#x2F; if exists, throw exception\n    &#x2F;&#x2F; if !exists, create user\n&#125;</code></pre>\n\n<p>在 UserDao 中添加如下方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public User findByName(String name);\npublic void createUser(User user);</code></pre>\n\n<p>相应的测试方法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">def &quot;it saves a new user&quot;() &#123;\n    given:\n        def user &#x3D; new User(id: 1, name: &#39;James&#39;, age:27)\n\n    when:\n        service.createUser(user)\n\n    then:\n        1 * dao.findByName(user.name) &gt;&gt; null\n\n    then:\n        1 * dao.createUser(user)\n&#125;</code></pre>\n\n<p>在上述代码中出现了两处 Then，这是因为当所有断言放在一个 then 块中，Spock 会认为这些断言是同时发生的。 如果期望断言按顺序执行，则需要将断言分割到多个 then 块中，spock 会按顺序执行断言。 如上述所示，首先需要判断用户是否存在，然后再去创建用户。产品代码实现如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void createUser(User user)&#123;\n    User existing &#x3D; userDao.findByName(user.getName());\n\n    if(existing &#x3D;&#x3D; null)&#123;\n        userDao.createUser(user);\n    &#125;\n&#125;</code></pre>\n\n<p>上述代码针对用户不存在场景，而对于用户存在的场景，测试代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">def &quot;it fails to create a user because one already exists with that name&quot;() &#123;\n    given:\n        def user &#x3D; new User(id: 1, name: &#39;James&#39;, age:27)\n\n    when:\n        service.createUser(user)\n\n    then:\n        1 * dao.findByName(user.name) &gt;&gt; user\n\n    then:\n        0 * dao.createUser(user)\n\n    then:\n        def exception &#x3D; thrown(RuntimeException)\n        exception.message &#x3D;&#x3D; &quot;User with name $&#123;user.name&#125; already exists!&quot;\n&#125;</code></pre>\n\n<p>上述代码当调用 findByName 时，返回一个存在的用户，然后不调用 createUser()，第三个 Then 块捕获方法抛出的异常。 注意 groovy 拥有一个称之为 GStrings 的特征，该特征可以在引用的字符串中插入参数，如${user.name}。相应产品代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void createUser(User user)&#123;\n    User existing &#x3D; userDao.findByName(user.getName());\n\n    if(existing &#x3D;&#x3D; null)&#123;\n        userDao.createUser(user);\n    &#125; else&#123;\n        throw new RuntimeException(String.format(&quot;User with name %s already exists!&quot;, user.getName()));\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"结合-PowerMock-mock-静态方法\"><a href=\"#结合-PowerMock-mock-静态方法\" class=\"headerlink\" title=\"结合 PowerMock mock 静态方法\"></a>结合 PowerMock mock 静态方法</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RunWith(PowerMockRunner)\n@PowerMockRunnerDelegate(Sputnik)\n@PowerMockIgnore(&#123;\n        &quot;javax.net.ssl.*&quot;,\n        &quot;javax.management.*&quot;,\n        &quot;com.sun.crypto.*&quot;,\n        &quot;javax.crypto.*&quot;&#125;)\n@PrepareForTest([BizEngine.class])\nclass BaseSimpleTest extends Specification &#123;\n    def &quot;test engine&quot;() &#123;\n        setup:\n        BizEngine mockStatic &#x3D; PowerMockito.mock(BizEngine.class)\n        Whitebox.setInternalState(BizEngine.class, &quot;bizEngine&quot;, mockStatic)\n\n        when:\n        Mockito.when(mockStatic.getPoint(Point.class, null, null)).thenReturn(new LocationPoint())\n\n        then:\n        println &quot;test engine end&quot;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"其他提示\"><a href=\"#其他提示\" class=\"headerlink\" title=\"其他提示\"></a>其他提示</h2><ul>\n<li>最重要也是最容易被遗忘的提示，阅读 spock 文档</li>\n<li>可以命名 spock 块，例如将 given 命名为“Some variables”，有助于开发者在测试代码中更加清楚的表达含义</li>\n<li>当对 mock 对象方法调用次数不关心时，可以使用_ * mock.method()</li>\n<li>在 then 块中可使用下划线来通配方法及类，例如，0 _ mock._ 表示期望 mock 对象的任何方法都未被调用，或 0 _ . 表示期望任何对象的任何方法都未被调用</li>\n<li>通常按 given，when，then 编写测试，但实际上从 when 开始编写测试会更加容易发现测试需要的 given 和测试的输出结果(then)</li>\n<li>expect 块对于测试不需要对 mock 对象进行断言的简单方法更加有效</li>\n<li>当对于传递给 mock 对象的参数不关注时，可以使用通配符参数</li>\n<li>拥抱 groovy 闭包 Embrace groovy closures! They can be you’re best friend in assertions!</li>\n<li>当希望在整个测试类中只运行一次，可以复写 setupSpec 和 cleanupSpec</li>\n</ul>\n","more":"<blockquote>\n<p>Spock 测试框架基于 Groovy 并吸收了 Junit、TestNG、Mockito 等测试框架的优点。 Spock 编写的单元测试层次清晰，代码量少，可读性好，Groovy 最终会编译为 class 文件，支持各种集成开发环境（eclipse，Intellij Ieda）， 尤其是 Intellij idea 已经集成支持 Groovy 的插件，也支持 maven-surefire-plugin、jacoco 等 maven 插件。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649583018000-a421eec4-e140-4dc7-b441-18d73fd6dee8.png#clientId=u8bb98b5c-a46d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua18a10b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=694&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=33048&status=done&style=none&taskId=u04c672d8-be2e-4f25-909f-4cd0c0965e0&title=\" alt=\"image.png\"><br><a href=\"http://spockframework.org/\">Spock 官网</a>，必读书籍《Java Testing with Spock》, 如要速成只需要阅读以下两篇文章</p>\n<ul>\n<li><a href=\"https://learnxinyminutes.com/docs/groovy/\">5 分钟入门 Groovy</a></li>\n<li><a href=\"https://semaphoreci.com/community/tutorials/stubbing-and-mocking-in-java-with-the-spock-testing-framework\">一篇非常详尽的介绍 Spock 的英文教程</a></li>\n</ul>\n<h2 id=\"Spock-实例\"><a href=\"#Spock-实例\" class=\"headerlink\" title=\"Spock 实例\"></a>Spock 实例</h2><p>大多数遵循 TDD 的 Java 开发者均会使用 mockito 或 powermock，但 mockito 和 powermock 均包含了许多样本代码，导致测试代码变得冗长而难以维护。 在测试中引入 Groovy&#x2F;Spock 后，我完全被它们吸引，并转向使用 Groovy&#x2F;Spock 来替代原有的测试框架。</p>\n<h3 id=\"定义-Domain，DAO，Service\"><a href=\"#定义-Domain，DAO，Service\" class=\"headerlink\" title=\"定义 Domain，DAO，Service\"></a>定义 Domain，DAO，Service</h3><p>下面将围绕一个简单例子来讲解 Groovy&#x2F;Spock，例子中将包含一个 service 类，负责处理 domain 对象，以及一个数据访问层。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class User &#123;\n    private int id;\n    private String name;\n    private int age;\n    &#x2F;&#x2F; Accessors omitted\n&#125;\n\npublic interface UserDao &#123;\n    public User get(int id);\n&#125;\n\npublic class UserService &#123;\n    private UserDao userDao;\n\n    public UserService(UserDao userDao) &#123;\n        this.userDao &#x3D; userDao;\n    &#125;\n\n    public User findUser(int id)&#123;\n        return userDao.get(id);;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"采用-Groovy-x2F-Spock-针对-UserService-编写测试\"><a href=\"#采用-Groovy-x2F-Spock-针对-UserService-编写测试\" class=\"headerlink\" title=\"采用 Groovy&#x2F;Spock 针对 UserService 编写测试\"></a>采用 Groovy&#x2F;Spock 针对 UserService 编写测试</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class UserTest extends Specification &#123;\n    UserDao dao &#x3D; Mock(UserDao)\n    UserService service &#x3D; new UserService(dao)\n\n    def &quot;it gets a user by id&quot;() &#123;\n        given:\n        1 * dao.get(id) &gt;&gt; new User(id: id, name: name, age: age)\n\n        when:\n        def result &#x3D; service.findUser(id)\n\n        then:\n        result.id &#x3D;&#x3D; userId\n        result.name &#x3D;&#x3D; userName\n        result.age &#x3D;&#x3D; userAge\n\n        where:\n        id | name      | age || userId | userName  | userAge\n        1  | &quot;zhang&quot;   | 18  || 1      | &quot;zhang&quot;   | 18\n        2  | &quot;charles&quot; | 28  || 2      | &quot;charles&quot; | 28\n    &#125;\n&#125;</code></pre>\n\n<p>在 Spock 中创建 mock 对象非常容易，只需要使用 Mock(Class)这样的语句即可。如上所述，mock 后的 DAO 对象被传入 userService 中。 Setup 方法会在每个测试方法运行前被执行。<br>Spock 是一个 BDD 测试框架，因此对于 Spock 中涉及的 given，when，then 样式最简单的理解就是：</p>\n<ul>\n<li>given 给定一些条件</li>\n<li>when 当执行一些操作时</li>\n<li>then 期望得到某个结果</li>\n<li>where 多套测试数据的检测和验证<table><thead><tr>\n<th><strong>分块</strong></th>\n<th><strong>替换</strong></th>\n<th><strong>功能</strong></th>\n<th><strong>限制</strong></th>\n</tr>\n</thead><tbody><tr>\n<td>given</td>\n<td>setup</td>\n<td>初始化函数，mock</td>\n<td>非必要</td>\n</tr>\n<tr>\n<td>when</td>\n<td>expect</td>\n<td>执行待测试的函数</td>\n<td>when 和 then 必须对成出现</td>\n</tr>\n<tr>\n<td>then</td>\n<td>expect</td>\n<td>验证函数结果</td>\n<td>when 和 then 可以被 expect 替换</td>\n</tr>\n<tr>\n<td>where</td>\n<td></td>\n<td>多套测试数据的检测</td>\n<td>spock 的特性功能</td>\n</tr>\n<tr>\n<td>and</td>\n<td></td>\n<td>对其余块进行分隔说明</td>\n<td>非必要</td>\n</tr>\n</tbody></table></li>\n</ul>\n<p>如上述测试方法中 Given，给定 id&#x3D;1，即测试的变量；而在 When 中则是被测试方法，如在上述代码中调用 findUser()； Then 中则是断言，即检查被测试方法的输出结果。<br>上述 Then 中的第一句语句虽然看上去可怕，但实际上却非常容易理解：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">1 * dao.get(id) &gt;&gt; new User(id:id, name:&quot;James&quot;, age:27)</code></pre>\n\n<p>该行表示了对于 mock 对象 dao 的期望值，即期望调用 dao.get()方法 1 次，而“&gt;&gt;”是 spock 的特色，表示“then return”含义。 因此该句翻译过来的意思是：期望调用 1 次 dao.get()方法，当执行该方法后，请返回一个新的 User 对象。 此外在构造方法中使用具名参数也是 groovy 的另一特点。Then 中剩余的代码对 result 对象进行检查。<br>由此测试代码驱动产生的产品代码非常简单，如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserService &#123;\n    private UserDao userDao;\n\n    public UserService(UserDao userDao) &#123;\n        this.userDao &#x3D; userDao;\n    &#125;\n\n    public User findUser(int id)&#123;\n        return userDao.get(id);\n    &#125;\n&#125;</code></pre>\n\n<p>接下来实现创建用户功能，在 UserService 中添加如下代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void createUser(User user) &#123;\n    &#x2F;&#x2F; check name\n    &#x2F;&#x2F; if exists, throw exception\n    &#x2F;&#x2F; if !exists, create user\n&#125;</code></pre>\n\n<p>在 UserDao 中添加如下方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public User findByName(String name);\npublic void createUser(User user);</code></pre>\n\n<p>相应的测试方法如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">def &quot;it saves a new user&quot;() &#123;\n    given:\n        def user &#x3D; new User(id: 1, name: &#39;James&#39;, age:27)\n\n    when:\n        service.createUser(user)\n\n    then:\n        1 * dao.findByName(user.name) &gt;&gt; null\n\n    then:\n        1 * dao.createUser(user)\n&#125;</code></pre>\n\n<p>在上述代码中出现了两处 Then，这是因为当所有断言放在一个 then 块中，Spock 会认为这些断言是同时发生的。 如果期望断言按顺序执行，则需要将断言分割到多个 then 块中，spock 会按顺序执行断言。 如上述所示，首先需要判断用户是否存在，然后再去创建用户。产品代码实现如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void createUser(User user)&#123;\n    User existing &#x3D; userDao.findByName(user.getName());\n\n    if(existing &#x3D;&#x3D; null)&#123;\n        userDao.createUser(user);\n    &#125;\n&#125;</code></pre>\n\n<p>上述代码针对用户不存在场景，而对于用户存在的场景，测试代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">def &quot;it fails to create a user because one already exists with that name&quot;() &#123;\n    given:\n        def user &#x3D; new User(id: 1, name: &#39;James&#39;, age:27)\n\n    when:\n        service.createUser(user)\n\n    then:\n        1 * dao.findByName(user.name) &gt;&gt; user\n\n    then:\n        0 * dao.createUser(user)\n\n    then:\n        def exception &#x3D; thrown(RuntimeException)\n        exception.message &#x3D;&#x3D; &quot;User with name $&#123;user.name&#125; already exists!&quot;\n&#125;</code></pre>\n\n<p>上述代码当调用 findByName 时，返回一个存在的用户，然后不调用 createUser()，第三个 Then 块捕获方法抛出的异常。 注意 groovy 拥有一个称之为 GStrings 的特征，该特征可以在引用的字符串中插入参数，如${user.name}。相应产品代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void createUser(User user)&#123;\n    User existing &#x3D; userDao.findByName(user.getName());\n\n    if(existing &#x3D;&#x3D; null)&#123;\n        userDao.createUser(user);\n    &#125; else&#123;\n        throw new RuntimeException(String.format(&quot;User with name %s already exists!&quot;, user.getName()));\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"结合-PowerMock-mock-静态方法\"><a href=\"#结合-PowerMock-mock-静态方法\" class=\"headerlink\" title=\"结合 PowerMock mock 静态方法\"></a>结合 PowerMock mock 静态方法</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RunWith(PowerMockRunner)\n@PowerMockRunnerDelegate(Sputnik)\n@PowerMockIgnore(&#123;\n        &quot;javax.net.ssl.*&quot;,\n        &quot;javax.management.*&quot;,\n        &quot;com.sun.crypto.*&quot;,\n        &quot;javax.crypto.*&quot;&#125;)\n@PrepareForTest([BizEngine.class])\nclass BaseSimpleTest extends Specification &#123;\n    def &quot;test engine&quot;() &#123;\n        setup:\n        BizEngine mockStatic &#x3D; PowerMockito.mock(BizEngine.class)\n        Whitebox.setInternalState(BizEngine.class, &quot;bizEngine&quot;, mockStatic)\n\n        when:\n        Mockito.when(mockStatic.getPoint(Point.class, null, null)).thenReturn(new LocationPoint())\n\n        then:\n        println &quot;test engine end&quot;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"其他提示\"><a href=\"#其他提示\" class=\"headerlink\" title=\"其他提示\"></a>其他提示</h2><ul>\n<li>最重要也是最容易被遗忘的提示，阅读 spock 文档</li>\n<li>可以命名 spock 块，例如将 given 命名为“Some variables”，有助于开发者在测试代码中更加清楚的表达含义</li>\n<li>当对 mock 对象方法调用次数不关心时，可以使用_ * mock.method()</li>\n<li>在 then 块中可使用下划线来通配方法及类，例如，0 _ mock._ 表示期望 mock 对象的任何方法都未被调用，或 0 _ . 表示期望任何对象的任何方法都未被调用</li>\n<li>通常按 given，when，then 编写测试，但实际上从 when 开始编写测试会更加容易发现测试需要的 given 和测试的输出结果(then)</li>\n<li>expect 块对于测试不需要对 mock 对象进行断言的简单方法更加有效</li>\n<li>当对于传递给 mock 对象的参数不关注时，可以使用通配符参数</li>\n<li>拥抱 groovy 闭包 Embrace groovy closures! They can be you’re best friend in assertions!</li>\n<li>当希望在整个测试类中只运行一次，可以复写 setupSpec 和 cleanupSpec</li>\n</ul>\n","categories":[{"name":"spock","path":"api/categories/spock.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Spock","path":"api/tags/Spock.json"}]}