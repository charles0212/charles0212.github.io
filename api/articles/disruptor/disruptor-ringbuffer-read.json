{"title":"Disruptor（二）RingBuffer读取","slug":"yuque/Disruptor（二）RingBuffer读取","date":"2016-12-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-read.json","excerpt":"上一章主要介绍 Ring Buffer的数据结构，本章主要讲解如何使用Disruptor 从 RingBuffer 中读取数据。1、消费者通过ProcessingSequenceBarrier读取数据能够读取数据的前提是数据已经写入到Ring Buffer中，关于数据的写入，后面一章节会详细讲解。RingBuffer 的元素的大小是 2的 n 次方（上面ringBufferSize 为8，从序号 0开始）。消费者(Consumer)是一个想从RingBuffer里读取数据的线程，它可以通过访问ProcessingSequenceBarrier对象和 ","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648397116031-82c58b44-3caf-47c7-bb3b-1923c80bd4c0.png#clientId=ucd2ac4d2-f85d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u326a8084&margin=%5Bobject%20Object%5D&name=image.png&originHeight=280&originWidth=704&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=29588&status=done&style=none&taskId=u8a8a8a8c-b409-491e-8b5a-757f23d4e78&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648397116033-7c7deb37-2b47-48ba-9449-270ec1b3134a.png#clientId=ucd2ac4d2-f85d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uec892130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=668&originWidth=508&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=44819&status=done&style=none&taskId=u47f1190a-0a68-4a7c-94f2-7c4dae2a966&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648397115980-a1126197-6f1f-48eb-85c7-86399a9d6161.png#clientId=ucd2ac4d2-f85d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u652bf873&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=441&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=36301&status=done&style=none&taskId=u7d531f19-1748-4b73-b0e2-fcee70debc0&title="],"content":"<p>上一章主要介绍 Ring Buffer 的数据结构，本章主要讲解如何使用 Disruptor 从 Ring Buffer 中读取数据。</p>\n<h2 id=\"1、消费者通过-ProcessingSequenceBarrier-读取数据\"><a href=\"#1、消费者通过-ProcessingSequenceBarrier-读取数据\" class=\"headerlink\" title=\"1、消费者通过 ProcessingSequenceBarrier 读取数据\"></a>1、消费者通过 ProcessingSequenceBarrier 读取数据</h2><p>能够读取数据的前提是数据已经写入到 Ring Buffer 中，关于数据的写入，后面一章节会详细讲解。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397116031-82c58b44-3caf-47c7-bb3b-1923c80bd4c0.png#clientId=ucd2ac4d2-f85d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u326a8084&margin=%5Bobject%20Object%5D&name=image.png&originHeight=280&originWidth=704&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=29588&status=done&style=none&taskId=u8a8a8a8c-b409-491e-8b5a-757f23d4e78&title=\" alt=\"image.png\"><br>RingBuffer 的元素的大小是 2 的 n 次方（上面 ringBufferSize 为 8，从序号 0 开始）。消费者(Consumer)是一个想从 RingBuffer 里读取数据的线程，它可以通过访问 ProcessingSequenceBarrier 对象和 RingBuffer 进行交互。消费者也需要知道它将要处理的序号，每个消费者都需要找到下一个它要访问的序号。在上面的例子中，消费者处理完了 RingBuffer 里序号 8 之前（包括 8）的所有数据，那么它期待访问的下一个序号是 9。</p>\n<h2 id=\"2、消费者-BatchEventProcessor\"><a href=\"#2、消费者-BatchEventProcessor\" class=\"headerlink\" title=\"2、消费者 BatchEventProcessor\"></a>2、消费者 BatchEventProcessor</h2><p>关于消费者如何通过调用 SequenceBarrier 对象的 waitFor()方法，传递它所需要的下一个序号。本章节以 BatchEventProcessor 批量事件处理器为例进行讲解，首先查看类图。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397116033-7c7deb37-2b47-48ba-9449-270ec1b3134a.png#clientId=ucd2ac4d2-f85d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uec892130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=668&originWidth=508&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=44819&status=done&style=none&taskId=u47f1190a-0a68-4a7c-94f2-7c4dae2a966&title=\" alt=\"image.png\"><br>主要继承 EventProcessor 接口和 Runnable 接口，本章主要介绍 run 方法，对于 BatchEventProcessor 的初始化暂时不做讲解。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void run() &#123;\n    &#x2F;&#x2F; 线程是否运行\n    if (!running.compareAndSet(false, true)) &#123;\n        throw new IllegalStateException(&quot;Thread is already running&quot;);\n    &#125;\n    &#x2F;&#x2F; 将ProcessingSequenceBarrier的alerted设置成false\n    sequenceBarrier.clearAlert();\n    &#x2F;&#x2F; start事件处理\n    notifyStart();\n\n    T event &#x3D; null;\n    &#x2F;&#x2F; 获取当前事件处理器的下一个sequence\n    long nextSequence &#x3D; sequence.get() + 1L;\n    try &#123;\n        while (true) &#123;\n            try &#123;\n                &#x2F;&#x2F; 从ProcessingSequenceBarrier获取可用的availableSequence\n                final long availableSequence &#x3D; sequenceBarrier.waitFor(nextSequence);\n                &#x2F;&#x2F; 下一个nextSequence比可用的availableSequence小的时候，获取事件，并触发事件处理\n                while (nextSequence &lt;&#x3D; availableSequence) &#123;\n                    event &#x3D; dataProvider.get(nextSequence);\n                    &#x2F;&#x2F; 消费者事件处理\n                    eventHandler.onEvent(event, nextSequence, nextSequence &#x3D;&#x3D; availableSequence);\n                    nextSequence++;\n                &#125;\n                &#x2F;&#x2F; 设置当前事件处理器已经处理的sequence\n                sequence.set(availableSequence);\n            &#125; catch (final TimeoutException e) &#123;\n                &#x2F;&#x2F; 超时处理\n                notifyTimeout(sequence.get());\n            &#125; catch (final AlertException ex) &#123;\n                if (!running.get()) &#123;\n                    break;\n                &#125;\n            &#125; catch (final Throwable ex) &#123;\n                &#x2F;&#x2F; 异常事件处理\n                exceptionHandler.handleEventException(ex, nextSequence, event);\n                sequence.set(nextSequence);\n                nextSequence++;\n            &#125;\n        &#125;\n    &#125; finally &#123;\n        &#x2F;&#x2F; 关闭事件处理\n        notifyShutdown();\n        running.set(false);\n    &#125;\n&#125;</code></pre>\n\n<p>拿到了数据后，消费者(Consumer)会更新自己的标识(cursor)，消费者(Consumer)现在只需要通过简单通过 ProcessingSequenceBarrier 拿到可用的 Ringbuffer 中的 Sequence 序号就可以可以读取数据了。因为这些新的节点的确已经写入了数据（RingBuffer 本身的序号已经更新），而且消费者对这些节点的唯一操作是读而不是写，因此访问不用加锁。不仅代码实现起来可以更加安全和简单，而且不用加锁使得速度更快。另一个好处是可以用多个消费者(Consumer)去读同一个 RingBuffer，不需要加锁，也不需要用另外的队列来协调不同的线程(消费者)。这样你可以在 Disruptor 的协调下实现真正的并发数据处理。</p>\n<h2 id=\"3、ProcessingSequenceBarrier-获取可用序号\"><a href=\"#3、ProcessingSequenceBarrier-获取可用序号\" class=\"headerlink\" title=\"3、ProcessingSequenceBarrier 获取可用序号\"></a>3、ProcessingSequenceBarrier 获取可用序号</h2><p>在上面的 BatchEventProcessor 中的 run 方法中有如下调用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final long availableSequence &#x3D; sequenceBarrier.waitFor(nextSequence);</code></pre>\n\n<p>获取 RingBuffer 最大可访问的 availableSequence 序号，在上面的例子中是 10。<br>首先看下 ProcessingSequenceBarrier 的类图。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397115980-a1126197-6f1f-48eb-85c7-86399a9d6161.png#clientId=ucd2ac4d2-f85d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u652bf873&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=441&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=36301&status=done&style=none&taskId=u7d531f19-1748-4b73-b0e2-fcee70debc0&title=\" alt=\"image.png\"><br>其实现了 SequenceBarrier 接口，用于和 RingBuffer 之间进行交互，下面主要看下构造函数和 waitFor 函数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long waitFor(final long sequence)\n        throws AlertException, InterruptedException, TimeoutException &#123;\n    &#x2F;&#x2F; 检查clert异常\n    checkAlert();\n    &#x2F;&#x2F; 通过waitStrategy策略获取可用的序号,cursorSequence为当前的Sequence，dependentSequence为依赖的Sequence[]\n    long availableSequence &#x3D; waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, this);\n    &#x2F;&#x2F; 产生比预期的sequence小,可能序号被重置回老的的oldSequence值\n    &#x2F;&#x2F;可参考https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;issues&#x2F;76\n    if (availableSequence &lt;sequence) &#123;\n        return availableSequence;\n    &#125;\n    &#x2F;&#x2F; 获取最大的可用的已经发布的sequence，可能比sequence小\n    &#x2F;&#x2F; 会在多生产者中出现，当生产者1获取到序号13，生产者2获取到14；生产者1没发布，生产者2发布，会导致获取的可用序号为12，而sequence为13\n    return sequencer.getHighestPublishedSequence(sequence, availableSequence);\n&#125;</code></pre>\n\n<h2 id=\"4、WaitStrategy-策略\"><a href=\"#4、WaitStrategy-策略\" class=\"headerlink\" title=\"4、WaitStrategy 策略\"></a>4、WaitStrategy 策略</h2><p>waitFor 函数的主要功能为获取到可用的 sequence 并返回给事件处理器。SequenceBarrier 内部有一个 WaitStrategy 方法来决定它如何等待这个序号，我现在不会去描述它的细节，代码的注释里已经概括了每一种 WaitStrategy 的优点和缺点，目前的实现方式主要有以下几种，后续会做详细介绍。</p>\n<ul>\n<li>BlockingWaitStrategy</li>\n<li>BusySpinWaitStrategy</li>\n<li>LiteBlockingWaitStrategy</li>\n<li>PhasedBackoffWaitStrategy</li>\n<li>SleepingWaitStrategy</li>\n<li>TimeoutBlockingWaitStrategy</li>\n<li>YieldingWaitStrategy</li>\n</ul>\n","more":"<p>上一章主要介绍 Ring Buffer 的数据结构，本章主要讲解如何使用 Disruptor 从 Ring Buffer 中读取数据。</p>\n<h2 id=\"1、消费者通过-ProcessingSequenceBarrier-读取数据\"><a href=\"#1、消费者通过-ProcessingSequenceBarrier-读取数据\" class=\"headerlink\" title=\"1、消费者通过 ProcessingSequenceBarrier 读取数据\"></a>1、消费者通过 ProcessingSequenceBarrier 读取数据</h2><p>能够读取数据的前提是数据已经写入到 Ring Buffer 中，关于数据的写入，后面一章节会详细讲解。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397116031-82c58b44-3caf-47c7-bb3b-1923c80bd4c0.png#clientId=ucd2ac4d2-f85d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u326a8084&margin=%5Bobject%20Object%5D&name=image.png&originHeight=280&originWidth=704&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=29588&status=done&style=none&taskId=u8a8a8a8c-b409-491e-8b5a-757f23d4e78&title=\" alt=\"image.png\"><br>RingBuffer 的元素的大小是 2 的 n 次方（上面 ringBufferSize 为 8，从序号 0 开始）。消费者(Consumer)是一个想从 RingBuffer 里读取数据的线程，它可以通过访问 ProcessingSequenceBarrier 对象和 RingBuffer 进行交互。消费者也需要知道它将要处理的序号，每个消费者都需要找到下一个它要访问的序号。在上面的例子中，消费者处理完了 RingBuffer 里序号 8 之前（包括 8）的所有数据，那么它期待访问的下一个序号是 9。</p>\n<h2 id=\"2、消费者-BatchEventProcessor\"><a href=\"#2、消费者-BatchEventProcessor\" class=\"headerlink\" title=\"2、消费者 BatchEventProcessor\"></a>2、消费者 BatchEventProcessor</h2><p>关于消费者如何通过调用 SequenceBarrier 对象的 waitFor()方法，传递它所需要的下一个序号。本章节以 BatchEventProcessor 批量事件处理器为例进行讲解，首先查看类图。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397116033-7c7deb37-2b47-48ba-9449-270ec1b3134a.png#clientId=ucd2ac4d2-f85d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uec892130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=668&originWidth=508&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=44819&status=done&style=none&taskId=u47f1190a-0a68-4a7c-94f2-7c4dae2a966&title=\" alt=\"image.png\"><br>主要继承 EventProcessor 接口和 Runnable 接口，本章主要介绍 run 方法，对于 BatchEventProcessor 的初始化暂时不做讲解。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void run() &#123;\n    &#x2F;&#x2F; 线程是否运行\n    if (!running.compareAndSet(false, true)) &#123;\n        throw new IllegalStateException(&quot;Thread is already running&quot;);\n    &#125;\n    &#x2F;&#x2F; 将ProcessingSequenceBarrier的alerted设置成false\n    sequenceBarrier.clearAlert();\n    &#x2F;&#x2F; start事件处理\n    notifyStart();\n\n    T event &#x3D; null;\n    &#x2F;&#x2F; 获取当前事件处理器的下一个sequence\n    long nextSequence &#x3D; sequence.get() + 1L;\n    try &#123;\n        while (true) &#123;\n            try &#123;\n                &#x2F;&#x2F; 从ProcessingSequenceBarrier获取可用的availableSequence\n                final long availableSequence &#x3D; sequenceBarrier.waitFor(nextSequence);\n                &#x2F;&#x2F; 下一个nextSequence比可用的availableSequence小的时候，获取事件，并触发事件处理\n                while (nextSequence &lt;&#x3D; availableSequence) &#123;\n                    event &#x3D; dataProvider.get(nextSequence);\n                    &#x2F;&#x2F; 消费者事件处理\n                    eventHandler.onEvent(event, nextSequence, nextSequence &#x3D;&#x3D; availableSequence);\n                    nextSequence++;\n                &#125;\n                &#x2F;&#x2F; 设置当前事件处理器已经处理的sequence\n                sequence.set(availableSequence);\n            &#125; catch (final TimeoutException e) &#123;\n                &#x2F;&#x2F; 超时处理\n                notifyTimeout(sequence.get());\n            &#125; catch (final AlertException ex) &#123;\n                if (!running.get()) &#123;\n                    break;\n                &#125;\n            &#125; catch (final Throwable ex) &#123;\n                &#x2F;&#x2F; 异常事件处理\n                exceptionHandler.handleEventException(ex, nextSequence, event);\n                sequence.set(nextSequence);\n                nextSequence++;\n            &#125;\n        &#125;\n    &#125; finally &#123;\n        &#x2F;&#x2F; 关闭事件处理\n        notifyShutdown();\n        running.set(false);\n    &#125;\n&#125;</code></pre>\n\n<p>拿到了数据后，消费者(Consumer)会更新自己的标识(cursor)，消费者(Consumer)现在只需要通过简单通过 ProcessingSequenceBarrier 拿到可用的 Ringbuffer 中的 Sequence 序号就可以可以读取数据了。因为这些新的节点的确已经写入了数据（RingBuffer 本身的序号已经更新），而且消费者对这些节点的唯一操作是读而不是写，因此访问不用加锁。不仅代码实现起来可以更加安全和简单，而且不用加锁使得速度更快。另一个好处是可以用多个消费者(Consumer)去读同一个 RingBuffer，不需要加锁，也不需要用另外的队列来协调不同的线程(消费者)。这样你可以在 Disruptor 的协调下实现真正的并发数据处理。</p>\n<h2 id=\"3、ProcessingSequenceBarrier-获取可用序号\"><a href=\"#3、ProcessingSequenceBarrier-获取可用序号\" class=\"headerlink\" title=\"3、ProcessingSequenceBarrier 获取可用序号\"></a>3、ProcessingSequenceBarrier 获取可用序号</h2><p>在上面的 BatchEventProcessor 中的 run 方法中有如下调用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final long availableSequence &#x3D; sequenceBarrier.waitFor(nextSequence);</code></pre>\n\n<p>获取 RingBuffer 最大可访问的 availableSequence 序号，在上面的例子中是 10。<br>首先看下 ProcessingSequenceBarrier 的类图。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397115980-a1126197-6f1f-48eb-85c7-86399a9d6161.png#clientId=ucd2ac4d2-f85d-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u652bf873&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=441&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=36301&status=done&style=none&taskId=u7d531f19-1748-4b73-b0e2-fcee70debc0&title=\" alt=\"image.png\"><br>其实现了 SequenceBarrier 接口，用于和 RingBuffer 之间进行交互，下面主要看下构造函数和 waitFor 函数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long waitFor(final long sequence)\n        throws AlertException, InterruptedException, TimeoutException &#123;\n    &#x2F;&#x2F; 检查clert异常\n    checkAlert();\n    &#x2F;&#x2F; 通过waitStrategy策略获取可用的序号,cursorSequence为当前的Sequence，dependentSequence为依赖的Sequence[]\n    long availableSequence &#x3D; waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, this);\n    &#x2F;&#x2F; 产生比预期的sequence小,可能序号被重置回老的的oldSequence值\n    &#x2F;&#x2F;可参考https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;issues&#x2F;76\n    if (availableSequence &lt;sequence) &#123;\n        return availableSequence;\n    &#125;\n    &#x2F;&#x2F; 获取最大的可用的已经发布的sequence，可能比sequence小\n    &#x2F;&#x2F; 会在多生产者中出现，当生产者1获取到序号13，生产者2获取到14；生产者1没发布，生产者2发布，会导致获取的可用序号为12，而sequence为13\n    return sequencer.getHighestPublishedSequence(sequence, availableSequence);\n&#125;</code></pre>\n\n<h2 id=\"4、WaitStrategy-策略\"><a href=\"#4、WaitStrategy-策略\" class=\"headerlink\" title=\"4、WaitStrategy 策略\"></a>4、WaitStrategy 策略</h2><p>waitFor 函数的主要功能为获取到可用的 sequence 并返回给事件处理器。SequenceBarrier 内部有一个 WaitStrategy 方法来决定它如何等待这个序号，我现在不会去描述它的细节，代码的注释里已经概括了每一种 WaitStrategy 的优点和缺点，目前的实现方式主要有以下几种，后续会做详细介绍。</p>\n<ul>\n<li>BlockingWaitStrategy</li>\n<li>BusySpinWaitStrategy</li>\n<li>LiteBlockingWaitStrategy</li>\n<li>PhasedBackoffWaitStrategy</li>\n<li>SleepingWaitStrategy</li>\n<li>TimeoutBlockingWaitStrategy</li>\n<li>YieldingWaitStrategy</li>\n</ul>\n","categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]}