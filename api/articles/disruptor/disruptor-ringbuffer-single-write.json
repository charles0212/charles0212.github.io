{"title":"Disruptor（三）RingBuffer单生产者写入","slug":"yuque/Disruptor（三）RingBuffer单生产者写入","date":"2017-02-15T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-single-write.json","excerpt":"上一章主要介绍了消费者从RingBuffer读取数据，本章主要介绍单个生产者如何向RingBuffer 数据写入数据。在RingBuffer数据写入过程中如何不要让 Ring重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作。在 RingBuffer写入数据的过程涉及到两阶段提交(two-phasecommit)1）生产者需要申请 buffer里的下一个节点。2）当生产者向节点写完数据，需要调用调用publish 发布数据。1、单个生产者SingleProducerSequencer数据写入在后台由ProducerSequencer","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648397299914-3ed84df9-6972-4100-91ef-73f24102ce5a.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6219745a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=644&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=31518&status=done&style=none&taskId=ud945e053-3c92-4edc-91fb-966dcbaff45&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648397299926-647bb596-72a8-4fd0-893c-ae97bbf0750e.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf1f8ca5f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=646&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=31871&status=done&style=none&taskId=u40900888-32ec-44ca-a8ef-9cf680b0bf0&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648397299941-c11a08c3-60fa-4ada-b893-38ab8221f12a.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1b79e4c6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=375&originWidth=964&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=52541&status=done&style=none&taskId=u05f1893c-4fae-4722-ba8c-917ef06c989&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648397300602-265d27ae-f95c-43ef-b703-f79eda237721.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub001cddc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1113&originWidth=1198&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=138853&status=done&style=none&taskId=ucd5ccad9-2b8a-4af1-8a15-f051d5c6473&title="],"content":"<p>上一章主要介绍了消费者从 RingBuffer 读取数据，本章主要介绍单个生产者如何向 RingBuffer 数据写入数据。在 RingBuffer 数据写入过程中如何不要让 Ring 重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作。<br>在 RingBuffer 写入数据的过程涉及到两阶段提交(two-phasecommit)<br>1）生产者需要申请 buffer 里的下一个节点。<br>2）当生产者向节点写完数据，需要调用调用 publish 发布数据。</p>\n<h2 id=\"1、单个生产者-SingleProducerSequencer-数据写入\"><a href=\"#1、单个生产者-SingleProducerSequencer-数据写入\" class=\"headerlink\" title=\"1、单个生产者 SingleProducerSequencer 数据写入\"></a>1、单个生产者 SingleProducerSequencer 数据写入</h2><p>在后台由 ProducerSequencer 负责所有的交互细节，来从 RingBuffer 中找到下一个节点，然后才允许生产者向它写入数据。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397299914-3ed84df9-6972-4100-91ef-73f24102ce5a.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6219745a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=644&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=31518&status=done&style=none&taskId=ud945e053-3c92-4edc-91fb-966dcbaff45&title=\" alt=\"image.png\"><br>在图中一个生产者写入 RingBuffer，SingleProducerSequencer 对象拥有所有正在访问 RingBuffer 的消费者 gatingSequences 列表（区别于队列需要追踪队列的头和尾，而且它们有时候会指向相同的位置），Disruptor 中由消费者负责通知它们处理到了哪个序列号，而不是 RingBuffer。<br>如果想确定我们没有让 RingBuffer 重叠，需要检查所有的消费者们都读到了哪里。在上图中有 2 个消费者，一个消费者顺利的读到了最大序号 13（用蓝色高亮），第二个消费者有点儿落后停在序号 6。因此消费者 2 在赶上消费者 1 之前要跑完整个 RingBuffer 一圈的距离。<br>现在生产者想要写入 RingBuffer 中序号 6 占据的节点，因为它是 RingBuffer 当前游标的下一个节点。但是 SingleProducerSequencer 明白现在不能写入，因为有一个消费者正在占用它。所以 SingleProducerSequencer 停下来自旋(spins)，等待，直到那个消费者离开。</p>\n<h2 id=\"2、申请下一个节点\"><a href=\"#2、申请下一个节点\" class=\"headerlink\" title=\"2、申请下一个节点\"></a>2、申请下一个节点</h2><p>现在可以想像消费者 2 已经处理完了一批节点，并且向前移动了它的序号。可能它挪到了序号 9（因为消费端的批处理方式，现实中我会预计它到达 13）<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397299926-647bb596-72a8-4fd0-893c-ae97bbf0750e.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf1f8ca5f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=646&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=31871&status=done&style=none&taskId=u40900888-32ec-44ca-a8ef-9cf680b0bf0&title=\" alt=\"image.png\"><br>上图显示了当消费者 2 挪动到序号 9 时发生的情况。SingleProducerSequencer 会看到下一个节点序号 6 那个已经可以用了。它会抢占这个节点上的 Entry（我还没有特别介绍 Entry 对象，基本上它是一个放写入到某个序号的 RingBuffer 数据的桶），把下一个序号（14）更新成 Entry 的序号，然后把 Entry 返回给生产者。生产者可以接着往 Entry 里写入数据。</p>\n<h2 id=\"3、提交新的数据\"><a href=\"#3、提交新的数据\" class=\"headerlink\" title=\"3、提交新的数据\"></a>3、提交新的数据</h2><p>将生产的数据提交，通知消费之。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397299941-c11a08c3-60fa-4ada-b893-38ab8221f12a.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1b79e4c6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=375&originWidth=964&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=52541&status=done&style=none&taskId=u05f1893c-4fae-4722-ba8c-917ef06c989&title=\" alt=\"image.png\"><br>绿色表示最近写入的 Entry，序号是 14，通过 publish 方法提交，设置 RingBuffer 的 cursor 为 14，通知消费者 14 被更新了，可以读取了（不同的 WaitStrategy 实现以不同的方式来实现提醒，取决于它是否采用阻塞模式）。现在消费者 2 可以读 Entry14 的数据进行消费了。<br>看完上面的原理后下面分析 SingleProducerSequencer 是如何获取序号和提交数据的。<strong>**</strong></p>\n<h2 id=\"4、SingleProducerSequencer-生产者类图\"><a href=\"#4、SingleProducerSequencer-生产者类图\" class=\"headerlink\" title=\"4、SingleProducerSequencer 生产者类图\"></a>4、SingleProducerSequencer 生产者类图</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397300602-265d27ae-f95c-43ef-b703-f79eda237721.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub001cddc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1113&originWidth=1198&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=138853&status=done&style=none&taskId=ucd5ccad9-2b8a-4af1-8a15-f051d5c6473&title=\" alt=\"image.png\"><br>SingleProducerSequencer 继承 AbstractSequencer，实现了 Sequencer 接口。<br>Sequencer 提供增加删除消费者序列，创建 SequenceBarrier，获取最小序号，和最大发布的序号。<br>Cursored 获取当前的游标。<br>Sequenced 获取当前 ringbuffer 大小，获取想一个序号，以及提交数据接口。</p>\n<h2 id=\"5、消费者和生产者直接的关联\"><a href=\"#5、消费者和生产者直接的关联\" class=\"headerlink\" title=\"5、消费者和生产者直接的关联\"></a>5、消费者和生产者直接的关联</h2><p>首先看下 AbstractSequencer 中定义</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 生产者的当前的游标位置\nprotected final Sequence cursor &#x3D; new Sequence(Sequencer.INITIAL_CURSOR_VALUE);\n&#x2F;&#x2F; 消费者当前处理的序号集合\nprotected volatile Sequence[] gatingSequences &#x3D; new Sequence[0];</code></pre>\n\n<p><strong>由于 volatile 只能保存可见性和禁止编译器优化，当时不能保证互斥性，多线程并发读写的话会有问题。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final AtomicReferenceFieldUpdater&lt;AbstractSequencer, Sequence[]&gt; SEQUENCE_UPDATER &#x3D; AtomicReferenceFieldUpdater.newUpdater(AbstractSequencer.class, Sequence[].class, &quot;gatingSequences&quot;);</code></pre>\n\n<p><strong>使用 AtomicReferenceFieldUpdater 原子字段更新解决多线程更新 gatingSequences 问题</strong><br>具体实现参照 SequenceGroups 中使用 CAS 进行更新。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void addGatingSequences(Sequence... gatingSequences) &#123;\n    SequenceGroups.addSequences(this, SEQUENCE_UPDATER, this, gatingSequences);\n&#125;\npublic boolean removeGatingSequence(Sequence sequence) &#123;\n    return SequenceGroups.removeSequence(this, SEQUENCE_UPDATER, sequence);\n&#125;</code></pre>\n\n<h2 id=\"6、生产者使用-next-获取下一个可用的序号\"><a href=\"#6、生产者使用-next-获取下一个可用的序号\" class=\"headerlink\" title=\"6、生产者使用 next 获取下一个可用的序号\"></a>6、生产者使用 next 获取下一个可用的序号</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long next(int n) &#123;\n    if (n &lt;1) &#123;\n        throw new IllegalArgumentException(&quot;n must be &gt; 0&quot;);\n    &#125;\n    &#x2F;&#x2F; 当前的最小序号（单个生产者为生产者的游标）\n    long nextValue &#x3D; this.nextValue;\n    &#x2F;&#x2F; 下一个序号\n    long nextSequence &#x3D; nextValue + n;\n    &#x2F;&#x2F; 重叠点位置\n    long wrapPoint &#x3D; nextSequence - bufferSize;\n    &#x2F;&#x2F; 缓存的消费者处理的序号\n    long cachedGatingSequence &#x3D; this.cachedValue;\n    &#x2F;&#x2F; wrapPoint &gt; cachedGatingSequence,\n    &#x2F;&#x2F; 重叠位置大于缓存的消费者处理的序号，说明有消费者没有处理完成，不能够防止数据\n    &#x2F;&#x2F; cachedGatingSequence &gt; nextValue\n    &#x2F;&#x2F; 只会在https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;issues&#x2F;76情况下存在\n    if (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; nextValue) &#123;\n        long minSequence;\n        &#x2F;&#x2F; 等待不重叠后退出循环\n        while (wrapPoint &gt; (minSequence &#x3D; Util.getMinimumSequence(gatingSequences, nextValue))) &#123;\n            &#x2F;&#x2F; 通知消费者处理事件\n            waitStrategy.signalAllWhenBlocking();\n            &#x2F;&#x2F; 生产者等待的时候后自旋，后续需要使用策略\n            LockSupport.parkNanos(1L);\n        &#125;\n        &#x2F;&#x2F; 缓存消费者和生产者的最小序号\n        this.cachedValue &#x3D; minSequence;\n    &#125;\n    &#x2F;&#x2F; 设置生产者下一个可用的的序号\n    this.nextValue &#x3D; nextSequence;\n    return nextSequence;\n&#125;</code></pre>\n\n<h2 id=\"7、生产者使用-publish-发布数据\"><a href=\"#7、生产者使用-publish-发布数据\" class=\"headerlink\" title=\"7、生产者使用 publish 发布数据\"></a>7、生产者使用 publish 发布数据</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void publish(long sequence) &#123; &#x2F;&#x2F; 设置生产者的游标序号\n    cursor.set(sequence);\n    &#x2F;&#x2F; 通知消费者处理事件\n    waitStrategy.signalAllWhenBlocking();\n&#125;</code></pre>\n\n<p>当发布数据后，消费者 sequenceBarrier.waitFor(nextSequence)就能够获取 RingBuffer 最大可访问的 availableSequence 序号，处理数据了。</p>\n<h2 id=\"8、消费者消费数据\"><a href=\"#8、消费者消费数据\" class=\"headerlink\" title=\"8、消费者消费数据\"></a>8、消费者消费数据</h2><p>再回忆下 ProcessingSequenceBarrier 的 waitFor 函数，其中调用到了 sequencer.getHighestPublishedSequence(sequence, availableSequence);</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long waitFor(final long sequence)\n        throws AlertException, InterruptedException, TimeoutException &#123;\n    &#x2F;&#x2F; 检查clert异常\n    checkAlert();\n    &#x2F;&#x2F; 通过waitStrategy策略获取可用的序号,cursorSequence为当前的Sequence，dependentSequence为依赖的Sequence[]\n    long availableSequence &#x3D; waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, this);\n    &#x2F;&#x2F; 产生比预期的sequence小,可能序号被重置回老的的oldSequence值\n    &#x2F;&#x2F;可参考https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;issues&#x2F;76\n    if (availableSequence &lt;sequence) &#123;\n        return availableSequence;\n    &#125;\n    &#x2F;&#x2F; 获取最大的可用的已经发布的sequence，可能比sequence小\n    &#x2F;&#x2F; 会在多生产者中出现，当生产者1获取到序号13，生产者2获取到14；生产者1没发布，生产者2发布，会导致获取的可用序号为12，而sequence为13\n    return sequencer.getHighestPublishedSequence(sequence, availableSequence);\n&#125;\npublic long getHighestPublishedSequence(long lowerBound, long availableSequence) &#123;\n    return availableSequence;\n&#125;</code></pre>\n\n<p>在 SingleProducerSequencer 的 getHighestPublishedSequence 方法中直接返回可用的 availableSequence，通知消费者消费数据。通过以上步骤，生产者和消费者就协同起来了。</p>\n","more":"<p>上一章主要介绍了消费者从 RingBuffer 读取数据，本章主要介绍单个生产者如何向 RingBuffer 数据写入数据。在 RingBuffer 数据写入过程中如何不要让 Ring 重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作。<br>在 RingBuffer 写入数据的过程涉及到两阶段提交(two-phasecommit)<br>1）生产者需要申请 buffer 里的下一个节点。<br>2）当生产者向节点写完数据，需要调用调用 publish 发布数据。</p>\n<h2 id=\"1、单个生产者-SingleProducerSequencer-数据写入\"><a href=\"#1、单个生产者-SingleProducerSequencer-数据写入\" class=\"headerlink\" title=\"1、单个生产者 SingleProducerSequencer 数据写入\"></a>1、单个生产者 SingleProducerSequencer 数据写入</h2><p>在后台由 ProducerSequencer 负责所有的交互细节，来从 RingBuffer 中找到下一个节点，然后才允许生产者向它写入数据。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397299914-3ed84df9-6972-4100-91ef-73f24102ce5a.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6219745a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=644&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=31518&status=done&style=none&taskId=ud945e053-3c92-4edc-91fb-966dcbaff45&title=\" alt=\"image.png\"><br>在图中一个生产者写入 RingBuffer，SingleProducerSequencer 对象拥有所有正在访问 RingBuffer 的消费者 gatingSequences 列表（区别于队列需要追踪队列的头和尾，而且它们有时候会指向相同的位置），Disruptor 中由消费者负责通知它们处理到了哪个序列号，而不是 RingBuffer。<br>如果想确定我们没有让 RingBuffer 重叠，需要检查所有的消费者们都读到了哪里。在上图中有 2 个消费者，一个消费者顺利的读到了最大序号 13（用蓝色高亮），第二个消费者有点儿落后停在序号 6。因此消费者 2 在赶上消费者 1 之前要跑完整个 RingBuffer 一圈的距离。<br>现在生产者想要写入 RingBuffer 中序号 6 占据的节点，因为它是 RingBuffer 当前游标的下一个节点。但是 SingleProducerSequencer 明白现在不能写入，因为有一个消费者正在占用它。所以 SingleProducerSequencer 停下来自旋(spins)，等待，直到那个消费者离开。</p>\n<h2 id=\"2、申请下一个节点\"><a href=\"#2、申请下一个节点\" class=\"headerlink\" title=\"2、申请下一个节点\"></a>2、申请下一个节点</h2><p>现在可以想像消费者 2 已经处理完了一批节点，并且向前移动了它的序号。可能它挪到了序号 9（因为消费端的批处理方式，现实中我会预计它到达 13）<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397299926-647bb596-72a8-4fd0-893c-ae97bbf0750e.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf1f8ca5f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=646&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=31871&status=done&style=none&taskId=u40900888-32ec-44ca-a8ef-9cf680b0bf0&title=\" alt=\"image.png\"><br>上图显示了当消费者 2 挪动到序号 9 时发生的情况。SingleProducerSequencer 会看到下一个节点序号 6 那个已经可以用了。它会抢占这个节点上的 Entry（我还没有特别介绍 Entry 对象，基本上它是一个放写入到某个序号的 RingBuffer 数据的桶），把下一个序号（14）更新成 Entry 的序号，然后把 Entry 返回给生产者。生产者可以接着往 Entry 里写入数据。</p>\n<h2 id=\"3、提交新的数据\"><a href=\"#3、提交新的数据\" class=\"headerlink\" title=\"3、提交新的数据\"></a>3、提交新的数据</h2><p>将生产的数据提交，通知消费之。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397299941-c11a08c3-60fa-4ada-b893-38ab8221f12a.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1b79e4c6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=375&originWidth=964&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=52541&status=done&style=none&taskId=u05f1893c-4fae-4722-ba8c-917ef06c989&title=\" alt=\"image.png\"><br>绿色表示最近写入的 Entry，序号是 14，通过 publish 方法提交，设置 RingBuffer 的 cursor 为 14，通知消费者 14 被更新了，可以读取了（不同的 WaitStrategy 实现以不同的方式来实现提醒，取决于它是否采用阻塞模式）。现在消费者 2 可以读 Entry14 的数据进行消费了。<br>看完上面的原理后下面分析 SingleProducerSequencer 是如何获取序号和提交数据的。<strong>**</strong></p>\n<h2 id=\"4、SingleProducerSequencer-生产者类图\"><a href=\"#4、SingleProducerSequencer-生产者类图\" class=\"headerlink\" title=\"4、SingleProducerSequencer 生产者类图\"></a>4、SingleProducerSequencer 生产者类图</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397300602-265d27ae-f95c-43ef-b703-f79eda237721.png#clientId=ufc0fe107-3dbe-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub001cddc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1113&originWidth=1198&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=138853&status=done&style=none&taskId=ucd5ccad9-2b8a-4af1-8a15-f051d5c6473&title=\" alt=\"image.png\"><br>SingleProducerSequencer 继承 AbstractSequencer，实现了 Sequencer 接口。<br>Sequencer 提供增加删除消费者序列，创建 SequenceBarrier，获取最小序号，和最大发布的序号。<br>Cursored 获取当前的游标。<br>Sequenced 获取当前 ringbuffer 大小，获取想一个序号，以及提交数据接口。</p>\n<h2 id=\"5、消费者和生产者直接的关联\"><a href=\"#5、消费者和生产者直接的关联\" class=\"headerlink\" title=\"5、消费者和生产者直接的关联\"></a>5、消费者和生产者直接的关联</h2><p>首先看下 AbstractSequencer 中定义</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 生产者的当前的游标位置\nprotected final Sequence cursor &#x3D; new Sequence(Sequencer.INITIAL_CURSOR_VALUE);\n&#x2F;&#x2F; 消费者当前处理的序号集合\nprotected volatile Sequence[] gatingSequences &#x3D; new Sequence[0];</code></pre>\n\n<p><strong>由于 volatile 只能保存可见性和禁止编译器优化，当时不能保证互斥性，多线程并发读写的话会有问题。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final AtomicReferenceFieldUpdater&lt;AbstractSequencer, Sequence[]&gt; SEQUENCE_UPDATER &#x3D; AtomicReferenceFieldUpdater.newUpdater(AbstractSequencer.class, Sequence[].class, &quot;gatingSequences&quot;);</code></pre>\n\n<p><strong>使用 AtomicReferenceFieldUpdater 原子字段更新解决多线程更新 gatingSequences 问题</strong><br>具体实现参照 SequenceGroups 中使用 CAS 进行更新。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void addGatingSequences(Sequence... gatingSequences) &#123;\n    SequenceGroups.addSequences(this, SEQUENCE_UPDATER, this, gatingSequences);\n&#125;\npublic boolean removeGatingSequence(Sequence sequence) &#123;\n    return SequenceGroups.removeSequence(this, SEQUENCE_UPDATER, sequence);\n&#125;</code></pre>\n\n<h2 id=\"6、生产者使用-next-获取下一个可用的序号\"><a href=\"#6、生产者使用-next-获取下一个可用的序号\" class=\"headerlink\" title=\"6、生产者使用 next 获取下一个可用的序号\"></a>6、生产者使用 next 获取下一个可用的序号</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long next(int n) &#123;\n    if (n &lt;1) &#123;\n        throw new IllegalArgumentException(&quot;n must be &gt; 0&quot;);\n    &#125;\n    &#x2F;&#x2F; 当前的最小序号（单个生产者为生产者的游标）\n    long nextValue &#x3D; this.nextValue;\n    &#x2F;&#x2F; 下一个序号\n    long nextSequence &#x3D; nextValue + n;\n    &#x2F;&#x2F; 重叠点位置\n    long wrapPoint &#x3D; nextSequence - bufferSize;\n    &#x2F;&#x2F; 缓存的消费者处理的序号\n    long cachedGatingSequence &#x3D; this.cachedValue;\n    &#x2F;&#x2F; wrapPoint &gt; cachedGatingSequence,\n    &#x2F;&#x2F; 重叠位置大于缓存的消费者处理的序号，说明有消费者没有处理完成，不能够防止数据\n    &#x2F;&#x2F; cachedGatingSequence &gt; nextValue\n    &#x2F;&#x2F; 只会在https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;issues&#x2F;76情况下存在\n    if (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; nextValue) &#123;\n        long minSequence;\n        &#x2F;&#x2F; 等待不重叠后退出循环\n        while (wrapPoint &gt; (minSequence &#x3D; Util.getMinimumSequence(gatingSequences, nextValue))) &#123;\n            &#x2F;&#x2F; 通知消费者处理事件\n            waitStrategy.signalAllWhenBlocking();\n            &#x2F;&#x2F; 生产者等待的时候后自旋，后续需要使用策略\n            LockSupport.parkNanos(1L);\n        &#125;\n        &#x2F;&#x2F; 缓存消费者和生产者的最小序号\n        this.cachedValue &#x3D; minSequence;\n    &#125;\n    &#x2F;&#x2F; 设置生产者下一个可用的的序号\n    this.nextValue &#x3D; nextSequence;\n    return nextSequence;\n&#125;</code></pre>\n\n<h2 id=\"7、生产者使用-publish-发布数据\"><a href=\"#7、生产者使用-publish-发布数据\" class=\"headerlink\" title=\"7、生产者使用 publish 发布数据\"></a>7、生产者使用 publish 发布数据</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void publish(long sequence) &#123; &#x2F;&#x2F; 设置生产者的游标序号\n    cursor.set(sequence);\n    &#x2F;&#x2F; 通知消费者处理事件\n    waitStrategy.signalAllWhenBlocking();\n&#125;</code></pre>\n\n<p>当发布数据后，消费者 sequenceBarrier.waitFor(nextSequence)就能够获取 RingBuffer 最大可访问的 availableSequence 序号，处理数据了。</p>\n<h2 id=\"8、消费者消费数据\"><a href=\"#8、消费者消费数据\" class=\"headerlink\" title=\"8、消费者消费数据\"></a>8、消费者消费数据</h2><p>再回忆下 ProcessingSequenceBarrier 的 waitFor 函数，其中调用到了 sequencer.getHighestPublishedSequence(sequence, availableSequence);</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long waitFor(final long sequence)\n        throws AlertException, InterruptedException, TimeoutException &#123;\n    &#x2F;&#x2F; 检查clert异常\n    checkAlert();\n    &#x2F;&#x2F; 通过waitStrategy策略获取可用的序号,cursorSequence为当前的Sequence，dependentSequence为依赖的Sequence[]\n    long availableSequence &#x3D; waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, this);\n    &#x2F;&#x2F; 产生比预期的sequence小,可能序号被重置回老的的oldSequence值\n    &#x2F;&#x2F;可参考https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;issues&#x2F;76\n    if (availableSequence &lt;sequence) &#123;\n        return availableSequence;\n    &#125;\n    &#x2F;&#x2F; 获取最大的可用的已经发布的sequence，可能比sequence小\n    &#x2F;&#x2F; 会在多生产者中出现，当生产者1获取到序号13，生产者2获取到14；生产者1没发布，生产者2发布，会导致获取的可用序号为12，而sequence为13\n    return sequencer.getHighestPublishedSequence(sequence, availableSequence);\n&#125;\npublic long getHighestPublishedSequence(long lowerBound, long availableSequence) &#123;\n    return availableSequence;\n&#125;</code></pre>\n\n<p>在 SingleProducerSequencer 的 getHighestPublishedSequence 方法中直接返回可用的 availableSequence，通知消费者消费数据。通过以上步骤，生产者和消费者就协同起来了。</p>\n","categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]}