{"title":"Disruptor（四）RingBuffer多生产者写入","slug":"yuque/Disruptor（四）RingBuffer多生产者写入","date":"2017-03-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-muti-write.json","excerpt":"上一章主要介绍了单个生产者如何向RingBuffer数据写入数据，如何不要让 Ring重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作，本章主要介绍多生产者向RingBuffer 数据写入数据。1、多生产者MultiProducerSequencer申请下一个节点和单生产者不同的是在 next方法中会直接通过cursor.compareAndSet(current,next)设置生产者的游标 cursor的sequence。大家很可能会问设置了生产者的游标后，没有提交数据之前，多生产者场景中消费者是否就能够获取到数据，答案是否定的，在M","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514503-95042b3d-3223-4a11-8b63-129201a857c1.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2a2de43c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=678&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=43988&status=done&style=none&taskId=u8c23180a-f31c-4ca9-b827-e0afd2f50af&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514762-36299bf0-a7b3-4385-bb2e-ec274a82912d.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u38506f47&margin=%5Bobject%20Object%5D&name=image.png&originHeight=374&originWidth=983&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=54199&status=done&style=none&taskId=u670184da-248e-4801-b74b-b0b3a888803&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514845-7342f6ef-c79a-4654-ba17-f600028afef9.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua7e57fc7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1113&originWidth=1198&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=138853&status=done&style=none&taskId=ua3ae1fa6-21bd-44fa-9fc2-82e8254c611&title="],"content":"<p>上一章主要介绍了单个生产者如何向 RingBuffer 数据写入数据，如何不要让 Ring 重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作，本章主要介绍多生产者向 RingBuffer 数据写入数据。</p>\n<h2 id=\"1、多生产者-MultiProducerSequencer-申请下一个节点\"><a href=\"#1、多生产者-MultiProducerSequencer-申请下一个节点\" class=\"headerlink\" title=\"1、多生产者 MultiProducerSequencer 申请下一个节点\"></a>1、多生产者 MultiProducerSequencer 申请下一个节点</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514503-95042b3d-3223-4a11-8b63-129201a857c1.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2a2de43c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=678&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=43988&status=done&style=none&taskId=u8c23180a-f31c-4ca9-b827-e0afd2f50af&title=\" alt=\"image.png\"><br>和单生产者不同的是在 next 方法中会直接通过 cursor.compareAndSet(current, next)设置生产者的游标 cursor 的 sequence。大家很可能会问设置了生产者的游标后，没有提交数据之前，多生产者场景中消费者是否就能够获取到数据，答案是否定的，在 MultiProducerSequencer 实现的 getHighestPublishedSequence 的方法和单生产者有所区别，后面会详细讲解。</p>\n<h2 id=\"2、多生产者-MultiProducerSequencer-提交数据\"><a href=\"#2、多生产者-MultiProducerSequencer-提交数据\" class=\"headerlink\" title=\"2、多生产者 MultiProducerSequencer 提交数据\"></a>2、多生产者 MultiProducerSequencer 提交数据</h2><p>和单生产者的区别是使用 setAvailable 将数据设置成可用状态。<br>在多个生产者的场景下，还需要其他东西来追踪序号。这个序号是指当前可写入的序号。注意这和“向 RingBuffer 的游标加 1”不一样，如果你有一个以上的生产者同时在向 RingBuffer 写入，就有可能出现某些 Entry 正在被生产者写入但还没有提交的情况。<br>生产者 1 拿到序号 14，生产者 2 拿到序号 15。现在假设生产者 1 因为某些原因没有来得及提交数据。<br>生产者 2 通过 setAvailable(15)请求完成提交数据，如图所示。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514762-36299bf0-a7b3-4385-bb2e-ec274a82912d.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u38506f47&margin=%5Bobject%20Object%5D&name=image.png&originHeight=374&originWidth=983&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=54199&status=done&style=none&taskId=u670184da-248e-4801-b74b-b0b3a888803&title=\" alt=\"image.png\"><br>当这个时候消费者通过 waitFor(14)，返回的结果会为 13，不错任何事件处理。<br>当生产者 1 通过 setAvailable(14)请求完成提交数据，如图所示。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514831-75b3af6a-f08b-4905-9c3d-dbecbffec22e.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u02f3d4b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=371&originWidth=979&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=54879&status=done&style=none&taskId=u5c56fe60-3531-433e-aa86-2e6cb4e5a00&title=\" alt=\"image.png\"><br>以 BatchEventProcessor 的 run 实现会处理 14 和 15 位置上的数据，在下一次通过 waitFor(16)获取可用的数据。</p>\n<h3 id=\"3、MutiProducerSequencer-生产者类图。\"><a href=\"#3、MutiProducerSequencer-生产者类图。\" class=\"headerlink\" title=\"3、MutiProducerSequencer 生产者类图。\"></a>3、MutiProducerSequencer 生产者类图。</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514845-7342f6ef-c79a-4654-ba17-f600028afef9.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua7e57fc7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1113&originWidth=1198&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=138853&status=done&style=none&taskId=ua3ae1fa6-21bd-44fa-9fc2-82e8254c611&title=\" alt=\"image.png\"><br>MutiProducerSequencer 继承 AbstractSequencer，实现了 Sequencer 接口。<br>Sequencer 提供增加删除消费者序列，创建 SequenceBarrier，获取最小序号，和最大发布的序号。<br>Cursored 获取当前的游标。<br>Sequenced 获取当前 ringbuffer 大小，获取想一个序号，以及提交数据接口。<br>消费者和生产者之间的关联和单生产者一样，不做重复介绍。</p>\n<h4 id=\"4、多生产者通过-next-获取下一个可用的序号\"><a href=\"#4、多生产者通过-next-获取下一个可用的序号\" class=\"headerlink\" title=\"4、多生产者通过 next 获取下一个可用的序号\"></a>4、多生产者通过 next 获取下一个可用的序号</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long next(int n) &#123;\n    if (n &lt;1) &#123;\n        throw new IllegalArgumentException(&quot;n must be &gt; 0&quot;);\n    &#125;\n    long current;\n    long next;\n    do &#123;\n        &#x2F;&#x2F; ringbuffer当前生产者cursor\n        current &#x3D; cursor.get();\n        &#x2F;&#x2F; 下一个可用的序号\n        next &#x3D; current + n;\n        &#x2F;&#x2F; 重叠点位置\n        long wrapPoint &#x3D; next - bufferSize;\n        &#x2F;&#x2F; 缓存的消费者处理的序号\n        long cachedGatingSequence &#x3D; gatingSequenceCache.get();\n        &#x2F;&#x2F; wrapPoint &gt; cachedGatingSequence,\n        &#x2F;&#x2F; 重叠位置大于缓存的消费者处理的序号，说明有消费者没有处理完成，不能够防止数据\n        &#x2F;&#x2F; cachedGatingSequence &gt; nextValue\n        &#x2F;&#x2F; 只会在https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;issues&#x2F;76情况下存在\n        if (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; current) &#123;\n            &#x2F;&#x2F; 获取消费者和生产者最小的序号\n            long gatingSequence &#x3D; Util.getMinimumSequence(gatingSequences, current);\n            &#x2F;&#x2F; 仍然重叠\n            if (wrapPoint &gt; gatingSequence) &#123;\n                &#x2F;&#x2F; 通知消费者处理事件\n                waitStrategy.signalAllWhenBlocking();\n                &#x2F;&#x2F; 生产者等待的时候后自旋，后续需要使用策略\n                LockSupport.parkNanos(1);\n                continue;\n            &#125;\n            &#x2F;&#x2F; 没有重叠的话，设置消费者缓存\n            gatingSequenceCache.set(gatingSequence);\n        &#125;\n        &#x2F;&#x2F; 没有重叠，直接将RingBuffer的序号设置成next\n        else if (cursor.compareAndSet(current, next)) &#123;\n            break;\n        &#125;\n    &#125;\n    while (true);\n    &#x2F;&#x2F; 返回可用的序号\n    return next;\n&#125;</code></pre>\n\n<h2 id=\"5、多生产者通过-publish-提交数据\"><a href=\"#5、多生产者通过-publish-提交数据\" class=\"headerlink\" title=\"5、多生产者通过 publish 提交数据\"></a>5、多生产者通过 publish 提交数据</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void publish(final long sequence) &#123;\n    &#x2F;&#x2F; 将sequence设置为可用状态\n    setAvailable(sequence);\n    &#x2F;&#x2F; 通知消费者处理事件\n    waitStrategy.signalAllWhenBlocking();\n&#125;</code></pre>\n\n<p>多生产者在获取序号 next 方法中就已经设置了 cusor，提交数据的时候是将该 sequence 设置成可用状态，才能够被消费者使用。</p>\n<h2 id=\"6、消费者消费数据\"><a href=\"#6、消费者消费数据\" class=\"headerlink\" title=\"6、消费者消费数据\"></a>6、消费者消费数据</h2><p>再回忆下 ProcessingSequenceBarrier 的 waitFor 函数，其中调用到了 sequencer.getHighestPublishedSequence(sequence,availableSequence);</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long waitFor(final long sequence)\n        throws AlertException, InterruptedException, TimeoutException &#123;\n    &#x2F;&#x2F; 检查clert异常\n    checkAlert();\n    &#x2F;&#x2F; 通过waitStrategy策略获取可用的序号,cursorSequence为当前的Sequence，dependentSequence为依赖的Sequence[]\n    long availableSequence &#x3D; waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, this);\n    &#x2F;&#x2F; 产生比预期的sequence小,可能序号被重置回老的的oldSequence值\n    &#x2F;&#x2F;可参考https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;issues&#x2F;76\n    if (availableSequence &lt;sequence) &#123;\n        return availableSequence;\n    &#125;\n    &#x2F;&#x2F; 获取最大的可用的已经发布的sequence，可能比sequence小\n    &#x2F;&#x2F; 会在多生产者中出现，当生产者1获取到序号13，生产者2获取到14；生产者1没发布，生产者2发布，会导致获取的可用序号为12，而sequence为13\n    return sequencer.getHighestPublishedSequence(sequence, availableSequence);\n&#125;</code></pre>\n\n<p>获取最大的可用的已经发布的 sequence</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long getHighestPublishedSequence(long lowerBound, long availableSequence) &#123;\n    for (long sequence &#x3D; lowerBound; sequence &lt;&#x3D; availableSequence; sequence++) &#123;\n        &#x2F;&#x2F; 判断是否可用\n        if (!isAvailable(sequence)) &#123;\n            return sequence - 1;\n        &#125;\n    &#125;\n    return availableSequence;\n&#125;</code></pre>\n\n<p>其中判断 isAvailable 通过 availableBuffer 进行判断</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean isAvailable(long sequence) &#123;\n    &#x2F;&#x2F; 计算((int) sequence) &amp; indexMask的索引index\n    int index &#x3D; calculateIndex(sequence);\n    &#x2F;&#x2F; 计算(int) (sequence &gt;&gt;&gt; indexShift) ringbuffer的slot的设置次数\n    int flag &#x3D; calculateAvailabilityFlag(sequence);\n    &#x2F;&#x2F; index在数组中的偏移量\n    long bufferAddress &#x3D; (index * SCALE) + BASE;\n    &#x2F;&#x2F; 如果和flag相等，说明可用\n    return UNSAFE.getIntVolatile(availableBuffer, bufferAddress) &#x3D;&#x3D; flag;\n&#125;</code></pre>\n\n<p>内部使用的变量如下。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; availableBuffer跟踪每个ringbuffer的slot槽的状态，是否可用\nprivate final int[] availableBuffer &#x3D; new int[bufferSize]; &#x2F;&#x2F; 初始值为-1\nprivate final int indexMask &#x3D; bufferSize - 1;\nprivate final int indexShift &#x3D; Util.log2(bufferSize);</code></pre>\n\n<p>通过以上方式就能够判断当前的 sequence 是否可用了。<br>通过在 MutiProducerSequencer 的 getHighestPublishedSequence 方法中直接返回可用的 availableSequence，通知消费者消费数据，生产者和消费者就协同起来了。</p>\n","more":"<p>上一章主要介绍了单个生产者如何向 RingBuffer 数据写入数据，如何不要让 Ring 重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作，本章主要介绍多生产者向 RingBuffer 数据写入数据。</p>\n<h2 id=\"1、多生产者-MultiProducerSequencer-申请下一个节点\"><a href=\"#1、多生产者-MultiProducerSequencer-申请下一个节点\" class=\"headerlink\" title=\"1、多生产者 MultiProducerSequencer 申请下一个节点\"></a>1、多生产者 MultiProducerSequencer 申请下一个节点</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514503-95042b3d-3223-4a11-8b63-129201a857c1.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2a2de43c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=678&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=43988&status=done&style=none&taskId=u8c23180a-f31c-4ca9-b827-e0afd2f50af&title=\" alt=\"image.png\"><br>和单生产者不同的是在 next 方法中会直接通过 cursor.compareAndSet(current, next)设置生产者的游标 cursor 的 sequence。大家很可能会问设置了生产者的游标后，没有提交数据之前，多生产者场景中消费者是否就能够获取到数据，答案是否定的，在 MultiProducerSequencer 实现的 getHighestPublishedSequence 的方法和单生产者有所区别，后面会详细讲解。</p>\n<h2 id=\"2、多生产者-MultiProducerSequencer-提交数据\"><a href=\"#2、多生产者-MultiProducerSequencer-提交数据\" class=\"headerlink\" title=\"2、多生产者 MultiProducerSequencer 提交数据\"></a>2、多生产者 MultiProducerSequencer 提交数据</h2><p>和单生产者的区别是使用 setAvailable 将数据设置成可用状态。<br>在多个生产者的场景下，还需要其他东西来追踪序号。这个序号是指当前可写入的序号。注意这和“向 RingBuffer 的游标加 1”不一样，如果你有一个以上的生产者同时在向 RingBuffer 写入，就有可能出现某些 Entry 正在被生产者写入但还没有提交的情况。<br>生产者 1 拿到序号 14，生产者 2 拿到序号 15。现在假设生产者 1 因为某些原因没有来得及提交数据。<br>生产者 2 通过 setAvailable(15)请求完成提交数据，如图所示。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514762-36299bf0-a7b3-4385-bb2e-ec274a82912d.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u38506f47&margin=%5Bobject%20Object%5D&name=image.png&originHeight=374&originWidth=983&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=54199&status=done&style=none&taskId=u670184da-248e-4801-b74b-b0b3a888803&title=\" alt=\"image.png\"><br>当这个时候消费者通过 waitFor(14)，返回的结果会为 13，不错任何事件处理。<br>当生产者 1 通过 setAvailable(14)请求完成提交数据，如图所示。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514831-75b3af6a-f08b-4905-9c3d-dbecbffec22e.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u02f3d4b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=371&originWidth=979&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=54879&status=done&style=none&taskId=u5c56fe60-3531-433e-aa86-2e6cb4e5a00&title=\" alt=\"image.png\"><br>以 BatchEventProcessor 的 run 实现会处理 14 和 15 位置上的数据，在下一次通过 waitFor(16)获取可用的数据。</p>\n<h3 id=\"3、MutiProducerSequencer-生产者类图。\"><a href=\"#3、MutiProducerSequencer-生产者类图。\" class=\"headerlink\" title=\"3、MutiProducerSequencer 生产者类图。\"></a>3、MutiProducerSequencer 生产者类图。</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648397514845-7342f6ef-c79a-4654-ba17-f600028afef9.png#clientId=u1a4fa253-2c3e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua7e57fc7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1113&originWidth=1198&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=138853&status=done&style=none&taskId=ua3ae1fa6-21bd-44fa-9fc2-82e8254c611&title=\" alt=\"image.png\"><br>MutiProducerSequencer 继承 AbstractSequencer，实现了 Sequencer 接口。<br>Sequencer 提供增加删除消费者序列，创建 SequenceBarrier，获取最小序号，和最大发布的序号。<br>Cursored 获取当前的游标。<br>Sequenced 获取当前 ringbuffer 大小，获取想一个序号，以及提交数据接口。<br>消费者和生产者之间的关联和单生产者一样，不做重复介绍。</p>\n<h4 id=\"4、多生产者通过-next-获取下一个可用的序号\"><a href=\"#4、多生产者通过-next-获取下一个可用的序号\" class=\"headerlink\" title=\"4、多生产者通过 next 获取下一个可用的序号\"></a>4、多生产者通过 next 获取下一个可用的序号</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long next(int n) &#123;\n    if (n &lt;1) &#123;\n        throw new IllegalArgumentException(&quot;n must be &gt; 0&quot;);\n    &#125;\n    long current;\n    long next;\n    do &#123;\n        &#x2F;&#x2F; ringbuffer当前生产者cursor\n        current &#x3D; cursor.get();\n        &#x2F;&#x2F; 下一个可用的序号\n        next &#x3D; current + n;\n        &#x2F;&#x2F; 重叠点位置\n        long wrapPoint &#x3D; next - bufferSize;\n        &#x2F;&#x2F; 缓存的消费者处理的序号\n        long cachedGatingSequence &#x3D; gatingSequenceCache.get();\n        &#x2F;&#x2F; wrapPoint &gt; cachedGatingSequence,\n        &#x2F;&#x2F; 重叠位置大于缓存的消费者处理的序号，说明有消费者没有处理完成，不能够防止数据\n        &#x2F;&#x2F; cachedGatingSequence &gt; nextValue\n        &#x2F;&#x2F; 只会在https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;issues&#x2F;76情况下存在\n        if (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; current) &#123;\n            &#x2F;&#x2F; 获取消费者和生产者最小的序号\n            long gatingSequence &#x3D; Util.getMinimumSequence(gatingSequences, current);\n            &#x2F;&#x2F; 仍然重叠\n            if (wrapPoint &gt; gatingSequence) &#123;\n                &#x2F;&#x2F; 通知消费者处理事件\n                waitStrategy.signalAllWhenBlocking();\n                &#x2F;&#x2F; 生产者等待的时候后自旋，后续需要使用策略\n                LockSupport.parkNanos(1);\n                continue;\n            &#125;\n            &#x2F;&#x2F; 没有重叠的话，设置消费者缓存\n            gatingSequenceCache.set(gatingSequence);\n        &#125;\n        &#x2F;&#x2F; 没有重叠，直接将RingBuffer的序号设置成next\n        else if (cursor.compareAndSet(current, next)) &#123;\n            break;\n        &#125;\n    &#125;\n    while (true);\n    &#x2F;&#x2F; 返回可用的序号\n    return next;\n&#125;</code></pre>\n\n<h2 id=\"5、多生产者通过-publish-提交数据\"><a href=\"#5、多生产者通过-publish-提交数据\" class=\"headerlink\" title=\"5、多生产者通过 publish 提交数据\"></a>5、多生产者通过 publish 提交数据</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void publish(final long sequence) &#123;\n    &#x2F;&#x2F; 将sequence设置为可用状态\n    setAvailable(sequence);\n    &#x2F;&#x2F; 通知消费者处理事件\n    waitStrategy.signalAllWhenBlocking();\n&#125;</code></pre>\n\n<p>多生产者在获取序号 next 方法中就已经设置了 cusor，提交数据的时候是将该 sequence 设置成可用状态，才能够被消费者使用。</p>\n<h2 id=\"6、消费者消费数据\"><a href=\"#6、消费者消费数据\" class=\"headerlink\" title=\"6、消费者消费数据\"></a>6、消费者消费数据</h2><p>再回忆下 ProcessingSequenceBarrier 的 waitFor 函数，其中调用到了 sequencer.getHighestPublishedSequence(sequence,availableSequence);</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long waitFor(final long sequence)\n        throws AlertException, InterruptedException, TimeoutException &#123;\n    &#x2F;&#x2F; 检查clert异常\n    checkAlert();\n    &#x2F;&#x2F; 通过waitStrategy策略获取可用的序号,cursorSequence为当前的Sequence，dependentSequence为依赖的Sequence[]\n    long availableSequence &#x3D; waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, this);\n    &#x2F;&#x2F; 产生比预期的sequence小,可能序号被重置回老的的oldSequence值\n    &#x2F;&#x2F;可参考https:&#x2F;&#x2F;github.com&#x2F;LMAX-Exchange&#x2F;disruptor&#x2F;issues&#x2F;76\n    if (availableSequence &lt;sequence) &#123;\n        return availableSequence;\n    &#125;\n    &#x2F;&#x2F; 获取最大的可用的已经发布的sequence，可能比sequence小\n    &#x2F;&#x2F; 会在多生产者中出现，当生产者1获取到序号13，生产者2获取到14；生产者1没发布，生产者2发布，会导致获取的可用序号为12，而sequence为13\n    return sequencer.getHighestPublishedSequence(sequence, availableSequence);\n&#125;</code></pre>\n\n<p>获取最大的可用的已经发布的 sequence</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long getHighestPublishedSequence(long lowerBound, long availableSequence) &#123;\n    for (long sequence &#x3D; lowerBound; sequence &lt;&#x3D; availableSequence; sequence++) &#123;\n        &#x2F;&#x2F; 判断是否可用\n        if (!isAvailable(sequence)) &#123;\n            return sequence - 1;\n        &#125;\n    &#125;\n    return availableSequence;\n&#125;</code></pre>\n\n<p>其中判断 isAvailable 通过 availableBuffer 进行判断</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean isAvailable(long sequence) &#123;\n    &#x2F;&#x2F; 计算((int) sequence) &amp; indexMask的索引index\n    int index &#x3D; calculateIndex(sequence);\n    &#x2F;&#x2F; 计算(int) (sequence &gt;&gt;&gt; indexShift) ringbuffer的slot的设置次数\n    int flag &#x3D; calculateAvailabilityFlag(sequence);\n    &#x2F;&#x2F; index在数组中的偏移量\n    long bufferAddress &#x3D; (index * SCALE) + BASE;\n    &#x2F;&#x2F; 如果和flag相等，说明可用\n    return UNSAFE.getIntVolatile(availableBuffer, bufferAddress) &#x3D;&#x3D; flag;\n&#125;</code></pre>\n\n<p>内部使用的变量如下。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; availableBuffer跟踪每个ringbuffer的slot槽的状态，是否可用\nprivate final int[] availableBuffer &#x3D; new int[bufferSize]; &#x2F;&#x2F; 初始值为-1\nprivate final int indexMask &#x3D; bufferSize - 1;\nprivate final int indexShift &#x3D; Util.log2(bufferSize);</code></pre>\n\n<p>通过以上方式就能够判断当前的 sequence 是否可用了。<br>通过在 MutiProducerSequencer 的 getHighestPublishedSequence 方法中直接返回可用的 availableSequence，通知消费者消费数据，生产者和消费者就协同起来了。</p>\n","categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]}