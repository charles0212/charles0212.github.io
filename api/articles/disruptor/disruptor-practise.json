{"title":"Disruptor（五）DSL相关实战","slug":"yuque/Disruptor（五）DSL相关实战","date":"2017-03-09T16:00:00.000Z","updated":"2022-05-15T04:19:28.490Z","comments":true,"path":"api/articles/disruptor/disruptor-practise.json","excerpt":"本文主要讲解使用 Disruptor 的DSL演示生产者和消费者的数据交换，和以往的线程间通信不同，disruptor使用消息传递的方式，通过RingBuffer进行线程间的数据传递和通信，下面分别从一对一和多对一的模型进行讲解。下面主要通过计算区间[0 ,100000000)中的所有数值相加为例子讲解Disruptor 中的 dsl 使用。1、一对一一个生产者和一个消费者之间进行数据传递，使用disruptor 主要涉及到RingBuffer 中的ValueEvent定义，ValueAdditionEventHandler消费者处理，以及生产者发布。","covers":["/images/c2.jpg"],"content":"<p>本文主要讲解使用 Disruptor 的 DSL 演示生产者和消费者的数据交换，和以往的线程间通信不同，disruptor 使用消息传递的方式，通过 RingBuffer 进行线程间的数据传递和通信，下面分别从一对一和多对一的模型进行讲解。<br>下面主要通过计算区间[0 , 100000000)中的所有数值相加为例子讲解 Disruptor 中的 dsl 使用。</p>\n<h2 id=\"1、一对一\"><a href=\"#1、一对一\" class=\"headerlink\" title=\"1、一对一\"></a>1、一对一</h2><p>一个生产者和一个消费者之间进行数据传递，使用 disruptor 主要涉及到 RingBuffer 中的 ValueEvent 定义，ValueAdditionEventHandler 消费者处理，以及生产者发布。</p>\n<h3 id=\"1-1-RingBuffer-中-ValueEvent-定义\"><a href=\"#1-1-RingBuffer-中-ValueEvent-定义\" class=\"headerlink\" title=\"1.1 RingBuffer 中 ValueEvent 定义\"></a>1.1 RingBuffer 中 ValueEvent 定义</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lmax.disruptor.charles;\n\nimport com.lmax.disruptor.EventFactory;\n\npublic final class ValueEvent &#123;\n\n    private long value;\n    public long getValue() &#123;\n        return value;\n    &#125;\n\n    public void setValue(final long value) &#123;\n        this.value &#x3D; value;\n    &#125;\n\n    public static final EventFactory&lt;ValueEvent&gt; EVENT_FACTORY &#x3D; new EventFactory&lt;ValueEvent&gt;() &#123;\n        public ValueEvent newInstance() &#123;\n            return new ValueEvent();\n        &#125;\n    &#125;;\n\n&#125;</code></pre>\n\n<h3 id=\"1-2-ValueAdditionEventHandler-消费者数据处理\"><a href=\"#1-2-ValueAdditionEventHandler-消费者数据处理\" class=\"headerlink\" title=\"1.2 ValueAdditionEventHandler 消费者数据处理\"></a>1.2 ValueAdditionEventHandler 消费者数据处理</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lmax.disruptor.charles;\n\nimport com.lmax.disruptor.EventHandler;\nimport com.lmax.disruptor.util.PaddedLong;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic final class ValueAdditionEventHandler implements EventHandler&lt;ValueEvent&gt; &#123;\n\n    private final PaddedLong value &#x3D; new PaddedLong();\n    private long count;\n    private CountDownLatch latch;\n\n    public long getValue() &#123;\n        return value.get();\n    &#125;\n\n    public void reset(final CountDownLatch latch, final long expectedCount) &#123;\n        value.set(0L);\n        this.latch &#x3D; latch;\n        count &#x3D; expectedCount;\n    &#125;\n\n    @Override\n    public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception &#123;\n        value.set(value.get() + event.getValue());\n\n        if (count &#x3D;&#x3D; sequence) &#123;\n            latch.countDown();\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n\n<p>使用 CountDownLatch 保证在处理完消费者数据后在退出，保证结果的正确性，其中 ValueAdditionEventHandler.value 为计算结果，每次增加事件中的数值。</p>\n<h3 id=\"1-3-数据发布\"><a href=\"#1-3-数据发布\" class=\"headerlink\" title=\"1.3 数据发布\"></a>1.3 数据发布</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n *\n * UniCast a series of items between 1 publisher and 1 event processor.\n *\n * +----+    +-----+\n * | P1 |---&gt;| EP1 |\n * +----+    +-----+\n *\n * Disruptor:\n * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n *              track to prevent wrap\n *              +------------------+\n *              |                  |\n *              |                  v\n * +----+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +&#x3D;&#x3D;&#x3D;&#x3D;+   +-----+\n * | P1 |---&gt;| RB |&lt;---| SB |   | EP1 |\n * +----+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +&#x3D;&#x3D;&#x3D;&#x3D;+   +-----+\n *      claim      get    ^        |\n *                        |        |\n *                        +--------+\n *                          waitFor\n *\n * P1  - Publisher 1\n * RB  - RingBuffer\n * SB  - SequenceBarrier\n * EP1 - EventProcessor 1\n *\n *&#x2F;\npublic class OneToOneDisruptor &#123;\n\n    private static int RING_BUFFER_SIZE &#x3D; 1024 * 16;\n    private static long ITERATIONS      &#x3D; 1000L * 1000L * 100L;\n\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F; 单个生产者ProducerType.SINGLE，消费者的等待策略为YieldingWaitStrategy\n        Disruptor&lt;ValueEvent&gt; disruptor &#x3D;\n                new Disruptor&lt;ValueEvent&gt;(ValueEvent.EVENT_FACTORY,\n                        RING_BUFFER_SIZE,\n                        DaemonThreadFactory.INSTANCE,\n                        ProducerType.SINGLE,\n                        new YieldingWaitStrategy());\n\n        ValueAdditionEventHandler handler &#x3D; new ValueAdditionEventHandler();\n        &#x2F;&#x2F; 设置处理者\n        disruptor.handleEventsWith(handler);\n        &#x2F;&#x2F; 启动disruptor\n        disruptor.start();\n\n        &#x2F;&#x2F; CountDownLatch是为了保证发布的数据被处理完后，才输出结果\n        CountDownLatch latch &#x3D; new CountDownLatch(1);\n        long expectedCount &#x3D; ITERATIONS - 1;\n        handler.reset(latch, expectedCount);\n\n        &#x2F;&#x2F; 生产者生产消息，暂时不用translator\n        for (int i &#x3D; 0; i &lt;ITERATIONS; i++) &#123;\n            &#x2F;&#x2F; 生产者设置数据并发布\n            long next &#x3D; disruptor.getRingBuffer().next();\n            disruptor.getRingBuffer().get(next).setValue(i);\n            disruptor.getRingBuffer().publish(next);\n        &#125;\n\n        &#x2F;&#x2F; 闭锁，等所有的发布的数据被处理完成后，向下执行\n        latch.await();\n        System.out.println(&quot;mutiProcess: &quot; + handler.getValue());\n        disruptor.shutdown();\n        &#x2F;&#x2F; 单个线程本地计算结果\n        locoalCaculate();\n    &#125;\n\n    &#x2F;**\n     * 单个线程本地计算\n     *&#x2F;\n    private static void locoalCaculate() &#123;\n        long total &#x3D; 0l;\n        for (int i &#x3D; 0; i &lt;ITERATIONS; i++) &#123;\n            total +&#x3D; i;\n        &#125;\n        System.out.println(&quot;local: &quot; + total);\n    &#125;\n\n&#125;</code></pre>\n\n<h2 id=\"2、多对一\"><a href=\"#2、多对一\" class=\"headerlink\" title=\"2、多对一\"></a>2、多对一</h2><p>多个生产者和一个消费者之间进行数据传递，和一对一不同的是，涉及到生产者 ValuePublisher 定义。和单生产者不同的时，需要让多个生产者同时工作，并且每个生产者处理其中的某个区间，在本例子中将分为 2 个区间，2 个生产者每个发布各自区间中的数据。首先看下 ValuePublisher 的定义</p>\n<h3 id=\"2-1-生产者-ValuePublisher-定义\"><a href=\"#2-1-生产者-ValuePublisher-定义\" class=\"headerlink\" title=\"2.1 生产者 ValuePublisher 定义\"></a>2.1 生产者 ValuePublisher 定义</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lmax.disruptor.charles;\n\nimport java.util.concurrent.CyclicBarrier;\n\nimport com.lmax.disruptor.RingBuffer;\n\npublic final class ValuePublisher implements Runnable &#123;\n    private final CyclicBarrier cyclicBarrier;\n    private final RingBuffer&lt;ValueEvent&gt; ringBuffer;\n    private final long start;\n    private final long end;\n\n    public ValuePublisher(\n            final CyclicBarrier cyclicBarrier,\n            final RingBuffer&lt;ValueEvent&gt; ringBuffer,\n            final long start,\n            final long end) &#123;\n        this.cyclicBarrier &#x3D; cyclicBarrier;\n        this.ringBuffer &#x3D; ringBuffer;\n        this.start &#x3D; start;\n        this.end &#x3D; end;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        try &#123;\n            cyclicBarrier.await();\n            for (long i &#x3D; start; i &lt;end; i++) &#123;\n                long sequence &#x3D; ringBuffer.next();\n                ValueEvent event &#x3D; ringBuffer.get(sequence);\n                event.setValue(i);\n                ringBuffer.publish(sequence);\n            &#125;\n        &#125; catch (Exception ex) &#123;\n            throw new RuntimeException(ex);\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n\n<p>CyclicBarrier 确保两个生产者同时生产数据，每个生产者处理[start, end)中数据的发布。</p>\n<h3 id=\"2-2-多生产者数据发布\"><a href=\"#2-2-多生产者数据发布\" class=\"headerlink\" title=\"2.2 多生产者数据发布\"></a>2.2 多生产者数据发布</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lmax.disruptor.charles;\n\nimport com.lmax.disruptor.YieldingWaitStrategy;\nimport com.lmax.disruptor.dsl.Disruptor;\nimport com.lmax.disruptor.dsl.ProducerType;\nimport com.lmax.disruptor.util.DaemonThreadFactory;\n\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.CyclicBarrier;\n\n&#x2F;**\n *\n *\n * Sequence a series of events from multiple publishers going to one event processor.\n *\n * +----+\n * | P1 |------+\n * +----+      |\n *             v\n * +----+    +-----+\n * | P2 |---&gt;| EP1 |\n * +----+    +-----+\n *\n * Disruptor:\n * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n *             track to prevent wrap\n *             +--------------------+\n *             |                    |\n *             |                    v\n * +----+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +-----+\n * | P1 |---&gt;| RB |&lt;---| SB |    | EP1 |\n * +----+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +-----+\n *             ^   get    ^         |\n * +----+      |          |         |\n * | P2 |------+          +---------+\n * +----+                   waitFor\n *\n *\n * P1  - Publisher 1\n * P2  - Publisher 2\n * RB  - RingBuffer\n * SB  - SequenceBarrier\n * EP1 - EventProcessor 1\n *\n *\n *&#x2F;\npublic class ManyToOneDisruptor &#123;\n\n    private static int RING_BUFFER_SIZE &#x3D; 1024 * 16;\n    private static long ITERATIONS      &#x3D; 1000L * 1000L * 100L;\n\n    public static void main(String[] args) throws InterruptedException, BrokenBarrierException &#123;\n\n        &#x2F;&#x2F; 单个生产者ProducerType.MULTI，消费者的等待策略为YieldingWaitStrategy\n        Disruptor&lt;ValueEvent&gt; disruptor &#x3D;\n                new Disruptor&lt;ValueEvent&gt;(ValueEvent.EVENT_FACTORY,\n                        RING_BUFFER_SIZE,\n                        DaemonThreadFactory.INSTANCE,\n                        ProducerType.MULTI,\n                        new YieldingWaitStrategy());\n\n        ValueAdditionEventHandler handler &#x3D; new ValueAdditionEventHandler();\n        &#x2F;&#x2F; 设置处理者\n        disruptor.handleEventsWith(handler);\n        &#x2F;&#x2F; 启动disruptor\n        disruptor.start();\n\n        &#x2F;&#x2F; CountDownLatch是为了保证发布的数据被处理完后，才输出结果\n        CountDownLatch latch &#x3D; new CountDownLatch(1);\n        handler.reset(latch, ITERATIONS - 1);\n\n        &#x2F;&#x2F; 保证2个生产者同时生产数据\n        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(3);\n\n        &#x2F;&#x2F; 定义生产者，以及生产的数据区间[start, end)\n        ValuePublisher publisher1 &#x3D; new ValuePublisher(cyclicBarrier,\n                disruptor.getRingBuffer(),\n                0,\n                ITERATIONS &#x2F; 2);\n        new Thread(publisher1).start();\n\n        ValuePublisher publisher2 &#x3D; new ValuePublisher(cyclicBarrier,\n                disruptor.getRingBuffer(),\n                ITERATIONS &#x2F; 2,\n                ITERATIONS);\n        new Thread(publisher2).start();\n\n        &#x2F;&#x2F; 所有的生产者线程都同时运行\n        cyclicBarrier.await();\n        &#x2F;&#x2F; 等待计算完成\n        latch.await();\n        System.out.println(&quot;mutiProcess: &quot; + handler.getValue());\n        disruptor.shutdown();\n        &#x2F;&#x2F; 单个线程本地计算\n        locoalCaculate();\n    &#125;\n\n    &#x2F;**\n     * 单个线程本地计算\n     *&#x2F;\n    private static void locoalCaculate() &#123;\n        long total &#x3D; 0l;\n        for (int i &#x3D; 0; i &lt;ITERATIONS; i++) &#123;\n            total +&#x3D; i;\n        &#125;\n        System.out.println(&quot;localProcess: &quot; + total);\n    &#125;\n\n&#125;</code></pre>\n\n<p>上面主要演示了一对一和多对一的使用，关于其他的使用方式，可以访问 <a href=\"%5Bhttps://github.com/LMAX-Exchange/disruptor%5D(https://github.com/LMAX-Exchange/disruptor)\">Disruptor</a> 进行查看其他的官方例子。</p>\n","more":"<p>本文主要讲解使用 Disruptor 的 DSL 演示生产者和消费者的数据交换，和以往的线程间通信不同，disruptor 使用消息传递的方式，通过 RingBuffer 进行线程间的数据传递和通信，下面分别从一对一和多对一的模型进行讲解。<br>下面主要通过计算区间[0 , 100000000)中的所有数值相加为例子讲解 Disruptor 中的 dsl 使用。</p>\n<h2 id=\"1、一对一\"><a href=\"#1、一对一\" class=\"headerlink\" title=\"1、一对一\"></a>1、一对一</h2><p>一个生产者和一个消费者之间进行数据传递，使用 disruptor 主要涉及到 RingBuffer 中的 ValueEvent 定义，ValueAdditionEventHandler 消费者处理，以及生产者发布。</p>\n<h3 id=\"1-1-RingBuffer-中-ValueEvent-定义\"><a href=\"#1-1-RingBuffer-中-ValueEvent-定义\" class=\"headerlink\" title=\"1.1 RingBuffer 中 ValueEvent 定义\"></a>1.1 RingBuffer 中 ValueEvent 定义</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lmax.disruptor.charles;\n\nimport com.lmax.disruptor.EventFactory;\n\npublic final class ValueEvent &#123;\n\n    private long value;\n    public long getValue() &#123;\n        return value;\n    &#125;\n\n    public void setValue(final long value) &#123;\n        this.value &#x3D; value;\n    &#125;\n\n    public static final EventFactory&lt;ValueEvent&gt; EVENT_FACTORY &#x3D; new EventFactory&lt;ValueEvent&gt;() &#123;\n        public ValueEvent newInstance() &#123;\n            return new ValueEvent();\n        &#125;\n    &#125;;\n\n&#125;</code></pre>\n\n<h3 id=\"1-2-ValueAdditionEventHandler-消费者数据处理\"><a href=\"#1-2-ValueAdditionEventHandler-消费者数据处理\" class=\"headerlink\" title=\"1.2 ValueAdditionEventHandler 消费者数据处理\"></a>1.2 ValueAdditionEventHandler 消费者数据处理</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lmax.disruptor.charles;\n\nimport com.lmax.disruptor.EventHandler;\nimport com.lmax.disruptor.util.PaddedLong;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic final class ValueAdditionEventHandler implements EventHandler&lt;ValueEvent&gt; &#123;\n\n    private final PaddedLong value &#x3D; new PaddedLong();\n    private long count;\n    private CountDownLatch latch;\n\n    public long getValue() &#123;\n        return value.get();\n    &#125;\n\n    public void reset(final CountDownLatch latch, final long expectedCount) &#123;\n        value.set(0L);\n        this.latch &#x3D; latch;\n        count &#x3D; expectedCount;\n    &#125;\n\n    @Override\n    public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception &#123;\n        value.set(value.get() + event.getValue());\n\n        if (count &#x3D;&#x3D; sequence) &#123;\n            latch.countDown();\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n\n<p>使用 CountDownLatch 保证在处理完消费者数据后在退出，保证结果的正确性，其中 ValueAdditionEventHandler.value 为计算结果，每次增加事件中的数值。</p>\n<h3 id=\"1-3-数据发布\"><a href=\"#1-3-数据发布\" class=\"headerlink\" title=\"1.3 数据发布\"></a>1.3 数据发布</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n *\n * UniCast a series of items between 1 publisher and 1 event processor.\n *\n * +----+    +-----+\n * | P1 |---&gt;| EP1 |\n * +----+    +-----+\n *\n * Disruptor:\n * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n *              track to prevent wrap\n *              +------------------+\n *              |                  |\n *              |                  v\n * +----+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +&#x3D;&#x3D;&#x3D;&#x3D;+   +-----+\n * | P1 |---&gt;| RB |&lt;---| SB |   | EP1 |\n * +----+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +&#x3D;&#x3D;&#x3D;&#x3D;+   +-----+\n *      claim      get    ^        |\n *                        |        |\n *                        +--------+\n *                          waitFor\n *\n * P1  - Publisher 1\n * RB  - RingBuffer\n * SB  - SequenceBarrier\n * EP1 - EventProcessor 1\n *\n *&#x2F;\npublic class OneToOneDisruptor &#123;\n\n    private static int RING_BUFFER_SIZE &#x3D; 1024 * 16;\n    private static long ITERATIONS      &#x3D; 1000L * 1000L * 100L;\n\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F; 单个生产者ProducerType.SINGLE，消费者的等待策略为YieldingWaitStrategy\n        Disruptor&lt;ValueEvent&gt; disruptor &#x3D;\n                new Disruptor&lt;ValueEvent&gt;(ValueEvent.EVENT_FACTORY,\n                        RING_BUFFER_SIZE,\n                        DaemonThreadFactory.INSTANCE,\n                        ProducerType.SINGLE,\n                        new YieldingWaitStrategy());\n\n        ValueAdditionEventHandler handler &#x3D; new ValueAdditionEventHandler();\n        &#x2F;&#x2F; 设置处理者\n        disruptor.handleEventsWith(handler);\n        &#x2F;&#x2F; 启动disruptor\n        disruptor.start();\n\n        &#x2F;&#x2F; CountDownLatch是为了保证发布的数据被处理完后，才输出结果\n        CountDownLatch latch &#x3D; new CountDownLatch(1);\n        long expectedCount &#x3D; ITERATIONS - 1;\n        handler.reset(latch, expectedCount);\n\n        &#x2F;&#x2F; 生产者生产消息，暂时不用translator\n        for (int i &#x3D; 0; i &lt;ITERATIONS; i++) &#123;\n            &#x2F;&#x2F; 生产者设置数据并发布\n            long next &#x3D; disruptor.getRingBuffer().next();\n            disruptor.getRingBuffer().get(next).setValue(i);\n            disruptor.getRingBuffer().publish(next);\n        &#125;\n\n        &#x2F;&#x2F; 闭锁，等所有的发布的数据被处理完成后，向下执行\n        latch.await();\n        System.out.println(&quot;mutiProcess: &quot; + handler.getValue());\n        disruptor.shutdown();\n        &#x2F;&#x2F; 单个线程本地计算结果\n        locoalCaculate();\n    &#125;\n\n    &#x2F;**\n     * 单个线程本地计算\n     *&#x2F;\n    private static void locoalCaculate() &#123;\n        long total &#x3D; 0l;\n        for (int i &#x3D; 0; i &lt;ITERATIONS; i++) &#123;\n            total +&#x3D; i;\n        &#125;\n        System.out.println(&quot;local: &quot; + total);\n    &#125;\n\n&#125;</code></pre>\n\n<h2 id=\"2、多对一\"><a href=\"#2、多对一\" class=\"headerlink\" title=\"2、多对一\"></a>2、多对一</h2><p>多个生产者和一个消费者之间进行数据传递，和一对一不同的是，涉及到生产者 ValuePublisher 定义。和单生产者不同的时，需要让多个生产者同时工作，并且每个生产者处理其中的某个区间，在本例子中将分为 2 个区间，2 个生产者每个发布各自区间中的数据。首先看下 ValuePublisher 的定义</p>\n<h3 id=\"2-1-生产者-ValuePublisher-定义\"><a href=\"#2-1-生产者-ValuePublisher-定义\" class=\"headerlink\" title=\"2.1 生产者 ValuePublisher 定义\"></a>2.1 生产者 ValuePublisher 定义</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lmax.disruptor.charles;\n\nimport java.util.concurrent.CyclicBarrier;\n\nimport com.lmax.disruptor.RingBuffer;\n\npublic final class ValuePublisher implements Runnable &#123;\n    private final CyclicBarrier cyclicBarrier;\n    private final RingBuffer&lt;ValueEvent&gt; ringBuffer;\n    private final long start;\n    private final long end;\n\n    public ValuePublisher(\n            final CyclicBarrier cyclicBarrier,\n            final RingBuffer&lt;ValueEvent&gt; ringBuffer,\n            final long start,\n            final long end) &#123;\n        this.cyclicBarrier &#x3D; cyclicBarrier;\n        this.ringBuffer &#x3D; ringBuffer;\n        this.start &#x3D; start;\n        this.end &#x3D; end;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        try &#123;\n            cyclicBarrier.await();\n            for (long i &#x3D; start; i &lt;end; i++) &#123;\n                long sequence &#x3D; ringBuffer.next();\n                ValueEvent event &#x3D; ringBuffer.get(sequence);\n                event.setValue(i);\n                ringBuffer.publish(sequence);\n            &#125;\n        &#125; catch (Exception ex) &#123;\n            throw new RuntimeException(ex);\n        &#125;\n    &#125;\n\n&#125;</code></pre>\n\n<p>CyclicBarrier 确保两个生产者同时生产数据，每个生产者处理[start, end)中数据的发布。</p>\n<h3 id=\"2-2-多生产者数据发布\"><a href=\"#2-2-多生产者数据发布\" class=\"headerlink\" title=\"2.2 多生产者数据发布\"></a>2.2 多生产者数据发布</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lmax.disruptor.charles;\n\nimport com.lmax.disruptor.YieldingWaitStrategy;\nimport com.lmax.disruptor.dsl.Disruptor;\nimport com.lmax.disruptor.dsl.ProducerType;\nimport com.lmax.disruptor.util.DaemonThreadFactory;\n\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.CyclicBarrier;\n\n&#x2F;**\n *\n *\n * Sequence a series of events from multiple publishers going to one event processor.\n *\n * +----+\n * | P1 |------+\n * +----+      |\n *             v\n * +----+    +-----+\n * | P2 |---&gt;| EP1 |\n * +----+    +-----+\n *\n * Disruptor:\n * &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n *             track to prevent wrap\n *             +--------------------+\n *             |                    |\n *             |                    v\n * +----+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +-----+\n * | P1 |---&gt;| RB |&lt;---| SB |    | EP1 |\n * +----+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +&#x3D;&#x3D;&#x3D;&#x3D;+    +-----+\n *             ^   get    ^         |\n * +----+      |          |         |\n * | P2 |------+          +---------+\n * +----+                   waitFor\n *\n *\n * P1  - Publisher 1\n * P2  - Publisher 2\n * RB  - RingBuffer\n * SB  - SequenceBarrier\n * EP1 - EventProcessor 1\n *\n *\n *&#x2F;\npublic class ManyToOneDisruptor &#123;\n\n    private static int RING_BUFFER_SIZE &#x3D; 1024 * 16;\n    private static long ITERATIONS      &#x3D; 1000L * 1000L * 100L;\n\n    public static void main(String[] args) throws InterruptedException, BrokenBarrierException &#123;\n\n        &#x2F;&#x2F; 单个生产者ProducerType.MULTI，消费者的等待策略为YieldingWaitStrategy\n        Disruptor&lt;ValueEvent&gt; disruptor &#x3D;\n                new Disruptor&lt;ValueEvent&gt;(ValueEvent.EVENT_FACTORY,\n                        RING_BUFFER_SIZE,\n                        DaemonThreadFactory.INSTANCE,\n                        ProducerType.MULTI,\n                        new YieldingWaitStrategy());\n\n        ValueAdditionEventHandler handler &#x3D; new ValueAdditionEventHandler();\n        &#x2F;&#x2F; 设置处理者\n        disruptor.handleEventsWith(handler);\n        &#x2F;&#x2F; 启动disruptor\n        disruptor.start();\n\n        &#x2F;&#x2F; CountDownLatch是为了保证发布的数据被处理完后，才输出结果\n        CountDownLatch latch &#x3D; new CountDownLatch(1);\n        handler.reset(latch, ITERATIONS - 1);\n\n        &#x2F;&#x2F; 保证2个生产者同时生产数据\n        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(3);\n\n        &#x2F;&#x2F; 定义生产者，以及生产的数据区间[start, end)\n        ValuePublisher publisher1 &#x3D; new ValuePublisher(cyclicBarrier,\n                disruptor.getRingBuffer(),\n                0,\n                ITERATIONS &#x2F; 2);\n        new Thread(publisher1).start();\n\n        ValuePublisher publisher2 &#x3D; new ValuePublisher(cyclicBarrier,\n                disruptor.getRingBuffer(),\n                ITERATIONS &#x2F; 2,\n                ITERATIONS);\n        new Thread(publisher2).start();\n\n        &#x2F;&#x2F; 所有的生产者线程都同时运行\n        cyclicBarrier.await();\n        &#x2F;&#x2F; 等待计算完成\n        latch.await();\n        System.out.println(&quot;mutiProcess: &quot; + handler.getValue());\n        disruptor.shutdown();\n        &#x2F;&#x2F; 单个线程本地计算\n        locoalCaculate();\n    &#125;\n\n    &#x2F;**\n     * 单个线程本地计算\n     *&#x2F;\n    private static void locoalCaculate() &#123;\n        long total &#x3D; 0l;\n        for (int i &#x3D; 0; i &lt;ITERATIONS; i++) &#123;\n            total +&#x3D; i;\n        &#125;\n        System.out.println(&quot;localProcess: &quot; + total);\n    &#125;\n\n&#125;</code></pre>\n\n<p>上面主要演示了一对一和多对一的使用，关于其他的使用方式，可以访问 <a href=\"%5Bhttps://github.com/LMAX-Exchange/disruptor%5D(https://github.com/LMAX-Exchange/disruptor)\">Disruptor</a> 进行查看其他的官方例子。</p>\n","categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]}