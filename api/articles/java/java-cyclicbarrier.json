{"title":"Java锁（五）CyclicBarrier分析","slug":"yuque/Java锁（五）CyclicBarrier分析","date":"2015-02-07T16:00:00.000Z","updated":"2022-05-15T04:19:28.499Z","comments":true,"path":"api/articles/java/java-cyclicbarrier.json","excerpt":"CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(intparties)，其参数表示屏障拦截的线程数量，每个线程调用await 方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。1、CyclicBarrier 使用实例public class CyclicBarrierTest {    stati","covers":["/images/c1.jpg"],"content":"<p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p>\n<h2 id=\"1、CyclicBarrier-使用实例\"><a href=\"#1、CyclicBarrier-使用实例\" class=\"headerlink\" title=\"1、CyclicBarrier 使用实例\"></a>1、CyclicBarrier 使用实例</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CyclicBarrierTest &#123;\n    static CyclicBarrier c &#x3D; new CyclicBarrier(2);\n    public static void main(String[] args) &#123;\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    c.await();\n                &#125; catch (Exception e) &#123;\n                &#125;\n                System.out.println(1);\n            &#125;\n        &#125;).start();\n        try &#123;\n            c.await();\n        &#125; catch (Exception e) &#123;\n        &#125;\n        System.out.println(2);\n    &#125;\n&#125;</code></pre>\n\n<p>输出 1,2 或者 2,1<br>如果把 new CyclicBarrier(2)修改成 new CyclicBarrier(3)则主线程和子线程会永远等待，因为没有第三个线程执行 await 方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。<br>CyclicBarrier 还提供一个更高级的构造函数 CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景。代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CyclicBarrierTest2 &#123;\n    static CyclicBarrier c &#x3D; new CyclicBarrier(2, new A());\n    public static void main(String[] args) &#123;\n        new Thread(new Runnable() &#123;\n\n            @Override\n            public void run() &#123;\n                try &#123;\n                    c.await();\n                &#125; catch (Exception e) &#123;\n\n                &#125;\n                System.out.println(1);\n            &#125;\n        &#125;).start();\n\n        try &#123;\n            c.await();\n        &#125; catch (Exception e) &#123;\n\n        &#125;\n        System.out.println(2);\n    &#125;\n\n    static class A implements Runnable &#123;\n\n        @Override\n        public void run() &#123;\n            System.out.println(3);\n        &#125;\n\n    &#125;\n&#125;</code></pre>\n\n<p>输出 1、3、2</p>\n<h2 id=\"2、CyclicBarrier-源码分析\"><a href=\"#2、CyclicBarrier-源码分析\" class=\"headerlink\" title=\"2、CyclicBarrier 源码分析\"></a>2、CyclicBarrier 源码分析</h2><p>CyclicBarrier 底层是基于 ReentrantLock、AbstractQueuedSynchronizer，ConditionObject 来实现的，实现相对比较简单。了解前面的 ReentrantLock，对 AQS 的分析中已经指出了其数据结构，在这里不再累赘。<br>CyclicBarrier 的几个标志性的成员变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 循环栅栏的当前代\n *&#x2F;\nprivate static class Generation &#123;\n    boolean broken &#x3D; false;\n&#125;\n\n&#x2F;** 屏障的重入锁 *&#x2F;\nprivate final ReentrantLock lock &#x3D; new ReentrantLock();\n&#x2F;** 等待状态直到触发*&#x2F;\nprivate final Condition trip &#x3D; lock.newCondition();\n&#x2F;**  parties 数量 *&#x2F;\nprivate final int parties;\n&#x2F;** 到达屏障时先触发的操作 *&#x2F;\nprivate final Runnable barrierCommand;\n\n&#x2F;** 一个generation对象代表一代的屏障，\n * 就是说，如果generation对象不同，就代表进入了下一次的屏障，\n * 所以说，这个线程屏障是可循环的(Cyclic)\n *&#x2F;\nprivate Generation generation &#x3D; new Generation();\n\n&#x2F;**\n * count是计数器，如果有线程到达了屏障点，count就减1；\n * 直到count&#x3D;0时，其它线程才可以向下执行\n *&#x2F;\nprivate int count;</code></pre>\n\n<p>线程等待所有线程到达，触发栅栏</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int await() throws InterruptedException, BrokenBarrierException &#123;\n    try &#123;\n        return dowait(false, 0L);\n    &#125; catch (TimeoutException toe) &#123;\n        throw new Error(toe); &#x2F;&#x2F; cannot happen\n    &#125;\n&#125;\n\n&#x2F;**\n * 主要屏障代码，负责各种策略\n *&#x2F;\nprivate int dowait(boolean timed, long nanos)\n    throws InterruptedException, BrokenBarrierException,\n           TimeoutException &#123;\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n        &#x2F;&#x2F; 获取屏障的当前代信息\n        final Generation g &#x3D; generation;\n\n        if (g.broken)\n            throw new BrokenBarrierException();\n\n        &#x2F;&#x2F; 线程中断，中断屏障\n        if (Thread.interrupted()) &#123;\n            breakBarrier();\n            throw new InterruptedException();\n        &#125;\n\n        &#x2F;&#x2F; count-1，到达0的时候，所有的线程向下执行\n        int index &#x3D; --count;\n        if (index &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 触发屏障的栅栏\n            boolean ranAction &#x3D; false;\n            try &#123;\n                &#x2F;&#x2F; 如果设置了barrierCommand，优先执行\n                final Runnable command &#x3D; barrierCommand;\n                if (command !&#x3D; null)\n                    command.run();\n                ranAction &#x3D; true;\n                &#x2F;&#x2F; 所有线程都到的屏障点\n                &#x2F;&#x2F; 更新屏障状态，唤醒其他线程，生成下一代屏障\n                nextGeneration();\n                return 0;\n            &#125; finally &#123;\n                if (!ranAction)\n                    breakBarrier();\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 循环直到触发屏障栅栏，或者中断，超时\n        for (;;) &#123;\n            try &#123;\n                if (!timed)\n                    trip.await();\n                else if (nanos &gt; 0L)\n                    nanos &#x3D; trip.awaitNanos(nanos);\n            &#125; catch (InterruptedException ie) &#123;\n                &#x2F;&#x2F; 被中断，设置栅栏中断标志\n                if (g &#x3D;&#x3D; generation &amp;&amp; ! g.broken) &#123;\n                    &#x2F;&#x2F; 设置broken中断标示\n                    breakBarrier();\n                    throw ie;\n                &#125; else &#123;\n                    &#x2F;&#x2F; We&#39;re about to finish waiting even if we had not\n                    &#x2F;&#x2F; been interrupted, so this interrupt is deemed to\n                    &#x2F;&#x2F; &quot;belong&quot; to subsequent execution.\n                    Thread.currentThread().interrupt();\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 屏障被中断，抛出异常\n            if (g.broken)\n                throw new BrokenBarrierException();\n\n            &#x2F;&#x2F; 不是栅栏的当前代（所有线程都到达，已经生成下一代的generation）\n            if (g !&#x3D; generation)\n                return index;\n\n            &#x2F;&#x2F; 超时后，中断屏障\n            if (timed &amp;&amp; nanos &lt;&#x3D; 0L) &#123;\n                breakBarrier();\n                throw new TimeoutException();\n            &#125;\n        &#125;\n    &#125; finally &#123;\n        lock.unlock();\n    &#125;\n&#125;\n\n&#x2F;**\n * 中断屏障，唤醒其他线程\n *&#x2F;\nprivate void breakBarrier() &#123;\n    generation.broken &#x3D; true;\n    count &#x3D; parties;\n    trip.signalAll();\n&#125;\n\n&#x2F;**\n * 更新屏障状态，唤醒其他线程，生成下一代屏障\n *&#x2F;\nprivate void nextGeneration() &#123;\n    &#x2F;&#x2F; signal completion of last generation\n    trip.signalAll();\n    &#x2F;&#x2F; set up next generation\n    count &#x3D; parties;\n    generation &#x3D; new Generation();\n&#125;</code></pre>\n\n<h2 id=\"3、CyclicBarrier-和-CountDownLatch-的区别\"><a href=\"#3、CyclicBarrier-和-CountDownLatch-的区别\" class=\"headerlink\" title=\"3、CyclicBarrier 和 CountDownLatch 的区别\"></a>3、CyclicBarrier 和 CountDownLatch 的区别</h2><p>CountDownLatch 的计数器只能使用一次。而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。<br>CyclicBarrier 还提供其他有用的方法，比如 getNumberWaiting 方法可以获得 CyclicBarrier 阻塞的线程数量。isBroken 方法用来知道阻塞的线程是否被中断。</p>\n<h2 id=\"4、CyclicBarrier-的应用场景\"><a href=\"#4、CyclicBarrier-的应用场景\" class=\"headerlink\" title=\"4、CyclicBarrier 的应用场景\"></a>4、CyclicBarrier 的应用场景</h2><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>\n","more":"<p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p>\n<h2 id=\"1、CyclicBarrier-使用实例\"><a href=\"#1、CyclicBarrier-使用实例\" class=\"headerlink\" title=\"1、CyclicBarrier 使用实例\"></a>1、CyclicBarrier 使用实例</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CyclicBarrierTest &#123;\n    static CyclicBarrier c &#x3D; new CyclicBarrier(2);\n    public static void main(String[] args) &#123;\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    c.await();\n                &#125; catch (Exception e) &#123;\n                &#125;\n                System.out.println(1);\n            &#125;\n        &#125;).start();\n        try &#123;\n            c.await();\n        &#125; catch (Exception e) &#123;\n        &#125;\n        System.out.println(2);\n    &#125;\n&#125;</code></pre>\n\n<p>输出 1,2 或者 2,1<br>如果把 new CyclicBarrier(2)修改成 new CyclicBarrier(3)则主线程和子线程会永远等待，因为没有第三个线程执行 await 方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。<br>CyclicBarrier 还提供一个更高级的构造函数 CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景。代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CyclicBarrierTest2 &#123;\n    static CyclicBarrier c &#x3D; new CyclicBarrier(2, new A());\n    public static void main(String[] args) &#123;\n        new Thread(new Runnable() &#123;\n\n            @Override\n            public void run() &#123;\n                try &#123;\n                    c.await();\n                &#125; catch (Exception e) &#123;\n\n                &#125;\n                System.out.println(1);\n            &#125;\n        &#125;).start();\n\n        try &#123;\n            c.await();\n        &#125; catch (Exception e) &#123;\n\n        &#125;\n        System.out.println(2);\n    &#125;\n\n    static class A implements Runnable &#123;\n\n        @Override\n        public void run() &#123;\n            System.out.println(3);\n        &#125;\n\n    &#125;\n&#125;</code></pre>\n\n<p>输出 1、3、2</p>\n<h2 id=\"2、CyclicBarrier-源码分析\"><a href=\"#2、CyclicBarrier-源码分析\" class=\"headerlink\" title=\"2、CyclicBarrier 源码分析\"></a>2、CyclicBarrier 源码分析</h2><p>CyclicBarrier 底层是基于 ReentrantLock、AbstractQueuedSynchronizer，ConditionObject 来实现的，实现相对比较简单。了解前面的 ReentrantLock，对 AQS 的分析中已经指出了其数据结构，在这里不再累赘。<br>CyclicBarrier 的几个标志性的成员变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 循环栅栏的当前代\n *&#x2F;\nprivate static class Generation &#123;\n    boolean broken &#x3D; false;\n&#125;\n\n&#x2F;** 屏障的重入锁 *&#x2F;\nprivate final ReentrantLock lock &#x3D; new ReentrantLock();\n&#x2F;** 等待状态直到触发*&#x2F;\nprivate final Condition trip &#x3D; lock.newCondition();\n&#x2F;**  parties 数量 *&#x2F;\nprivate final int parties;\n&#x2F;** 到达屏障时先触发的操作 *&#x2F;\nprivate final Runnable barrierCommand;\n\n&#x2F;** 一个generation对象代表一代的屏障，\n * 就是说，如果generation对象不同，就代表进入了下一次的屏障，\n * 所以说，这个线程屏障是可循环的(Cyclic)\n *&#x2F;\nprivate Generation generation &#x3D; new Generation();\n\n&#x2F;**\n * count是计数器，如果有线程到达了屏障点，count就减1；\n * 直到count&#x3D;0时，其它线程才可以向下执行\n *&#x2F;\nprivate int count;</code></pre>\n\n<p>线程等待所有线程到达，触发栅栏</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int await() throws InterruptedException, BrokenBarrierException &#123;\n    try &#123;\n        return dowait(false, 0L);\n    &#125; catch (TimeoutException toe) &#123;\n        throw new Error(toe); &#x2F;&#x2F; cannot happen\n    &#125;\n&#125;\n\n&#x2F;**\n * 主要屏障代码，负责各种策略\n *&#x2F;\nprivate int dowait(boolean timed, long nanos)\n    throws InterruptedException, BrokenBarrierException,\n           TimeoutException &#123;\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n        &#x2F;&#x2F; 获取屏障的当前代信息\n        final Generation g &#x3D; generation;\n\n        if (g.broken)\n            throw new BrokenBarrierException();\n\n        &#x2F;&#x2F; 线程中断，中断屏障\n        if (Thread.interrupted()) &#123;\n            breakBarrier();\n            throw new InterruptedException();\n        &#125;\n\n        &#x2F;&#x2F; count-1，到达0的时候，所有的线程向下执行\n        int index &#x3D; --count;\n        if (index &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 触发屏障的栅栏\n            boolean ranAction &#x3D; false;\n            try &#123;\n                &#x2F;&#x2F; 如果设置了barrierCommand，优先执行\n                final Runnable command &#x3D; barrierCommand;\n                if (command !&#x3D; null)\n                    command.run();\n                ranAction &#x3D; true;\n                &#x2F;&#x2F; 所有线程都到的屏障点\n                &#x2F;&#x2F; 更新屏障状态，唤醒其他线程，生成下一代屏障\n                nextGeneration();\n                return 0;\n            &#125; finally &#123;\n                if (!ranAction)\n                    breakBarrier();\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 循环直到触发屏障栅栏，或者中断，超时\n        for (;;) &#123;\n            try &#123;\n                if (!timed)\n                    trip.await();\n                else if (nanos &gt; 0L)\n                    nanos &#x3D; trip.awaitNanos(nanos);\n            &#125; catch (InterruptedException ie) &#123;\n                &#x2F;&#x2F; 被中断，设置栅栏中断标志\n                if (g &#x3D;&#x3D; generation &amp;&amp; ! g.broken) &#123;\n                    &#x2F;&#x2F; 设置broken中断标示\n                    breakBarrier();\n                    throw ie;\n                &#125; else &#123;\n                    &#x2F;&#x2F; We&#39;re about to finish waiting even if we had not\n                    &#x2F;&#x2F; been interrupted, so this interrupt is deemed to\n                    &#x2F;&#x2F; &quot;belong&quot; to subsequent execution.\n                    Thread.currentThread().interrupt();\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F; 屏障被中断，抛出异常\n            if (g.broken)\n                throw new BrokenBarrierException();\n\n            &#x2F;&#x2F; 不是栅栏的当前代（所有线程都到达，已经生成下一代的generation）\n            if (g !&#x3D; generation)\n                return index;\n\n            &#x2F;&#x2F; 超时后，中断屏障\n            if (timed &amp;&amp; nanos &lt;&#x3D; 0L) &#123;\n                breakBarrier();\n                throw new TimeoutException();\n            &#125;\n        &#125;\n    &#125; finally &#123;\n        lock.unlock();\n    &#125;\n&#125;\n\n&#x2F;**\n * 中断屏障，唤醒其他线程\n *&#x2F;\nprivate void breakBarrier() &#123;\n    generation.broken &#x3D; true;\n    count &#x3D; parties;\n    trip.signalAll();\n&#125;\n\n&#x2F;**\n * 更新屏障状态，唤醒其他线程，生成下一代屏障\n *&#x2F;\nprivate void nextGeneration() &#123;\n    &#x2F;&#x2F; signal completion of last generation\n    trip.signalAll();\n    &#x2F;&#x2F; set up next generation\n    count &#x3D; parties;\n    generation &#x3D; new Generation();\n&#125;</code></pre>\n\n<h2 id=\"3、CyclicBarrier-和-CountDownLatch-的区别\"><a href=\"#3、CyclicBarrier-和-CountDownLatch-的区别\" class=\"headerlink\" title=\"3、CyclicBarrier 和 CountDownLatch 的区别\"></a>3、CyclicBarrier 和 CountDownLatch 的区别</h2><p>CountDownLatch 的计数器只能使用一次。而 CyclicBarrier 的计数器可以使用 reset() 方法重置。所以 CyclicBarrier 能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。<br>CyclicBarrier 还提供其他有用的方法，比如 getNumberWaiting 方法可以获得 CyclicBarrier 阻塞的线程数量。isBroken 方法用来知道阻塞的线程是否被中断。</p>\n<h2 id=\"4、CyclicBarrier-的应用场景\"><a href=\"#4、CyclicBarrier-的应用场景\" class=\"headerlink\" title=\"4、CyclicBarrier 的应用场景\"></a>4、CyclicBarrier 的应用场景</h2><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>\n","categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]}