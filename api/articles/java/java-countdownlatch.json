{"title":"Java锁（三）CountDownLatch共享锁分析","slug":"yuque/Java锁（三）CountDownLatch共享锁分析","date":"2015-02-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.499Z","comments":true,"path":"api/articles/java/java-countdownlatch.json","excerpt":"> 在开始解读 AQS> 的共享功能前，我们再重温一下> CountDownLatch，CountDownLatch> 为> java.util.concurrent> 包下的计数器工具类，常被用在多线程环境下，它在初始时需要指定一个计数器的大小，然后可被多个线程并发的实现减> 1 操作，并在计数器为 0 后调用> await> 方法的线程被唤醒，从而实现多线程间的协作。1、闭锁使用class Driver2 {    void main() throws InterruptedException {        CountDownLatch doneSigna","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1649589997355-2e0d2412-8dc4-43b5-926e-a0cae309882c.png#clientId=u825d69b5-2259-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf9bcf6fb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=115&originWidth=315&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=6006&status=done&style=none&taskId=u1bb122c2-e3b3-4fef-b74e-4ba54abb8ae&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1649589997397-74fdd3d7-a0f1-4993-9f49-71bb562eb720.png#clientId=u825d69b5-2259-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4cee9eb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=559&originWidth=690&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=53782&status=done&style=none&taskId=u06589832-a1c2-43c5-b5b0-4ace8d7b61c&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1649589997367-5ebefbf7-8bc8-4d93-9d39-f00f3ce8e61b.png#clientId=u825d69b5-2259-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubd30420a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=744&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57023&status=done&style=none&taskId=u26f46c5e-d54d-415b-a2ec-e3fe596ff8f&title="],"content":"<blockquote>\n<p>在开始解读 AQS 的共享功能前，我们再重温一下 CountDownLatch，CountDownLatch 为 java.util.concurrent 包下的计数器工具类，常被用在多线程环境下，它在初始时需要指定一个计数器的大小，然后可被多个线程并发的实现减 1 操作，并在计数器为 0 后调用 await 方法的线程被唤醒，从而实现多线程间的协作。</p>\n</blockquote>\n<h2 id=\"1、闭锁使用\"><a href=\"#1、闭锁使用\" class=\"headerlink\" title=\"1、闭锁使用\"></a>1、闭锁使用</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Driver2 &#123;\n    void main() throws InterruptedException &#123;\n        CountDownLatch doneSignal &#x3D; new CountDownLatch(N);\n        Executor e &#x3D; ...\n\n        for (int i &#x3D; 0; i &lt;N; ++i) &#x2F;&#x2F; create and start threads\n        e.execute(new WorkerRunnable(doneSignal, i));\n        doneSignal.await(); &#x2F;&#x2F; wait for all to finish\n    &#125;\n&#125;\n\nclass WorkerRunnable implements Runnable &#123;\n  private final CountDownLatch doneSignal;\n  private final int i;\n  WorkerRunnable(CountDownLatch doneSignal, int i) &#123;\n    this.doneSignal &#x3D; doneSignal;\n    this.i &#x3D; i;\n  &#125;\n  public void run() &#123;\n    try &#123;\n      doWork(i);\n      doneSignal.countDown();\n    &#125; catch (InterruptedException ex) &#123;&#125; &#x2F;&#x2F; return;\n  &#125;\n\n  void doWork() &#123; ... &#125;\n&#125;</code></pre>\n\n<p>可以看到 CountDownLatch 的作用类似于一个“栏栅”，在 CountDownLatch 的计数为 0 前，调用 await 方法的线程将一直阻塞，直到 CountDownLatch 计数为 0，await 方法才会返回，而 CountDownLatch 的 countDown()方法则一般由各个线程调用，实现 CountDownLatch 计数的减 1。<br>首先，看下 CountDownLatch 的构造方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public CountDownLatch(int count) &#123;\n    if (count &lt;0) throw new IllegalArgumentException(&quot;count &lt;0&quot;);\n    this.sync &#x3D; new Sync(count);\n&#125;</code></pre>\n\n<p>和 ReentrantLock 类似，CountDownLatch 内部也有一个叫做 Sync 的内部类，同样也是用它继承了 AQS，子类需要实现 AQS 的 5 个保护方法。</p>\n<h2 id=\"2、state-状态位\"><a href=\"#2、state-状态位\" class=\"headerlink\" title=\"2、state 状态位\"></a>2、state 状态位</h2><p>对于共享锁，需要实现 tryAcquireShared，tryReleaseShared 这 2 个方法。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649589997355-2e0d2412-8dc4-43b5-926e-a0cae309882c.png#clientId=u825d69b5-2259-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf9bcf6fb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=115&originWidth=315&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=6006&status=done&style=none&taskId=u1bb122c2-e3b3-4fef-b74e-4ba54abb8ae&title=\" alt=\"image.png\"><br>setState 方法设定的 state 是 AQS 的一个“状态位”，在不同的场景下，代表不同的含义，比如在 ReentrantLock 中，表示加锁的次数，在 CountDownLatch 中，则表示 CountDownLatch 的计数器的初始大小，任务分为 N 个子线程去执行，同步状态 state 也初始化为 N。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1650856861668-cac26f1c-272f-4b62-99cc-25f3cd132a03.png#clientId=u905e4a7c-27fa-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u59b97447&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=549&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=23052&status=done&style=none&taskId=uad9217c4-28a6-4be9-9569-180ab830a7d&title=\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final class Sync extends AbstractQueuedSynchronizer &#123;\n    private static final long serialVersionUID &#x3D; 4982264981922014374L;\n\n    Sync(int count) &#123;\n        setState(count);\n    &#125;\n\n    int getCount() &#123;\n        return getState();\n    &#125;\n\n    protected int tryAcquireShared(int acquires) &#123;\n        return (getState() &#x3D;&#x3D; 0) ? 1 : -1;\n    &#125;\n\n    protected boolean tryReleaseShared(int releases) &#123;\n        &#x2F;&#x2F; Decrement count; signal when transition to zero\n        for (;;) &#123;\n            int c &#x3D; getState();\n            if (c &#x3D;&#x3D; 0)\n                return false;\n            int nextc &#x3D; c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc &#x3D;&#x3D; 0;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>设置完计数器大小后 CountDownLatch 的构造方法返回，下面我们再看下 CountDownLatch 的 await()方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void await() throws InterruptedException &#123;\n    sync.acquireSharedInterruptibly(1);\n&#125;</code></pre>\n\n<p>调用了 Sync 的 acquireSharedInterruptibly 方法，因为 Sync 是 AQS 子类的原因，这里其实是直接调用了 AQS 的 acquireSharedInterruptibly 方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException &#123;\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (tryAcquireShared(arg) &lt;0)\n        doAcquireSharedInterruptibly(arg);\n&#125;</code></pre>\n\n<p>这个方法的调用是响应线程的打断的，所以在前两行会检查下线程是否被打断。接着，尝试着获取共享锁，小于 0，表示获取失败，AQS 在获取锁的思路是，先尝试直接获取锁，如果失败会将当前线程放在队列中，按照 FIFO 的原则等待锁。而对于共享锁也是这个思路，如果和独占锁一致，这里的 tryAcquireShared 应该是个空方法，留给子类去判断。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected int tryAcquireShared(int acquires) &#123;\n    return (getState() &#x3D;&#x3D; 0) ? 1 : -1;\n&#125;</code></pre>\n\n<p>如果 state 变成 0 了，则返回 1，表示获取成功，否则返回-1 则表示获取失败。</p>\n<h2 id=\"3、获取锁\"><a href=\"#3、获取锁\" class=\"headerlink\" title=\"3、获取锁\"></a>3、获取锁</h2><p>看到这里，读者可能会发现，await 方法的获取方式更像是在获取一个独占锁，那为什么这里还会用 tryAcquireShared 呢？<br>回想下 CountDownLatch 的 await 方法是不是只能在主线程中调用？答案是否定的，CountDownLatch 的 await 方法可以在多个线程中调用，当 CountDownLatch 的计数器为 0 后，调用 await 的方法都会依次返回。 也就是说可以多个线程同时在等待 await 方法返回，所以它被设计成了实现 tryAcquireShared 方法，获取的是一个共享锁，锁在所有调用 await 方法的线程间共享，所以叫共享锁。<br>如果获取共享锁失败（返回了-1，说明 state 不为 0，也就是 CountDownLatch 的计数器还不为 0），进入调用 doAcquireSharedInterruptibly 方法中，按照我们上述的猜想，应该是要将当前线程放入到队列中去。<br>在这之前，我们再回顾一下 AQS 队列的数据结构：AQS 是一个双向链表，通过节点中的 next，pre 变量分别指向当前节点后一个节点和前一个节点。其中，每个节点中都包含了一个线程和一个类型变量：表示当前节点是独占节点还是共享节点，头节点中的线程为正在占有锁的线程，而后的所有节点的线程表示为正在等待获取锁的线程。<br>黄色节点为头节点，表示正在获取锁的节点，剩下的蓝色节点（Node1、Node2、Node3）为正在等待锁的节点，他们通过各自的 next、pre 变量分别指向前后节点，形成了 AQS 中的双向链表。每个线程被加上类型（共享还是独占）后便是一个 Node， 也就是本文中说的节点。<br>回到 acquireSharedInterruptibly 方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 在中断模式下获取共享锁\n * @param arg the acquire argument\n *&#x2F;\nprivate void doAcquireSharedInterruptibly(int arg)\n    throws InterruptedException &#123;\n    &#x2F;* 类型为Node.SHARED，标示为共享节点。*&#x2F;\n    final Node node &#x3D; addWaiter(Node.SHARED);\n    boolean failed &#x3D; true;\n    try &#123;\n        for (;;) &#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head) &#123;\n                &#x2F;* 头节点获取共享锁 *&#x2F;\n                int r &#x3D; tryAcquireShared(arg);\n                if (r &gt;&#x3D; 0) &#123;\n                    setHeadAndPropagate(node, r);\n                    p.next &#x3D; null; &#x2F;&#x2F; help GC\n                    failed &#x3D; false;\n                    return;\n                &#125;\n            &#125;\n            &#x2F;* 阻塞并判断是否打断，其实这个判断才是自旋锁真正的猥琐点，\n             * 意思是如果你的前继节点不是head,\n             * 而且当你的前继节点状态是Node.SIGNAL时，\n             * 你这个线程将被park()，\n             * 直到另外的线程release时,发现head.next是你这个node时，才unpark，\n             * 才能继续循环并获取锁\n             *&#x2F;\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        &#125;\n    &#125; finally &#123;\n        if (failed)\n            cancelAcquire(node);\n    &#125;\n&#125;</code></pre>\n\n<p>使用了 CAS 更换了头节点，然后，将当前节点的下一个节点取出来，如果同样是“shared”类型的，再做一个”releaseShared”操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 设置队列head节点，检查后继节点是否在共享模式下等待，\n * 如果propagate &gt; 0 或者 节点PROPAGATE状态被设置，状态传播，\n *&#x2F;\nprivate void setHeadAndPropagate(Node node, int propagate) &#123;\n    Node h &#x3D; head; &#x2F;&#x2F; 记录老的头节点\n    setHead(node);\n    &#x2F;*\n     * 如果传播propagate被调用者caller标示，或者被前一次操作记录\n     * 并且下一个节点在共享模式等待，或者为null，\n     * 尝试信号通知队列下一个节点\n     *&#x2F;\n    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt;0 ||\n        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt;0) &#123;\n        Node s &#x3D; node.next;\n        if (s &#x3D;&#x3D; null || s.isShared())\n            &#x2F;* 共享模式下的释放动作，信号通知后继节点，保证状态传递 *&#x2F;\n            doReleaseShared();\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649589997397-74fdd3d7-a0f1-4993-9f49-71bb562eb720.png#clientId=u825d69b5-2259-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4cee9eb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=559&originWidth=690&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=53782&status=done&style=none&taskId=u06589832-a1c2-43c5-b5b0-4ace8d7b61c&title=\" alt=\"image.png\"></p>\n<h2 id=\"4、释放锁\"><a href=\"#4、释放锁\" class=\"headerlink\" title=\"4、释放锁\"></a>4、释放锁</h2><p>看完 await 方法，我们再来看下 countDown()方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void countDown() &#123;\n    sync.releaseShared(1);\n&#125;\n\n&#x2F;**\n * Releases in shared mode. Implemented by unblocking one or more\n * threads if &#123;@link &#x3D;tryReleaseShared&#125; returns true.\n*&#x2F;\npublic final boolean releaseShared(int arg) &#123;\n    if (tryReleaseShared(arg)) &#123;\n        doReleaseShared();\n        return true;\n    &#125;\n    return false;\n&#125;\n\nprotected boolean tryReleaseShared(int releases) &#123;\n    &#x2F;&#x2F; Decrement count; signal when transition to zero\n    for (;;) &#123;\n        int c &#x3D; getState();\n        if (c &#x3D;&#x3D; 0)\n            return false;\n        int nextc &#x3D; c-1;\n        if (compareAndSetState(c, nextc))\n            return nextc &#x3D;&#x3D; 0;\n    &#125;\n&#125;\n\n&#x2F;**\n * 共享模式下的释放动作，信号通知后继节点，保证状态传递\n *&#x2F;\nprivate void doReleaseShared() &#123;\n    &#x2F;*\n     * 确保释放状态的传播，即使有其他在进行中的acquires&#x2F;releases操作的情况下。\n     * 如果节点需要等待信号，用常用的方式，\n     * 尝试unparkSuccessor将head节点的后继unpark\n     * 否则状态被设置成PROPAGATE，来保证在释放的时候，传播能够继续。\n     * 另外，当执行这个操作的时候，必须循环，防止新的节点被增加，\n     * 此外，不像其他使用unparkSuccessor，我们需要知道CAS是否重置状态失败，\n     * 如果失败重新检查。\n     *&#x2F;\n    for (;;) &#123;\n        Node h &#x3D; head;\n        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;\n            int ws &#x3D; h.waitStatus;\n            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;\n                &#x2F;* 如果当前节点是SIGNAL意味着，它正在等待一个信号，\n                 * 或者说，它在等待被唤醒，因此做两件事，\n                 * 1是重置waitStatus标志位，2是重置成功后,唤醒下一个节点。\n                 *&#x2F;\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            &#x2F;&#x2F; loop to recheck cases\n                unparkSuccessor(h);\n            &#125;\n            else if (ws &#x3D;&#x3D; 0 &amp;&amp;!compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                &#x2F;* 如果本身头节点的waitStatus是出于重置状态（waitStatus&#x3D;&#x3D;0）的，\n                 * 将其设置为“传播”状态。\n                 * 意味着需要将状态向后一个节点传播。\n                 *&#x2F;\n                continue;                &#x2F;&#x2F; loop on failed CAS &#125;\n        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed\n            break;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649589997367-5ebefbf7-8bc8-4d93-9d39-f00f3ce8e61b.png#clientId=u825d69b5-2259-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubd30420a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=744&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57023&status=done&style=none&taskId=u26f46c5e-d54d-415b-a2ec-e3fe596ff8f&title=\" alt=\"image.png\"><br>闭锁 CountdownLatch 总结</p>\n<ol>\n<li>与 AQS 的独占功能一样，共享锁是否可以被获取的判断为空方法，交由子类去实现。</li>\n<li>与 AQS 的独占功能不同，当共享锁被头节点获取后，独占功能是只有头节点获取锁，其余节点的线程继续沉睡，等待锁被释放后，才会唤醒下一个节点的线程，而共享功能是只要头节点获取锁成功，就在唤醒自身节点对应的线程的同时，继续唤醒 AQS 队列中的下一个节点的线程，每个节点在唤醒自身的同时还会唤醒下一个节点对应的线程，以实现共享状态的“向后传播”，从而实现共享功能。</li>\n</ol>\n","more":"<blockquote>\n<p>在开始解读 AQS 的共享功能前，我们再重温一下 CountDownLatch，CountDownLatch 为 java.util.concurrent 包下的计数器工具类，常被用在多线程环境下，它在初始时需要指定一个计数器的大小，然后可被多个线程并发的实现减 1 操作，并在计数器为 0 后调用 await 方法的线程被唤醒，从而实现多线程间的协作。</p>\n</blockquote>\n<h2 id=\"1、闭锁使用\"><a href=\"#1、闭锁使用\" class=\"headerlink\" title=\"1、闭锁使用\"></a>1、闭锁使用</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Driver2 &#123;\n    void main() throws InterruptedException &#123;\n        CountDownLatch doneSignal &#x3D; new CountDownLatch(N);\n        Executor e &#x3D; ...\n\n        for (int i &#x3D; 0; i &lt;N; ++i) &#x2F;&#x2F; create and start threads\n        e.execute(new WorkerRunnable(doneSignal, i));\n        doneSignal.await(); &#x2F;&#x2F; wait for all to finish\n    &#125;\n&#125;\n\nclass WorkerRunnable implements Runnable &#123;\n  private final CountDownLatch doneSignal;\n  private final int i;\n  WorkerRunnable(CountDownLatch doneSignal, int i) &#123;\n    this.doneSignal &#x3D; doneSignal;\n    this.i &#x3D; i;\n  &#125;\n  public void run() &#123;\n    try &#123;\n      doWork(i);\n      doneSignal.countDown();\n    &#125; catch (InterruptedException ex) &#123;&#125; &#x2F;&#x2F; return;\n  &#125;\n\n  void doWork() &#123; ... &#125;\n&#125;</code></pre>\n\n<p>可以看到 CountDownLatch 的作用类似于一个“栏栅”，在 CountDownLatch 的计数为 0 前，调用 await 方法的线程将一直阻塞，直到 CountDownLatch 计数为 0，await 方法才会返回，而 CountDownLatch 的 countDown()方法则一般由各个线程调用，实现 CountDownLatch 计数的减 1。<br>首先，看下 CountDownLatch 的构造方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public CountDownLatch(int count) &#123;\n    if (count &lt;0) throw new IllegalArgumentException(&quot;count &lt;0&quot;);\n    this.sync &#x3D; new Sync(count);\n&#125;</code></pre>\n\n<p>和 ReentrantLock 类似，CountDownLatch 内部也有一个叫做 Sync 的内部类，同样也是用它继承了 AQS，子类需要实现 AQS 的 5 个保护方法。</p>\n<h2 id=\"2、state-状态位\"><a href=\"#2、state-状态位\" class=\"headerlink\" title=\"2、state 状态位\"></a>2、state 状态位</h2><p>对于共享锁，需要实现 tryAcquireShared，tryReleaseShared 这 2 个方法。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649589997355-2e0d2412-8dc4-43b5-926e-a0cae309882c.png#clientId=u825d69b5-2259-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf9bcf6fb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=115&originWidth=315&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=6006&status=done&style=none&taskId=u1bb122c2-e3b3-4fef-b74e-4ba54abb8ae&title=\" alt=\"image.png\"><br>setState 方法设定的 state 是 AQS 的一个“状态位”，在不同的场景下，代表不同的含义，比如在 ReentrantLock 中，表示加锁的次数，在 CountDownLatch 中，则表示 CountDownLatch 的计数器的初始大小，任务分为 N 个子线程去执行，同步状态 state 也初始化为 N。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1650856861668-cac26f1c-272f-4b62-99cc-25f3cd132a03.png#clientId=u905e4a7c-27fa-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u59b97447&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=549&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=23052&status=done&style=none&taskId=uad9217c4-28a6-4be9-9569-180ab830a7d&title=\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final class Sync extends AbstractQueuedSynchronizer &#123;\n    private static final long serialVersionUID &#x3D; 4982264981922014374L;\n\n    Sync(int count) &#123;\n        setState(count);\n    &#125;\n\n    int getCount() &#123;\n        return getState();\n    &#125;\n\n    protected int tryAcquireShared(int acquires) &#123;\n        return (getState() &#x3D;&#x3D; 0) ? 1 : -1;\n    &#125;\n\n    protected boolean tryReleaseShared(int releases) &#123;\n        &#x2F;&#x2F; Decrement count; signal when transition to zero\n        for (;;) &#123;\n            int c &#x3D; getState();\n            if (c &#x3D;&#x3D; 0)\n                return false;\n            int nextc &#x3D; c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc &#x3D;&#x3D; 0;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>设置完计数器大小后 CountDownLatch 的构造方法返回，下面我们再看下 CountDownLatch 的 await()方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void await() throws InterruptedException &#123;\n    sync.acquireSharedInterruptibly(1);\n&#125;</code></pre>\n\n<p>调用了 Sync 的 acquireSharedInterruptibly 方法，因为 Sync 是 AQS 子类的原因，这里其实是直接调用了 AQS 的 acquireSharedInterruptibly 方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException &#123;\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (tryAcquireShared(arg) &lt;0)\n        doAcquireSharedInterruptibly(arg);\n&#125;</code></pre>\n\n<p>这个方法的调用是响应线程的打断的，所以在前两行会检查下线程是否被打断。接着，尝试着获取共享锁，小于 0，表示获取失败，AQS 在获取锁的思路是，先尝试直接获取锁，如果失败会将当前线程放在队列中，按照 FIFO 的原则等待锁。而对于共享锁也是这个思路，如果和独占锁一致，这里的 tryAcquireShared 应该是个空方法，留给子类去判断。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected int tryAcquireShared(int acquires) &#123;\n    return (getState() &#x3D;&#x3D; 0) ? 1 : -1;\n&#125;</code></pre>\n\n<p>如果 state 变成 0 了，则返回 1，表示获取成功，否则返回-1 则表示获取失败。</p>\n<h2 id=\"3、获取锁\"><a href=\"#3、获取锁\" class=\"headerlink\" title=\"3、获取锁\"></a>3、获取锁</h2><p>看到这里，读者可能会发现，await 方法的获取方式更像是在获取一个独占锁，那为什么这里还会用 tryAcquireShared 呢？<br>回想下 CountDownLatch 的 await 方法是不是只能在主线程中调用？答案是否定的，CountDownLatch 的 await 方法可以在多个线程中调用，当 CountDownLatch 的计数器为 0 后，调用 await 的方法都会依次返回。 也就是说可以多个线程同时在等待 await 方法返回，所以它被设计成了实现 tryAcquireShared 方法，获取的是一个共享锁，锁在所有调用 await 方法的线程间共享，所以叫共享锁。<br>如果获取共享锁失败（返回了-1，说明 state 不为 0，也就是 CountDownLatch 的计数器还不为 0），进入调用 doAcquireSharedInterruptibly 方法中，按照我们上述的猜想，应该是要将当前线程放入到队列中去。<br>在这之前，我们再回顾一下 AQS 队列的数据结构：AQS 是一个双向链表，通过节点中的 next，pre 变量分别指向当前节点后一个节点和前一个节点。其中，每个节点中都包含了一个线程和一个类型变量：表示当前节点是独占节点还是共享节点，头节点中的线程为正在占有锁的线程，而后的所有节点的线程表示为正在等待获取锁的线程。<br>黄色节点为头节点，表示正在获取锁的节点，剩下的蓝色节点（Node1、Node2、Node3）为正在等待锁的节点，他们通过各自的 next、pre 变量分别指向前后节点，形成了 AQS 中的双向链表。每个线程被加上类型（共享还是独占）后便是一个 Node， 也就是本文中说的节点。<br>回到 acquireSharedInterruptibly 方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 在中断模式下获取共享锁\n * @param arg the acquire argument\n *&#x2F;\nprivate void doAcquireSharedInterruptibly(int arg)\n    throws InterruptedException &#123;\n    &#x2F;* 类型为Node.SHARED，标示为共享节点。*&#x2F;\n    final Node node &#x3D; addWaiter(Node.SHARED);\n    boolean failed &#x3D; true;\n    try &#123;\n        for (;;) &#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head) &#123;\n                &#x2F;* 头节点获取共享锁 *&#x2F;\n                int r &#x3D; tryAcquireShared(arg);\n                if (r &gt;&#x3D; 0) &#123;\n                    setHeadAndPropagate(node, r);\n                    p.next &#x3D; null; &#x2F;&#x2F; help GC\n                    failed &#x3D; false;\n                    return;\n                &#125;\n            &#125;\n            &#x2F;* 阻塞并判断是否打断，其实这个判断才是自旋锁真正的猥琐点，\n             * 意思是如果你的前继节点不是head,\n             * 而且当你的前继节点状态是Node.SIGNAL时，\n             * 你这个线程将被park()，\n             * 直到另外的线程release时,发现head.next是你这个node时，才unpark，\n             * 才能继续循环并获取锁\n             *&#x2F;\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        &#125;\n    &#125; finally &#123;\n        if (failed)\n            cancelAcquire(node);\n    &#125;\n&#125;</code></pre>\n\n<p>使用了 CAS 更换了头节点，然后，将当前节点的下一个节点取出来，如果同样是“shared”类型的，再做一个”releaseShared”操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 设置队列head节点，检查后继节点是否在共享模式下等待，\n * 如果propagate &gt; 0 或者 节点PROPAGATE状态被设置，状态传播，\n *&#x2F;\nprivate void setHeadAndPropagate(Node node, int propagate) &#123;\n    Node h &#x3D; head; &#x2F;&#x2F; 记录老的头节点\n    setHead(node);\n    &#x2F;*\n     * 如果传播propagate被调用者caller标示，或者被前一次操作记录\n     * 并且下一个节点在共享模式等待，或者为null，\n     * 尝试信号通知队列下一个节点\n     *&#x2F;\n    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt;0 ||\n        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt;0) &#123;\n        Node s &#x3D; node.next;\n        if (s &#x3D;&#x3D; null || s.isShared())\n            &#x2F;* 共享模式下的释放动作，信号通知后继节点，保证状态传递 *&#x2F;\n            doReleaseShared();\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649589997397-74fdd3d7-a0f1-4993-9f49-71bb562eb720.png#clientId=u825d69b5-2259-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4cee9eb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=559&originWidth=690&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=53782&status=done&style=none&taskId=u06589832-a1c2-43c5-b5b0-4ace8d7b61c&title=\" alt=\"image.png\"></p>\n<h2 id=\"4、释放锁\"><a href=\"#4、释放锁\" class=\"headerlink\" title=\"4、释放锁\"></a>4、释放锁</h2><p>看完 await 方法，我们再来看下 countDown()方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void countDown() &#123;\n    sync.releaseShared(1);\n&#125;\n\n&#x2F;**\n * Releases in shared mode. Implemented by unblocking one or more\n * threads if &#123;@link &#x3D;tryReleaseShared&#125; returns true.\n*&#x2F;\npublic final boolean releaseShared(int arg) &#123;\n    if (tryReleaseShared(arg)) &#123;\n        doReleaseShared();\n        return true;\n    &#125;\n    return false;\n&#125;\n\nprotected boolean tryReleaseShared(int releases) &#123;\n    &#x2F;&#x2F; Decrement count; signal when transition to zero\n    for (;;) &#123;\n        int c &#x3D; getState();\n        if (c &#x3D;&#x3D; 0)\n            return false;\n        int nextc &#x3D; c-1;\n        if (compareAndSetState(c, nextc))\n            return nextc &#x3D;&#x3D; 0;\n    &#125;\n&#125;\n\n&#x2F;**\n * 共享模式下的释放动作，信号通知后继节点，保证状态传递\n *&#x2F;\nprivate void doReleaseShared() &#123;\n    &#x2F;*\n     * 确保释放状态的传播，即使有其他在进行中的acquires&#x2F;releases操作的情况下。\n     * 如果节点需要等待信号，用常用的方式，\n     * 尝试unparkSuccessor将head节点的后继unpark\n     * 否则状态被设置成PROPAGATE，来保证在释放的时候，传播能够继续。\n     * 另外，当执行这个操作的时候，必须循环，防止新的节点被增加，\n     * 此外，不像其他使用unparkSuccessor，我们需要知道CAS是否重置状态失败，\n     * 如果失败重新检查。\n     *&#x2F;\n    for (;;) &#123;\n        Node h &#x3D; head;\n        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;\n            int ws &#x3D; h.waitStatus;\n            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;\n                &#x2F;* 如果当前节点是SIGNAL意味着，它正在等待一个信号，\n                 * 或者说，它在等待被唤醒，因此做两件事，\n                 * 1是重置waitStatus标志位，2是重置成功后,唤醒下一个节点。\n                 *&#x2F;\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            &#x2F;&#x2F; loop to recheck cases\n                unparkSuccessor(h);\n            &#125;\n            else if (ws &#x3D;&#x3D; 0 &amp;&amp;!compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                &#x2F;* 如果本身头节点的waitStatus是出于重置状态（waitStatus&#x3D;&#x3D;0）的，\n                 * 将其设置为“传播”状态。\n                 * 意味着需要将状态向后一个节点传播。\n                 *&#x2F;\n                continue;                &#x2F;&#x2F; loop on failed CAS &#125;\n        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed\n            break;\n    &#125;\n&#125;</code></pre>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649589997367-5ebefbf7-8bc8-4d93-9d39-f00f3ce8e61b.png#clientId=u825d69b5-2259-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubd30420a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=744&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57023&status=done&style=none&taskId=u26f46c5e-d54d-415b-a2ec-e3fe596ff8f&title=\" alt=\"image.png\"><br>闭锁 CountdownLatch 总结</p>\n<ol>\n<li>与 AQS 的独占功能一样，共享锁是否可以被获取的判断为空方法，交由子类去实现。</li>\n<li>与 AQS 的独占功能不同，当共享锁被头节点获取后，独占功能是只有头节点获取锁，其余节点的线程继续沉睡，等待锁被释放后，才会唤醒下一个节点的线程，而共享功能是只要头节点获取锁成功，就在唤醒自身节点对应的线程的同时，继续唤醒 AQS 队列中的下一个节点的线程，每个节点在唤醒自身的同时还会唤醒下一个节点对应的线程，以实现共享状态的“向后传播”，从而实现共享功能。</li>\n</ol>\n","categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]}