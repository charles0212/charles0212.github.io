{"title":"Java锁（四）ConditionObject分析","slug":"yuque/Java锁（四）ConditionObject分析","date":"2015-02-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.499Z","comments":true,"path":"api/articles/java/java-conditionobject.json","excerpt":"在讲 ConditionObject之前，先讲解下条件队列。条件队列能够使得一组线程能够通过某种方式来等待特定的条件变成真，条件队列中的成员是一个个正在等待状态的线程。条件队列提供了一种挂起方式，当现场等待的条件非真时，挂起自己并释放锁，一旦等待条件为真，则立即醒来。条件队列主要功能1、隐式锁对应的条件队列对象的内置锁（synchronized语义对应的同步机制），关联着一个内置的条件队列。Object的wait/notify/notifyAll等方法构成了内部条件队列的API（即将内部锁与内部条件队列关联的机制）。内部条件队列是需要内置锁保护的，需要调用对象X","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734865-739bf34e-78fb-4a01-8c21-2dbedd5a0aa8.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7fcdf467&margin=%5Bobject%20Object%5D&name=image.png&originHeight=556&originWidth=656&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57897&status=done&style=none&taskId=ufc51b264-532e-4873-aaac-2848a6b76ea&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734907-8867f1f1-95be-438f-bc78-1eb6a9e72484.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue8d1fd2b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=1186&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=76862&status=done&style=none&taskId=ucb02a0ae-ca4e-483b-8600-af99a1423cc&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734932-a81a3a72-c37b-4bff-939b-216b5627c773.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3164b185&margin=%5Bobject%20Object%5D&name=image.png&originHeight=919&originWidth=692&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=90215&status=done&style=none&taskId=u54118d76-26e9-4148-ad0f-073d21c68ba&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734733-d11f6304-b1ff-4ca4-9a96-05c753d436f8.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua9bda77d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=270&originWidth=466&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=20651&status=done&style=none&taskId=u00f9d5b8-b2cf-4cad-951e-ad13f639c9e&title="],"content":"<p>在讲 ConditionObject 之前，先讲解下条件队列。条件队列能够使得一组线程能够通过某种方式来等待特定的条件变成真，条件队列中的成员是一个个正在等待状态的线程。条件队列提供了一种挂起方式，当现场等待的条件非真时，挂起自己并释放锁，一旦等待条件为真，则立即醒来。</p>\n<h2 id=\"条件队列主要功能\"><a href=\"#条件队列主要功能\" class=\"headerlink\" title=\"条件队列主要功能\"></a>条件队列主要功能</h2><h3 id=\"1、隐式锁对应的条件队列\"><a href=\"#1、隐式锁对应的条件队列\" class=\"headerlink\" title=\"1、隐式锁对应的条件队列\"></a>1、隐式锁对应的条件队列</h3><p>对象的内置锁（synchronized 语义对应的同步机制），关联着一个内置的条件队列。Object 的 wait&#x2F;notify&#x2F;notifyAll 等方法构成了内部条件队列的 API（即将内部锁与内部条件队列关联的机制）。 内部条件队列是需要内置锁保护的，需要调用对象 X 中的条件队列，必须持有对象 X 上的锁。这是因为状态处于并发环境下，“等待依赖状态的某个条件”与“维护状态的一致性”是绑定在一起的。</p>\n<h3 id=\"2、显式锁对应的条件队列\"><a href=\"#2、显式锁对应的条件队列\" class=\"headerlink\" title=\"2、显式锁对应的条件队列\"></a>2、显式锁对应的条件队列</h3><p>与内置锁对应的是显式锁，显式锁关联的条件队列是显式条件队列。内置锁的局限是每个内置锁只能关联一个条件队列，当线程需要等待多个条件时，则需要同时获取多个内置锁。 显式锁可以与多个条件队列关联，Condition 是显式锁的条件队列，它是 Object 的 wait&#x2F;notify&#x2F;notifyAll 等方法的扩展。提供了在一个对象上设置多个等待集合的功能，即一个对象上设置多个等待条件。</p>\n<h3 id=\"3、condition-使用\"><a href=\"#3、condition-使用\" class=\"headerlink\" title=\"3、condition 使用\"></a>3、condition 使用</h3><p>Condition 也称为条件队列，与内置锁关联的条件队列类似，它是一种广义的内置条件队列。它提供给线程一种方式使得该线程在调用 wait 方法后执行挂起操作，直到线程的等待的某个条件为真时被唤醒。 条件队列必须跟锁一起使用的，因为对共享状态变量的访问发生在多线程环境下，原理与内部条件队列一样。一个 Condition 的实例必须跟一个 Lock 绑定， Condition 一般作为 Lock 的内部类现。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class BoundedBuffer &#123;\n  final Lock lock &#x3D; new ReentrantLock();\n  final Condition notFull  &#x3D; lock.newCondition();\n  final Condition notEmpty &#x3D; lock.newCondition();\n\n  final Object[] items &#x3D; new Object[100];\n  int putptr, takeptr, count;\n\n  public void put(Object x) throws InterruptedException &#123;\n    lock.lock();\n    try &#123;\n      while (count &#x3D;&#x3D; items.length)\n        notFull.await();\n      items[putptr] &#x3D; x;\n      if (++putptr &#x3D;&#x3D; items.length) putptr &#x3D; 0;\n      ++count;\n      notEmpty.signal();\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n\n  public Object take() throws InterruptedException &#123;\n    lock.lock();\n    try &#123;\n      while (count &#x3D;&#x3D; 0)\n        notEmpty.await();\n      Object x &#x3D; items[takeptr];\n      if (++takeptr &#x3D;&#x3D; items.length) takeptr &#x3D; 0;\n      --count;\n      notFull.signal();\n      return x;\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n\n&#125;</code></pre>\n\n<h3 id=\"4、AQS-对条件队列类图\"><a href=\"#4、AQS-对条件队列类图\" class=\"headerlink\" title=\"4、AQS 对条件队列类图\"></a>4、AQS 对条件队列类图</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734865-739bf34e-78fb-4a01-8c21-2dbedd5a0aa8.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7fcdf467&margin=%5Bobject%20Object%5D&name=image.png&originHeight=556&originWidth=656&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57897&status=done&style=none&taskId=ufc51b264-532e-4873-aaac-2848a6b76ea&title=\" alt=\"image.png\"></p>\n<h3 id=\"5、条件队列的节点状态\"><a href=\"#5、条件队列的节点状态\" class=\"headerlink\" title=\"5、条件队列的节点状态\"></a>5、条件队列的节点状态</h3><p>调用条件队列的等待操作，会设置节点的 waitingStatus 为 Condition，标识当前节点正处于条件队列中。状态转换图如下：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734907-8867f1f1-95be-438f-bc78-1eb6a9e72484.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue8d1fd2b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=1186&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=76862&status=done&style=none&taskId=ucb02a0ae-ca4e-483b-8600-af99a1423cc&title=\" alt=\"image.png\"><br>Node 的各个状态的主要作用，Cancelled 主要是解决线程在持有锁时被外部中断的逻辑，AQS 的可中断锁获取方法 lockInterrutible()是基于该状态实现的，显示锁必须手动释放锁，尤其是有中断的环境中，一个线程被中断可能仍然持有锁，所以必须注意在 finally 中 unlock。Condition 则是条件队列的等待操作，是 Lock 与条件队列关联的基础。Signal 是阻塞后继线程的标识。</p>\n<h3 id=\"6、条件队列的等待和唤醒操作\"><a href=\"#6、条件队列的等待和唤醒操作\" class=\"headerlink\" title=\"6、条件队列的等待和唤醒操作\"></a>6、条件队列的等待和唤醒操作</h3><p>条件队列上的等待和唤醒操作，本质上是节点在 AQS 线程等待队列和条件队列之间相互转移的过程，当需要等待某个条件时，线程会将当前节点添加到条件队列中，并释放锁；当某个线程执行条件队列的唤醒操作，则会将条件队列的节点转移到 AQS 等待队列。每个 Condition 就是一个条件队列，可以通过 Lock 的 newCondition 创建多个等待条件。操作流程如下：<br>条件队列等待 await 如下所示</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void await() throws InterruptedException &#123;\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    &#x2F;&#x2F; 将当前线程所在的节点添加到条件等待队列里面\n    Node node &#x3D; addConditionWaiter();\n    &#x2F;&#x2F; 释放并唤醒后续节点\n    int savedState &#x3D; fullyRelease(node);\n    int interruptMode &#x3D; 0;\n    &#x2F;&#x2F; node不在同步队列中，挂起当前线程，\n    while (!isOnSyncQueue(node)) &#123;\n        LockSupport.park(this);\n        &#x2F;&#x2F; 检查在等待时是否中断，如果中断，返回中断模式\n        if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)\n            break;\n    &#125;\n    &#x2F;&#x2F; 当前节点进入到队列中，并自旋\n    if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)\n        interruptMode &#x3D; REINTERRUPT;\n    &#x2F;&#x2F; 当前节点的下一个等待者，不为空，移除所有取消的\n    if (node.nextWaiter !&#x3D; null)\n        unlinkCancelledWaiters();\n    if (interruptMode !&#x3D; 0)\n        reportInterruptAfterWait(interruptMode);\n&#125;\n\n&#x2F;**\n * 添加一个新的等待者到条件等待队列里面\n *&#x2F;\nprivate Node addConditionWaiter() &#123;\n    Node t &#x3D; lastWaiter;\n    &#x2F;&#x2F; 如果lastWaiter不为状态节点，移除\n    if (t !&#x3D; null &amp;&amp; t.waitStatus !&#x3D; Node.CONDITION) &#123;\n        unlinkCancelledWaiters();\n        t &#x3D; lastWaiter;\n    &#125;\n    &#x2F;&#x2F; 将当前线程关联的node添加到条件队列中\n    Node node &#x3D; new Node(Thread.currentThread(), Node.CONDITION);\n    if (t &#x3D;&#x3D; null)\n        firstWaiter &#x3D; node;\n    else\n        t.nextWaiter &#x3D; node;\n    lastWaiter &#x3D; node;\n    return node;\n&#125;\n\n&#x2F;**\n * 使用当前的state值调用release方法，返回保存的state值\n * 失败时抛出异常，并将节点设置成在Node.CANCELLED，\n * @param node 等待的状态节点\n * @return 返回上一次同步队列的state状态\n *&#x2F;\nfinal int fullyRelease(Node node) &#123;\n    boolean failed &#x3D; true;\n    try &#123;\n        &#x2F;&#x2F; 获取当前AQS的状态值state\n        int savedState &#x3D; getState();\n        &#x2F;&#x2F; 释放，并唤醒后继节点\n        if (release(savedState)) &#123;\n            failed &#x3D; false;\n            return savedState;\n        &#125; else &#123;\n            &#x2F;&#x2F; 释放失败，抛出异常，并且在finally中将节点设置成在Node.CANCELLED\n            throw new IllegalMonitorStateException();\n        &#125;\n    &#125; finally &#123;\n        if (failed)\n            node.waitStatus &#x3D; Node.CANCELLED;\n    &#125;\n&#125;\n\npublic final boolean release(int arg) &#123;\n    if (tryRelease(arg)) &#123;\n        Node h &#x3D; head;\n        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)\n            unparkSuccessor(h);&#x2F;&#x2F;unblock，唤醒head的后继节点\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<p>await 等待的流程如下图所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734932-a81a3a72-c37b-4bff-939b-216b5627c773.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3164b185&margin=%5Bobject%20Object%5D&name=image.png&originHeight=919&originWidth=692&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=90215&status=done&style=none&taskId=u54118d76-26e9-4148-ad0f-073d21c68ba&title=\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Moves the longest-waiting thread, if one exists, from the\n * wait queue for this condition to the wait queue for the\n * owning lock.\n *\n * @throws IllegalMonitorStateException if &#123;@link &#x3D;isHeldExclusively&#125;\n *         returns &#123;@code false&#125;\n *&#x2F;\npublic final void signal() &#123;\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first &#x3D; firstWaiter;\n    if (first !&#x3D; null)\n        doSignal(first);\n&#125;\n\n&#x2F;**\n * Moves all threads from the wait queue for this condition to\n * the wait queue for the owning lock.\n *\n * @throws IllegalMonitorStateException if &#123;@link &#x3D;isHeldExclusively&#125;\n *         returns &#123;@code false&#125;\n *&#x2F;\npublic final void signalAll() &#123;\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first &#x3D; firstWaiter;\n    if (first !&#x3D; null)\n        doSignalAll(first);\n&#125;\n\n&#x2F;**\n * Removes and transfers nodes until hit non-cancelled one or\n * null. Split out from signal in part to encourage compilers\n * to inline the case of no waiters.\n * @param first (non-null) the first node on condition queue\n *&#x2F;\nprivate void doSignal(Node first) &#123;\n    do &#123;\n        if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)\n            lastWaiter &#x3D; null;\n        first.nextWaiter &#x3D; null;\n    &#125; while (!transferForSignal(first) &amp;&amp;\n             (first &#x3D; firstWaiter) !&#x3D; null);\n&#125;\n\n&#x2F;**\n * Removes and transfers all nodes.\n * @param first (non-null) the first node on condition queue\n *&#x2F;\nprivate void doSignalAll(Node first) &#123;\n    lastWaiter &#x3D; firstWaiter &#x3D; null;\n    do &#123;\n        Node next &#x3D; first.nextWaiter;\n        first.nextWaiter &#x3D; null;\n        transferForSignal(first);\n        first &#x3D; next;\n    &#125; while (first !&#x3D; null);\n&#125;\n\n&#x2F;**\n * 将节点从条件队列转到同步队列中\n * 成功，返回true\n * 否则节点被取消，在收到信号前\n *&#x2F;\nfinal boolean transferForSignal(Node node) &#123;\n    &#x2F;*\n     * 节点被取消，不能改变waitStatus\n     *&#x2F;\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    &#x2F;*\n     * 将节点粘到队列中，尝试设置前驱节点的waitStatus，表明线程可能正在等待\n     * 如果取消或者尝试设置waitStatus失败，唤醒重新同步\n     * 在这种情况下waitStatus会出错，但是是瞬时无害的\n     *&#x2F;\n    Node p &#x3D; enq(node);\n    int ws &#x3D; p.waitStatus;\n    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        LockSupport.unpark(node.thread);\n    return true;\n&#125;</code></pre>\n\n<p>signal 通知条件等待<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734733-d11f6304-b1ff-4ca4-9a96-05c753d436f8.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua9bda77d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=270&originWidth=466&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=20651&status=done&style=none&taskId=u00f9d5b8-b2cf-4cad-951e-ad13f639c9e&title=\" alt=\"image.png\"><br>显式条件队列弥补内置条件队列只能关联一个条件的缺陷，同时继承了 Lock 对象的公平性。在 Condition 对象中，与 Object 的 wait&#x2F;notify&#x2F;notifyAll 对应的扩展方法是 await&#x2F;signal&#x2F;signallAll，同时也具有 Object 的这三个方法，所以使用的时候需要注意使用版本的正确。另外，显式锁必须遵从特定的使用规范，先 lock 在 finally 中 unlock，以确保锁必然会被正确释放。<br>此外，AQS 的两个队列都是链表队列，关联类的方法的都相当简洁，尤其是节点移除队列操作过程中，都及时释放了所占内存。读源码，可以学习到一种编码的严谨性，锻炼自己关注 GC 的意识。这是我见到过的第三处及时释放 GC 的的代码了。从最初的 ArrayList 的元素 remove 中，然后是 HashMap 的动态扩容数组转移操作，最近看 AQS 的元素唤醒和锁释放操作。关注 GC 的确是最近开始形成的一种编程意识。</p>\n","more":"<p>在讲 ConditionObject 之前，先讲解下条件队列。条件队列能够使得一组线程能够通过某种方式来等待特定的条件变成真，条件队列中的成员是一个个正在等待状态的线程。条件队列提供了一种挂起方式，当现场等待的条件非真时，挂起自己并释放锁，一旦等待条件为真，则立即醒来。</p>\n<h2 id=\"条件队列主要功能\"><a href=\"#条件队列主要功能\" class=\"headerlink\" title=\"条件队列主要功能\"></a>条件队列主要功能</h2><h3 id=\"1、隐式锁对应的条件队列\"><a href=\"#1、隐式锁对应的条件队列\" class=\"headerlink\" title=\"1、隐式锁对应的条件队列\"></a>1、隐式锁对应的条件队列</h3><p>对象的内置锁（synchronized 语义对应的同步机制），关联着一个内置的条件队列。Object 的 wait&#x2F;notify&#x2F;notifyAll 等方法构成了内部条件队列的 API（即将内部锁与内部条件队列关联的机制）。 内部条件队列是需要内置锁保护的，需要调用对象 X 中的条件队列，必须持有对象 X 上的锁。这是因为状态处于并发环境下，“等待依赖状态的某个条件”与“维护状态的一致性”是绑定在一起的。</p>\n<h3 id=\"2、显式锁对应的条件队列\"><a href=\"#2、显式锁对应的条件队列\" class=\"headerlink\" title=\"2、显式锁对应的条件队列\"></a>2、显式锁对应的条件队列</h3><p>与内置锁对应的是显式锁，显式锁关联的条件队列是显式条件队列。内置锁的局限是每个内置锁只能关联一个条件队列，当线程需要等待多个条件时，则需要同时获取多个内置锁。 显式锁可以与多个条件队列关联，Condition 是显式锁的条件队列，它是 Object 的 wait&#x2F;notify&#x2F;notifyAll 等方法的扩展。提供了在一个对象上设置多个等待集合的功能，即一个对象上设置多个等待条件。</p>\n<h3 id=\"3、condition-使用\"><a href=\"#3、condition-使用\" class=\"headerlink\" title=\"3、condition 使用\"></a>3、condition 使用</h3><p>Condition 也称为条件队列，与内置锁关联的条件队列类似，它是一种广义的内置条件队列。它提供给线程一种方式使得该线程在调用 wait 方法后执行挂起操作，直到线程的等待的某个条件为真时被唤醒。 条件队列必须跟锁一起使用的，因为对共享状态变量的访问发生在多线程环境下，原理与内部条件队列一样。一个 Condition 的实例必须跟一个 Lock 绑定， Condition 一般作为 Lock 的内部类现。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class BoundedBuffer &#123;\n  final Lock lock &#x3D; new ReentrantLock();\n  final Condition notFull  &#x3D; lock.newCondition();\n  final Condition notEmpty &#x3D; lock.newCondition();\n\n  final Object[] items &#x3D; new Object[100];\n  int putptr, takeptr, count;\n\n  public void put(Object x) throws InterruptedException &#123;\n    lock.lock();\n    try &#123;\n      while (count &#x3D;&#x3D; items.length)\n        notFull.await();\n      items[putptr] &#x3D; x;\n      if (++putptr &#x3D;&#x3D; items.length) putptr &#x3D; 0;\n      ++count;\n      notEmpty.signal();\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n\n  public Object take() throws InterruptedException &#123;\n    lock.lock();\n    try &#123;\n      while (count &#x3D;&#x3D; 0)\n        notEmpty.await();\n      Object x &#x3D; items[takeptr];\n      if (++takeptr &#x3D;&#x3D; items.length) takeptr &#x3D; 0;\n      --count;\n      notFull.signal();\n      return x;\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n\n&#125;</code></pre>\n\n<h3 id=\"4、AQS-对条件队列类图\"><a href=\"#4、AQS-对条件队列类图\" class=\"headerlink\" title=\"4、AQS 对条件队列类图\"></a>4、AQS 对条件队列类图</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734865-739bf34e-78fb-4a01-8c21-2dbedd5a0aa8.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7fcdf467&margin=%5Bobject%20Object%5D&name=image.png&originHeight=556&originWidth=656&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=57897&status=done&style=none&taskId=ufc51b264-532e-4873-aaac-2848a6b76ea&title=\" alt=\"image.png\"></p>\n<h3 id=\"5、条件队列的节点状态\"><a href=\"#5、条件队列的节点状态\" class=\"headerlink\" title=\"5、条件队列的节点状态\"></a>5、条件队列的节点状态</h3><p>调用条件队列的等待操作，会设置节点的 waitingStatus 为 Condition，标识当前节点正处于条件队列中。状态转换图如下：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734907-8867f1f1-95be-438f-bc78-1eb6a9e72484.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue8d1fd2b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=1186&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=76862&status=done&style=none&taskId=ucb02a0ae-ca4e-483b-8600-af99a1423cc&title=\" alt=\"image.png\"><br>Node 的各个状态的主要作用，Cancelled 主要是解决线程在持有锁时被外部中断的逻辑，AQS 的可中断锁获取方法 lockInterrutible()是基于该状态实现的，显示锁必须手动释放锁，尤其是有中断的环境中，一个线程被中断可能仍然持有锁，所以必须注意在 finally 中 unlock。Condition 则是条件队列的等待操作，是 Lock 与条件队列关联的基础。Signal 是阻塞后继线程的标识。</p>\n<h3 id=\"6、条件队列的等待和唤醒操作\"><a href=\"#6、条件队列的等待和唤醒操作\" class=\"headerlink\" title=\"6、条件队列的等待和唤醒操作\"></a>6、条件队列的等待和唤醒操作</h3><p>条件队列上的等待和唤醒操作，本质上是节点在 AQS 线程等待队列和条件队列之间相互转移的过程，当需要等待某个条件时，线程会将当前节点添加到条件队列中，并释放锁；当某个线程执行条件队列的唤醒操作，则会将条件队列的节点转移到 AQS 等待队列。每个 Condition 就是一个条件队列，可以通过 Lock 的 newCondition 创建多个等待条件。操作流程如下：<br>条件队列等待 await 如下所示</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void await() throws InterruptedException &#123;\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    &#x2F;&#x2F; 将当前线程所在的节点添加到条件等待队列里面\n    Node node &#x3D; addConditionWaiter();\n    &#x2F;&#x2F; 释放并唤醒后续节点\n    int savedState &#x3D; fullyRelease(node);\n    int interruptMode &#x3D; 0;\n    &#x2F;&#x2F; node不在同步队列中，挂起当前线程，\n    while (!isOnSyncQueue(node)) &#123;\n        LockSupport.park(this);\n        &#x2F;&#x2F; 检查在等待时是否中断，如果中断，返回中断模式\n        if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)\n            break;\n    &#125;\n    &#x2F;&#x2F; 当前节点进入到队列中，并自旋\n    if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)\n        interruptMode &#x3D; REINTERRUPT;\n    &#x2F;&#x2F; 当前节点的下一个等待者，不为空，移除所有取消的\n    if (node.nextWaiter !&#x3D; null)\n        unlinkCancelledWaiters();\n    if (interruptMode !&#x3D; 0)\n        reportInterruptAfterWait(interruptMode);\n&#125;\n\n&#x2F;**\n * 添加一个新的等待者到条件等待队列里面\n *&#x2F;\nprivate Node addConditionWaiter() &#123;\n    Node t &#x3D; lastWaiter;\n    &#x2F;&#x2F; 如果lastWaiter不为状态节点，移除\n    if (t !&#x3D; null &amp;&amp; t.waitStatus !&#x3D; Node.CONDITION) &#123;\n        unlinkCancelledWaiters();\n        t &#x3D; lastWaiter;\n    &#125;\n    &#x2F;&#x2F; 将当前线程关联的node添加到条件队列中\n    Node node &#x3D; new Node(Thread.currentThread(), Node.CONDITION);\n    if (t &#x3D;&#x3D; null)\n        firstWaiter &#x3D; node;\n    else\n        t.nextWaiter &#x3D; node;\n    lastWaiter &#x3D; node;\n    return node;\n&#125;\n\n&#x2F;**\n * 使用当前的state值调用release方法，返回保存的state值\n * 失败时抛出异常，并将节点设置成在Node.CANCELLED，\n * @param node 等待的状态节点\n * @return 返回上一次同步队列的state状态\n *&#x2F;\nfinal int fullyRelease(Node node) &#123;\n    boolean failed &#x3D; true;\n    try &#123;\n        &#x2F;&#x2F; 获取当前AQS的状态值state\n        int savedState &#x3D; getState();\n        &#x2F;&#x2F; 释放，并唤醒后继节点\n        if (release(savedState)) &#123;\n            failed &#x3D; false;\n            return savedState;\n        &#125; else &#123;\n            &#x2F;&#x2F; 释放失败，抛出异常，并且在finally中将节点设置成在Node.CANCELLED\n            throw new IllegalMonitorStateException();\n        &#125;\n    &#125; finally &#123;\n        if (failed)\n            node.waitStatus &#x3D; Node.CANCELLED;\n    &#125;\n&#125;\n\npublic final boolean release(int arg) &#123;\n    if (tryRelease(arg)) &#123;\n        Node h &#x3D; head;\n        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)\n            unparkSuccessor(h);&#x2F;&#x2F;unblock，唤醒head的后继节点\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<p>await 等待的流程如下图所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734932-a81a3a72-c37b-4bff-939b-216b5627c773.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3164b185&margin=%5Bobject%20Object%5D&name=image.png&originHeight=919&originWidth=692&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=90215&status=done&style=none&taskId=u54118d76-26e9-4148-ad0f-073d21c68ba&title=\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Moves the longest-waiting thread, if one exists, from the\n * wait queue for this condition to the wait queue for the\n * owning lock.\n *\n * @throws IllegalMonitorStateException if &#123;@link &#x3D;isHeldExclusively&#125;\n *         returns &#123;@code false&#125;\n *&#x2F;\npublic final void signal() &#123;\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first &#x3D; firstWaiter;\n    if (first !&#x3D; null)\n        doSignal(first);\n&#125;\n\n&#x2F;**\n * Moves all threads from the wait queue for this condition to\n * the wait queue for the owning lock.\n *\n * @throws IllegalMonitorStateException if &#123;@link &#x3D;isHeldExclusively&#125;\n *         returns &#123;@code false&#125;\n *&#x2F;\npublic final void signalAll() &#123;\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first &#x3D; firstWaiter;\n    if (first !&#x3D; null)\n        doSignalAll(first);\n&#125;\n\n&#x2F;**\n * Removes and transfers nodes until hit non-cancelled one or\n * null. Split out from signal in part to encourage compilers\n * to inline the case of no waiters.\n * @param first (non-null) the first node on condition queue\n *&#x2F;\nprivate void doSignal(Node first) &#123;\n    do &#123;\n        if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)\n            lastWaiter &#x3D; null;\n        first.nextWaiter &#x3D; null;\n    &#125; while (!transferForSignal(first) &amp;&amp;\n             (first &#x3D; firstWaiter) !&#x3D; null);\n&#125;\n\n&#x2F;**\n * Removes and transfers all nodes.\n * @param first (non-null) the first node on condition queue\n *&#x2F;\nprivate void doSignalAll(Node first) &#123;\n    lastWaiter &#x3D; firstWaiter &#x3D; null;\n    do &#123;\n        Node next &#x3D; first.nextWaiter;\n        first.nextWaiter &#x3D; null;\n        transferForSignal(first);\n        first &#x3D; next;\n    &#125; while (first !&#x3D; null);\n&#125;\n\n&#x2F;**\n * 将节点从条件队列转到同步队列中\n * 成功，返回true\n * 否则节点被取消，在收到信号前\n *&#x2F;\nfinal boolean transferForSignal(Node node) &#123;\n    &#x2F;*\n     * 节点被取消，不能改变waitStatus\n     *&#x2F;\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    &#x2F;*\n     * 将节点粘到队列中，尝试设置前驱节点的waitStatus，表明线程可能正在等待\n     * 如果取消或者尝试设置waitStatus失败，唤醒重新同步\n     * 在这种情况下waitStatus会出错，但是是瞬时无害的\n     *&#x2F;\n    Node p &#x3D; enq(node);\n    int ws &#x3D; p.waitStatus;\n    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        LockSupport.unpark(node.thread);\n    return true;\n&#125;</code></pre>\n\n<p>signal 通知条件等待<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649590734733-d11f6304-b1ff-4ca4-9a96-05c753d436f8.png#clientId=ueca12249-0176-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua9bda77d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=270&originWidth=466&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=20651&status=done&style=none&taskId=u00f9d5b8-b2cf-4cad-951e-ad13f639c9e&title=\" alt=\"image.png\"><br>显式条件队列弥补内置条件队列只能关联一个条件的缺陷，同时继承了 Lock 对象的公平性。在 Condition 对象中，与 Object 的 wait&#x2F;notify&#x2F;notifyAll 对应的扩展方法是 await&#x2F;signal&#x2F;signallAll，同时也具有 Object 的这三个方法，所以使用的时候需要注意使用版本的正确。另外，显式锁必须遵从特定的使用规范，先 lock 在 finally 中 unlock，以确保锁必然会被正确释放。<br>此外，AQS 的两个队列都是链表队列，关联类的方法的都相当简洁，尤其是节点移除队列操作过程中，都及时释放了所占内存。读源码，可以学习到一种编码的严谨性，锻炼自己关注 GC 的意识。这是我见到过的第三处及时释放 GC 的的代码了。从最初的 ArrayList 的元素 remove 中，然后是 HashMap 的动态扩容数组转移操作，最近看 AQS 的元素唤醒和锁释放操作。关注 GC 的确是最近开始形成的一种编程意识。</p>\n","categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]}