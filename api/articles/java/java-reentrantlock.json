{"title":"Java锁（二）ReentrantLock独占锁分析","slug":"yuque/Java锁（二）ReentrantLock独占锁分析","date":"2015-02-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.499Z","comments":true,"path":"api/articles/java/java-reentrantlock.json","excerpt":"ReentrantLock的功能是实现代码段的并发访问控制，是一种排它锁，也就是通常意义上所说的锁，内部有两种实现NonfairSync 和FairSync，公平锁和非公平锁，默认采用非公平锁策略。ReentrantLock的实现不仅可以替代隐式的synchronized关键字，而且能够提供超过关键字本身的多种功能。1、ReentrantLock 的使用class X {  private final ReentrantLock lock = new ReentrantLock();  // ...  public void m() {    lock.lock","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1650856752907-aa48a20e-51da-401f-830d-e940b1b0c650.png#clientId=u47a90b62-dbe9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=344&id=u9774d715&margin=%5Bobject%20Object%5D&name=image.png&originHeight=344&originWidth=595&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=17143&status=done&style=none&taskId=u38557c22-fb44-4ca4-88cb-451b1757914&title=&width=595","https://cdn.nlark.com/yuque/0/2022/png/104130/1649588516655-5cee77db-adfa-4178-b280-d4c73d94135c.png#clientId=u62baf52a-5843-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua0bc3798&margin=%5Bobject%20Object%5D&name=image.png&originHeight=628&originWidth=644&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=49845&status=done&style=none&taskId=u94f0a047-bfa4-4d89-9711-3937c0917a6&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1649588516660-6ebd55d4-9b5c-406b-afac-702d0242a43b.png#clientId=u62baf52a-5843-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u72e622c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=507&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=28849&status=done&style=none&taskId=ue26c6f4f-943e-4912-ac16-c067c441718&title="],"content":"<p>ReentrantLock 的功能是实现代码段的并发访问控制，是一种排它锁，也就是通常意义上所说的锁，内部有两种实现 NonfairSync 和 FairSync，公平锁和非公平锁，默认采用非公平锁策略。ReentrantLock 的实现不仅可以替代隐式的 synchronized 关键字，而且能够提供超过关键字本身的多种功能。</p>\n<h2 id=\"1、ReentrantLock-的使用\"><a href=\"#1、ReentrantLock-的使用\" class=\"headerlink\" title=\"1、ReentrantLock 的使用\"></a>1、ReentrantLock 的使用</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class X &#123;\n  private final ReentrantLock lock &#x3D; new ReentrantLock();\n  &#x2F;&#x2F; ...\n\n  public void m() &#123;\n    lock.lock();  &#x2F;&#x2F; block until condition holds\n    try &#123;\n      &#x2F;&#x2F; ... method body\n    &#125; finally &#123;\n      lock.unlock()\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p><strong>ReentrantLock 会保证 method-body 在同一时间只有一个线程在执行这段代码</strong>，或者说，同一时刻只有一个线程的 lock 方法会返回。其余线程会被挂起，直到获取锁。从这里可以看出，其实 ReentrantLock 实现的就是一个独占锁的功能：有且只有一个线程获取到锁，其余线程全部挂起，直到该拥有锁的线程释放锁，被挂起的线程被唤醒重新开始竞争锁。那现在看下 Doug Lea 怎么去实现 ReentrantLock 重入锁的。首先看下 ReentrantLock 的创建和加锁、解锁过程。</p>\n<h2 id=\"2、ReentrantLock-原理分析\"><a href=\"#2、ReentrantLock-原理分析\" class=\"headerlink\" title=\"2、ReentrantLock 原理分析\"></a>2、ReentrantLock 原理分析</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 默认非公平锁\n *&#x2F;\npublic ReentrantLock() &#123;\n    sync &#x3D; new NonfairSync();\n&#125; &#x2F;**\n * 创建ReentrantLock，公平锁or非公平锁\n*&#x2F;\npublic ReentrantLock(boolean fair) &#123;\n    sync &#x3D; fair ? new FairSync() : new NonfairSync();\n&#125;\n\n&#x2F;**\n *加锁解锁，使用sync完成\n*&#x2F;\npublic void lock() &#123;\n    sync.lock();\n&#125;\npublic void unlock() &#123;\n    sync.release(1);\n&#125;</code></pre>\n\n<p>其中，公平锁中每个线程抢占锁的顺序为先后调用 lock 方法的顺序依次获取锁。非公平锁中每个线程抢占锁的顺序不定，先获取锁，获取不到，然后加入到 queue 中，和调用 lock 方法的先后顺序无关。<br>如果在绝对时间上，先对锁进行获取的请求一定被先满足，那么这个锁是公平的，反之，是不公平的，也就是说等待时间最长的线程最有机会获取锁，也可以说锁的获取是有序的。ReentrantLock 这个锁提供了一个构造函数，能够控制这个锁是否是公平的。而锁的名字也是说明了这个锁具备了重复进入的可能，也就是说能够让当前线程多次的进行对锁的获取操作，这样的最大次数限制是 Integer.MAX_VALUE，约 21 亿次左右。<br>事实上公平的锁机制往往没有非公平的效率高，因为公平的获取锁没有考虑到操作系统对线程的调度因素，这样造成 JVM 对于等待中的线程调度次序和操作系统对线程的调度之间的不匹配。对于锁的快速且重复的获取过程中，连续获取的概率是非常高的，而公平锁会压制这种情况，虽然公平性得以保障，但是响应比却下降了，但是并不是任何场景都是以 TPS 作为唯一指标的，因为公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。</p>\n<h3 id=\"AQS-的队列操作\"><a href=\"#AQS-的队列操作\" class=\"headerlink\" title=\"AQS 的队列操作\"></a>AQS 的队列操作</h3><p>在分析加锁前，先看下 AQS 的入队列操作， head，tail 节点默认为 null，入队列时，当 tail 为 null 时，初始化创建 dummy head 节点，将入队列的 node 插入队尾。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Creates and enqueues node for given thread and mode.\n * 节点入同步队列，通过CAS比较然后插入队列尾部，\n * @param current the thread\n * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared\n * @return the new node\n *&#x2F;\nprivate Node addWaiter(Node mode) &#123;\n    Node node &#x3D; new Node(Thread.currentThread(), mode);\n    &#x2F;&#x2F; 快速入队列,tail不为null，通过CAS比较然后插入队列尾部 Node pred &#x3D; tail;\n    if (pred !&#x3D; null) &#123;\n        node.prev &#x3D; pred;\n        if (compareAndSetTail(pred, node)) &#123;\n            pred.next &#x3D; node;\n            return node;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;快速入队列失败后执行enq方法\n    enq(node);\n    return node;\n&#125;\n\n&#x2F;**\n * 插入节点到队列中，必要的时候初始化头节点，返回该节点前驱\n * @param node the node to insert\n * @return node&#39;s predecessor\n *&#x2F;\nprivate Node enq(final Node node) &#123;\n    for (;;) &#123;\n        Node t &#x3D; tail;\n        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 初始化，创建Dummy header，thread为null\n            if (compareAndSetHead(new Node()))\n                tail &#x3D; head;\n        &#125; else &#123;\n            node.prev &#x3D; t;\n            if (compareAndSetTail(t, node)) &#123;\n                t.next &#x3D; node;\n                return t;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"AQS-获取锁定-独占锁\"><a href=\"#AQS-获取锁定-独占锁\" class=\"headerlink\" title=\"AQS 获取锁定(独占锁)\"></a>AQS 获取锁定(独占锁)</h3><p>调用 acquire 方法，其实这个方法是阻塞的, 获取锁的步骤为：<br>1、 tryAcquire（由子类 Sync 实现）尝试获取锁<br>2、 没有获取到锁，将节点加入到队列尾部中，加入成功 selfInterrupt，中断当前线程。<br>ReentrantLock，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1650856752907-aa48a20e-51da-401f-830d-e940b1b0c650.png#clientId=u47a90b62-dbe9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=344&id=u9774d715&margin=%5Bobject%20Object%5D&name=image.png&originHeight=344&originWidth=595&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=17143&status=done&style=none&taskId=u38557c22-fb44-4ca4-88cb-451b1757914&title=&width=595\" alt=\"image.png\"><br><strong>独占模式下的 AQS 是不响应中断的</strong> ，指的是加入到同步队列中的线程，如果因为中断而被唤醒的话，不会立即返回，并且抛出 InterruptedException。而是再次去判断其前驱节点是否为 head 节点，决定是否争抢同步状态。如果其前驱节点不是 head 节点或者争抢同步状态失败，那么再次挂起。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void acquire(int arg)  &#123;\n    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n&#125;</code></pre>\n\n<p>没有获取到锁则调用 AQS 的 acquireQueued 方法：<br>1、当 node 的前驱节点是头节点，并且独占时才返回<br>2、前继节点不是 head, 而且当你的前继节点状态是 Node.SIGNAL 时， 你这个线程将被 park()，直到另外的线程 release 时,发现 head.next 是你这个 node 时才 unpark，才能继续循环并获取锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final boolean acquireQueued(final Node node, int arg) &#123;\n    boolean failed &#x3D; true;\n    try &#123;\n        boolean interrupted &#x3D; false;\n        for (;;) &#123;\n            final Node p &#x3D; node.predecessor();\n            &#x2F;* 当node的前驱节点是头节点，并且独占时才返回 *&#x2F;\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC，队列中移除头节点p\n                failed &#x3D; false;\n                return interrupted;\n            &#125;\n            &#x2F;* 阻塞并判断是否打断，其实这个判断才是自旋锁真正的猥琐点，\n             * 意思是如果你的前继节点不是head,\n             * 而且当你的前继节点状态是Node.SIGNAL时，\n             * 你这个线程将被park()，\n             * 直到另外的线程release时,发现head.next是你这个node时，才unpark，\n             * 才能继续循环并获取锁\n             *&#x2F;\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                interrupted &#x3D; true;\n        &#125;\n    &#125; finally &#123;\n        if (failed)\n            cancelAcquire(node);\n    &#125;\n&#125;</code></pre>\n\n<p>shouldParkAfterFailedAcquire 这个方法删除所有 waitStatus&gt;0 也就是 CANCELLED 状态的 Node,并设置前继节点为 signal</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;\n    int ws &#x3D; pred.waitStatus;\n    if (ws &#x3D;&#x3D; Node.SIGNAL)\n        &#x2F;*\n         * 节点已经设置状态Node.SIGNAL，\n         * 请求释放使它获取信号，所以它才能安全的park\n         *&#x2F;\n        return true;\n    if (ws &gt; 0) &#123;\n        &#x2F;*\n         *前驱节点被取消，跳过所有的取消的前驱节点和表明重试\n         *&#x2F;\n        do &#123;\n            node.prev &#x3D; pred &#x3D; pred.prev;\n        &#125; while (pred.waitStatus &gt; 0);\n        pred.next &#x3D; node;\n    &#125; else &#123;\n        &#x2F;*\n         * waitStatus为0或者PROPAGATE,表明我们需要一个信号，但是还没有park，\n         * 调用者需要重试，保证在parking过程中，它不能被获取到\n         *&#x2F;\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    &#125;\n    return false;\n&#125;\n\n&#x2F;* 禁用当前线程，返回是否中断 *&#x2F;\nprivate final boolean parkAndCheckInterrupt() &#123;\n    LockSupport.park(this);\n    return Thread.interrupted();\n&#125;</code></pre>\n\n<p>独占锁 acquire 获取的过程，如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649588516655-5cee77db-adfa-4178-b280-d4c73d94135c.png#clientId=u62baf52a-5843-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua0bc3798&margin=%5Bobject%20Object%5D&name=image.png&originHeight=628&originWidth=644&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=49845&status=done&style=none&taskId=u94f0a047-bfa4-4d89-9711-3937c0917a6&title=\" alt=\"image.png\"></p>\n<h3 id=\"AQS-释放独占锁\"><a href=\"#AQS-释放独占锁\" class=\"headerlink\" title=\"AQS 释放独占锁\"></a>AQS 释放独占锁</h3><p>1、tryRelease 释放锁，没有释放成功，返回 false<br>2、锁释放成功，唤醒 head 的后继节点，返回 true</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final boolean release(int arg) &#123;\n    if (tryRelease(arg)) &#123;\n        Node h &#x3D; head;\n        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)\n            unparkSuccessor(h);&#x2F;&#x2F;unblock，唤醒head的后继节点\n        return true;\n    &#125;\n    return false;\n&#125;\n\nprivate void unparkSuccessor(Node node) &#123;\n    &#x2F;*\n     * 状态为负数，清除信号，设置成0\n     *&#x2F;\n    int ws &#x3D; node.waitStatus;\n    if (ws &lt;0)\n        compareAndSetWaitStatus(node, ws, 0);\n    &#x2F;*\n     * 唤醒后继节点（一般是下一个节点)，如果节点被取消或者为null\n     * 反向遍历从尾到头找到实际的非取消的后继节点（问题：为什么不正向遍历）\n     *&#x2F;\n    Node s &#x3D; node.next;\n    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;\n        s &#x3D; null;\n        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)\n            if (t.waitStatus &lt;&#x3D; 0)\n                s &#x3D; t;\n    &#125;\n    if (s !&#x3D; null)\n        LockSupport.unpark(s.thread);\n&#125;</code></pre>\n\n<p>释放锁的过程如下图所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649588516660-6ebd55d4-9b5c-406b-afac-702d0242a43b.png#clientId=u62baf52a-5843-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u72e622c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=507&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=28849&status=done&style=none&taskId=ue26c6f4f-943e-4912-ac16-c067c441718&title=\" alt=\"image.png\"></p>\n<h2 id=\"3、公平锁和非公平锁\"><a href=\"#3、公平锁和非公平锁\" class=\"headerlink\" title=\"3、公平锁和非公平锁\"></a>3、公平锁和非公平锁</h2><p>两种锁都继承 Sync，而 Sync 又继承 AbstractQueuedSynchronizer ，所以子类必须实现 AQS 的 5 个保护方法。<br>对于独占锁，需要实现 tryAcquire，tryRelease，isHeldExclusively 这 3 个方法，<br>其中 tryRelease，isHeldExclusively 是公平锁和非公平锁共有的，在 Sync 中实现。<br>1、tryRelease 尝试释放锁，每调用 tryRelease(1)一次，将 state 减去 1，当 state 为 0 的时候，释放锁成功，将独占锁的 owner 设为 null。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean tryRelease(int releases) &#123;\n    int c &#x3D; getState() - releases;\n    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free &#x3D; false;\n    if (c &#x3D;&#x3D; 0) &#123;\n        free &#x3D; true;\n        setExclusiveOwnerThread(null);\n    &#125;\n    setState(c);\n    return free;\n&#125;</code></pre>\n\n<p>2、isHeldExclusively 判断独占锁的 owner 是不是当前线程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean isHeldExclusively() &#123;\n    return getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread();\n&#125;</code></pre>\n\n<h3 id=\"非公平锁\"><a href=\"#非公平锁\" class=\"headerlink\" title=\"非公平锁\"></a>非公平锁</h3><p>现在我们来看 NonfairSync 加锁的策略<br>1、查看同步队列锁的 state，不通过同步队列，通过 CAS 抢占独占锁，抢占成功，将当前线程设置成独占线程，state 增加 1。<br>2、获取不成功，走普通的获取锁的流程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final void lock() &#123;\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n&#125;</code></pre>\n\n<p>其中 NonfairSync 在 acquire 获取锁的过程中，调用 tryAcquire 尝试获取锁。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean tryAcquire(int acquires) &#123;\n    return nonfairTryAcquire(acquires);\n&#125;</code></pre>\n\n<p>在看 Sync 的 nonfairTryAcquire 方法实现如下，直接通过 CAS 获取锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final boolean nonfairTryAcquire(int acquires) &#123;\n    final Thread current &#x3D; Thread.currentThread();\n    int c &#x3D; getState();\n    &#x2F;* 锁没有被占用，将当前线程设置成独占锁的owner\n    if (c &#x3D;&#x3D; 0) &#123;\n        if (compareAndSetState(0, acquires)) &#123;\n            setExclusiveOwnerThread(current);\n            return true;\n        &#125;\n    &#125;\n    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;\n        &#x2F;* 增加独占锁的被线程的加锁次数 *&#x2F;\n        int nextc &#x3D; c + acquires;\n        if (nextc &lt;0) &#x2F;&#x2F; overflow\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<h3 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h3><p>了解非公平锁的获取过程，我们再看下公平锁的加锁过程，了解其区别</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final void lock() &#123;\n    acquire(1);\n&#125;</code></pre>\n\n<p>通过 acquire 获取锁，没有像非公平锁通过 CAS 操作，直接抢占独占锁。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean tryAcquire(int acquires) &#123;\n    final Thread current &#x3D; Thread.currentThread();\n    int c &#x3D; getState();\n    if (c &#x3D;&#x3D; 0) &#123;\n        &#x2F;* hasQueuedPredecessors判断是否有比当前线程等待更久的线程在等待\n         * 没有的话则通过CAS获取锁\n         *&#x2F;\n        if (!hasQueuedPredecessors() &amp;&amp;\n            compareAndSetState(0, acquires)) &#123;\n            setExclusiveOwnerThread(current);\n            return true;\n        &#125;\n    &#125;\n    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;\n        int nextc &#x3D; c + acquires;\n        if (nextc &lt;0)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<p>从上面的代码可以看出<br>1、公平锁与非公平锁的释放锁步骤是一致的<br>2、获取锁的过程不一致，非公平锁是让当前线程优先独占，而公平锁则是让等待时间最长的线程优先，非公平的可能让其他线程没机会执行，而公平的则可以让等待时间最长的先执行，但是性能上会差点。</p>\n","more":"<p>ReentrantLock 的功能是实现代码段的并发访问控制，是一种排它锁，也就是通常意义上所说的锁，内部有两种实现 NonfairSync 和 FairSync，公平锁和非公平锁，默认采用非公平锁策略。ReentrantLock 的实现不仅可以替代隐式的 synchronized 关键字，而且能够提供超过关键字本身的多种功能。</p>\n<h2 id=\"1、ReentrantLock-的使用\"><a href=\"#1、ReentrantLock-的使用\" class=\"headerlink\" title=\"1、ReentrantLock 的使用\"></a>1、ReentrantLock 的使用</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class X &#123;\n  private final ReentrantLock lock &#x3D; new ReentrantLock();\n  &#x2F;&#x2F; ...\n\n  public void m() &#123;\n    lock.lock();  &#x2F;&#x2F; block until condition holds\n    try &#123;\n      &#x2F;&#x2F; ... method body\n    &#125; finally &#123;\n      lock.unlock()\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<p><strong>ReentrantLock 会保证 method-body 在同一时间只有一个线程在执行这段代码</strong>，或者说，同一时刻只有一个线程的 lock 方法会返回。其余线程会被挂起，直到获取锁。从这里可以看出，其实 ReentrantLock 实现的就是一个独占锁的功能：有且只有一个线程获取到锁，其余线程全部挂起，直到该拥有锁的线程释放锁，被挂起的线程被唤醒重新开始竞争锁。那现在看下 Doug Lea 怎么去实现 ReentrantLock 重入锁的。首先看下 ReentrantLock 的创建和加锁、解锁过程。</p>\n<h2 id=\"2、ReentrantLock-原理分析\"><a href=\"#2、ReentrantLock-原理分析\" class=\"headerlink\" title=\"2、ReentrantLock 原理分析\"></a>2、ReentrantLock 原理分析</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 默认非公平锁\n *&#x2F;\npublic ReentrantLock() &#123;\n    sync &#x3D; new NonfairSync();\n&#125; &#x2F;**\n * 创建ReentrantLock，公平锁or非公平锁\n*&#x2F;\npublic ReentrantLock(boolean fair) &#123;\n    sync &#x3D; fair ? new FairSync() : new NonfairSync();\n&#125;\n\n&#x2F;**\n *加锁解锁，使用sync完成\n*&#x2F;\npublic void lock() &#123;\n    sync.lock();\n&#125;\npublic void unlock() &#123;\n    sync.release(1);\n&#125;</code></pre>\n\n<p>其中，公平锁中每个线程抢占锁的顺序为先后调用 lock 方法的顺序依次获取锁。非公平锁中每个线程抢占锁的顺序不定，先获取锁，获取不到，然后加入到 queue 中，和调用 lock 方法的先后顺序无关。<br>如果在绝对时间上，先对锁进行获取的请求一定被先满足，那么这个锁是公平的，反之，是不公平的，也就是说等待时间最长的线程最有机会获取锁，也可以说锁的获取是有序的。ReentrantLock 这个锁提供了一个构造函数，能够控制这个锁是否是公平的。而锁的名字也是说明了这个锁具备了重复进入的可能，也就是说能够让当前线程多次的进行对锁的获取操作，这样的最大次数限制是 Integer.MAX_VALUE，约 21 亿次左右。<br>事实上公平的锁机制往往没有非公平的效率高，因为公平的获取锁没有考虑到操作系统对线程的调度因素，这样造成 JVM 对于等待中的线程调度次序和操作系统对线程的调度之间的不匹配。对于锁的快速且重复的获取过程中，连续获取的概率是非常高的，而公平锁会压制这种情况，虽然公平性得以保障，但是响应比却下降了，但是并不是任何场景都是以 TPS 作为唯一指标的，因为公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。</p>\n<h3 id=\"AQS-的队列操作\"><a href=\"#AQS-的队列操作\" class=\"headerlink\" title=\"AQS 的队列操作\"></a>AQS 的队列操作</h3><p>在分析加锁前，先看下 AQS 的入队列操作， head，tail 节点默认为 null，入队列时，当 tail 为 null 时，初始化创建 dummy head 节点，将入队列的 node 插入队尾。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Creates and enqueues node for given thread and mode.\n * 节点入同步队列，通过CAS比较然后插入队列尾部，\n * @param current the thread\n * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared\n * @return the new node\n *&#x2F;\nprivate Node addWaiter(Node mode) &#123;\n    Node node &#x3D; new Node(Thread.currentThread(), mode);\n    &#x2F;&#x2F; 快速入队列,tail不为null，通过CAS比较然后插入队列尾部 Node pred &#x3D; tail;\n    if (pred !&#x3D; null) &#123;\n        node.prev &#x3D; pred;\n        if (compareAndSetTail(pred, node)) &#123;\n            pred.next &#x3D; node;\n            return node;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;快速入队列失败后执行enq方法\n    enq(node);\n    return node;\n&#125;\n\n&#x2F;**\n * 插入节点到队列中，必要的时候初始化头节点，返回该节点前驱\n * @param node the node to insert\n * @return node&#39;s predecessor\n *&#x2F;\nprivate Node enq(final Node node) &#123;\n    for (;;) &#123;\n        Node t &#x3D; tail;\n        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 初始化，创建Dummy header，thread为null\n            if (compareAndSetHead(new Node()))\n                tail &#x3D; head;\n        &#125; else &#123;\n            node.prev &#x3D; t;\n            if (compareAndSetTail(t, node)) &#123;\n                t.next &#x3D; node;\n                return t;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"AQS-获取锁定-独占锁\"><a href=\"#AQS-获取锁定-独占锁\" class=\"headerlink\" title=\"AQS 获取锁定(独占锁)\"></a>AQS 获取锁定(独占锁)</h3><p>调用 acquire 方法，其实这个方法是阻塞的, 获取锁的步骤为：<br>1、 tryAcquire（由子类 Sync 实现）尝试获取锁<br>2、 没有获取到锁，将节点加入到队列尾部中，加入成功 selfInterrupt，中断当前线程。<br>ReentrantLock，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1650856752907-aa48a20e-51da-401f-830d-e940b1b0c650.png#clientId=u47a90b62-dbe9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=344&id=u9774d715&margin=%5Bobject%20Object%5D&name=image.png&originHeight=344&originWidth=595&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=17143&status=done&style=none&taskId=u38557c22-fb44-4ca4-88cb-451b1757914&title=&width=595\" alt=\"image.png\"><br><strong>独占模式下的 AQS 是不响应中断的</strong> ，指的是加入到同步队列中的线程，如果因为中断而被唤醒的话，不会立即返回，并且抛出 InterruptedException。而是再次去判断其前驱节点是否为 head 节点，决定是否争抢同步状态。如果其前驱节点不是 head 节点或者争抢同步状态失败，那么再次挂起。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void acquire(int arg)  &#123;\n    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n&#125;</code></pre>\n\n<p>没有获取到锁则调用 AQS 的 acquireQueued 方法：<br>1、当 node 的前驱节点是头节点，并且独占时才返回<br>2、前继节点不是 head, 而且当你的前继节点状态是 Node.SIGNAL 时， 你这个线程将被 park()，直到另外的线程 release 时,发现 head.next 是你这个 node 时才 unpark，才能继续循环并获取锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final boolean acquireQueued(final Node node, int arg) &#123;\n    boolean failed &#x3D; true;\n    try &#123;\n        boolean interrupted &#x3D; false;\n        for (;;) &#123;\n            final Node p &#x3D; node.predecessor();\n            &#x2F;* 当node的前驱节点是头节点，并且独占时才返回 *&#x2F;\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC，队列中移除头节点p\n                failed &#x3D; false;\n                return interrupted;\n            &#125;\n            &#x2F;* 阻塞并判断是否打断，其实这个判断才是自旋锁真正的猥琐点，\n             * 意思是如果你的前继节点不是head,\n             * 而且当你的前继节点状态是Node.SIGNAL时，\n             * 你这个线程将被park()，\n             * 直到另外的线程release时,发现head.next是你这个node时，才unpark，\n             * 才能继续循环并获取锁\n             *&#x2F;\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                interrupted &#x3D; true;\n        &#125;\n    &#125; finally &#123;\n        if (failed)\n            cancelAcquire(node);\n    &#125;\n&#125;</code></pre>\n\n<p>shouldParkAfterFailedAcquire 这个方法删除所有 waitStatus&gt;0 也就是 CANCELLED 状态的 Node,并设置前继节点为 signal</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;\n    int ws &#x3D; pred.waitStatus;\n    if (ws &#x3D;&#x3D; Node.SIGNAL)\n        &#x2F;*\n         * 节点已经设置状态Node.SIGNAL，\n         * 请求释放使它获取信号，所以它才能安全的park\n         *&#x2F;\n        return true;\n    if (ws &gt; 0) &#123;\n        &#x2F;*\n         *前驱节点被取消，跳过所有的取消的前驱节点和表明重试\n         *&#x2F;\n        do &#123;\n            node.prev &#x3D; pred &#x3D; pred.prev;\n        &#125; while (pred.waitStatus &gt; 0);\n        pred.next &#x3D; node;\n    &#125; else &#123;\n        &#x2F;*\n         * waitStatus为0或者PROPAGATE,表明我们需要一个信号，但是还没有park，\n         * 调用者需要重试，保证在parking过程中，它不能被获取到\n         *&#x2F;\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    &#125;\n    return false;\n&#125;\n\n&#x2F;* 禁用当前线程，返回是否中断 *&#x2F;\nprivate final boolean parkAndCheckInterrupt() &#123;\n    LockSupport.park(this);\n    return Thread.interrupted();\n&#125;</code></pre>\n\n<p>独占锁 acquire 获取的过程，如下所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649588516655-5cee77db-adfa-4178-b280-d4c73d94135c.png#clientId=u62baf52a-5843-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua0bc3798&margin=%5Bobject%20Object%5D&name=image.png&originHeight=628&originWidth=644&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=49845&status=done&style=none&taskId=u94f0a047-bfa4-4d89-9711-3937c0917a6&title=\" alt=\"image.png\"></p>\n<h3 id=\"AQS-释放独占锁\"><a href=\"#AQS-释放独占锁\" class=\"headerlink\" title=\"AQS 释放独占锁\"></a>AQS 释放独占锁</h3><p>1、tryRelease 释放锁，没有释放成功，返回 false<br>2、锁释放成功，唤醒 head 的后继节点，返回 true</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final boolean release(int arg) &#123;\n    if (tryRelease(arg)) &#123;\n        Node h &#x3D; head;\n        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)\n            unparkSuccessor(h);&#x2F;&#x2F;unblock，唤醒head的后继节点\n        return true;\n    &#125;\n    return false;\n&#125;\n\nprivate void unparkSuccessor(Node node) &#123;\n    &#x2F;*\n     * 状态为负数，清除信号，设置成0\n     *&#x2F;\n    int ws &#x3D; node.waitStatus;\n    if (ws &lt;0)\n        compareAndSetWaitStatus(node, ws, 0);\n    &#x2F;*\n     * 唤醒后继节点（一般是下一个节点)，如果节点被取消或者为null\n     * 反向遍历从尾到头找到实际的非取消的后继节点（问题：为什么不正向遍历）\n     *&#x2F;\n    Node s &#x3D; node.next;\n    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;\n        s &#x3D; null;\n        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)\n            if (t.waitStatus &lt;&#x3D; 0)\n                s &#x3D; t;\n    &#125;\n    if (s !&#x3D; null)\n        LockSupport.unpark(s.thread);\n&#125;</code></pre>\n\n<p>释放锁的过程如下图所示<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649588516660-6ebd55d4-9b5c-406b-afac-702d0242a43b.png#clientId=u62baf52a-5843-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u72e622c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=507&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=28849&status=done&style=none&taskId=ue26c6f4f-943e-4912-ac16-c067c441718&title=\" alt=\"image.png\"></p>\n<h2 id=\"3、公平锁和非公平锁\"><a href=\"#3、公平锁和非公平锁\" class=\"headerlink\" title=\"3、公平锁和非公平锁\"></a>3、公平锁和非公平锁</h2><p>两种锁都继承 Sync，而 Sync 又继承 AbstractQueuedSynchronizer ，所以子类必须实现 AQS 的 5 个保护方法。<br>对于独占锁，需要实现 tryAcquire，tryRelease，isHeldExclusively 这 3 个方法，<br>其中 tryRelease，isHeldExclusively 是公平锁和非公平锁共有的，在 Sync 中实现。<br>1、tryRelease 尝试释放锁，每调用 tryRelease(1)一次，将 state 减去 1，当 state 为 0 的时候，释放锁成功，将独占锁的 owner 设为 null。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean tryRelease(int releases) &#123;\n    int c &#x3D; getState() - releases;\n    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free &#x3D; false;\n    if (c &#x3D;&#x3D; 0) &#123;\n        free &#x3D; true;\n        setExclusiveOwnerThread(null);\n    &#125;\n    setState(c);\n    return free;\n&#125;</code></pre>\n\n<p>2、isHeldExclusively 判断独占锁的 owner 是不是当前线程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean isHeldExclusively() &#123;\n    return getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread();\n&#125;</code></pre>\n\n<h3 id=\"非公平锁\"><a href=\"#非公平锁\" class=\"headerlink\" title=\"非公平锁\"></a>非公平锁</h3><p>现在我们来看 NonfairSync 加锁的策略<br>1、查看同步队列锁的 state，不通过同步队列，通过 CAS 抢占独占锁，抢占成功，将当前线程设置成独占线程，state 增加 1。<br>2、获取不成功，走普通的获取锁的流程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final void lock() &#123;\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n&#125;</code></pre>\n\n<p>其中 NonfairSync 在 acquire 获取锁的过程中，调用 tryAcquire 尝试获取锁。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean tryAcquire(int acquires) &#123;\n    return nonfairTryAcquire(acquires);\n&#125;</code></pre>\n\n<p>在看 Sync 的 nonfairTryAcquire 方法实现如下，直接通过 CAS 获取锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final boolean nonfairTryAcquire(int acquires) &#123;\n    final Thread current &#x3D; Thread.currentThread();\n    int c &#x3D; getState();\n    &#x2F;* 锁没有被占用，将当前线程设置成独占锁的owner\n    if (c &#x3D;&#x3D; 0) &#123;\n        if (compareAndSetState(0, acquires)) &#123;\n            setExclusiveOwnerThread(current);\n            return true;\n        &#125;\n    &#125;\n    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;\n        &#x2F;* 增加独占锁的被线程的加锁次数 *&#x2F;\n        int nextc &#x3D; c + acquires;\n        if (nextc &lt;0) &#x2F;&#x2F; overflow\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<h3 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h3><p>了解非公平锁的获取过程，我们再看下公平锁的加锁过程，了解其区别</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final void lock() &#123;\n    acquire(1);\n&#125;</code></pre>\n\n<p>通过 acquire 获取锁，没有像非公平锁通过 CAS 操作，直接抢占独占锁。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean tryAcquire(int acquires) &#123;\n    final Thread current &#x3D; Thread.currentThread();\n    int c &#x3D; getState();\n    if (c &#x3D;&#x3D; 0) &#123;\n        &#x2F;* hasQueuedPredecessors判断是否有比当前线程等待更久的线程在等待\n         * 没有的话则通过CAS获取锁\n         *&#x2F;\n        if (!hasQueuedPredecessors() &amp;&amp;\n            compareAndSetState(0, acquires)) &#123;\n            setExclusiveOwnerThread(current);\n            return true;\n        &#125;\n    &#125;\n    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;\n        int nextc &#x3D; c + acquires;\n        if (nextc &lt;0)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    &#125;\n    return false;\n&#125;</code></pre>\n\n<p>从上面的代码可以看出<br>1、公平锁与非公平锁的释放锁步骤是一致的<br>2、获取锁的过程不一致，非公平锁是让当前线程优先独占，而公平锁则是让等待时间最长的线程优先，非公平的可能让其他线程没机会执行，而公平的则可以让等待时间最长的先执行，但是性能上会差点。</p>\n","categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]}