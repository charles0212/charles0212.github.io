{"title":"JVM（三）内存分配与回收策略","slug":"yuque/JVM（三）内存分配与回收策略","date":"2016-07-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.489Z","comments":true,"path":"api/articles/jvm/jvm-gc-allocation.json","excerpt":"对象的分配的细节取决于当前使用哪一种垃圾收集器组合，以及和内存相关参数有关，本文主要讨论Serial/SerialOld收集器的内存分配和回收的策略，其他几种垃圾收集器可以自己去探讨。先介绍下 MinorGC 和FullGC 的概念。新生代 GC（MinorGC）:发生在新生代，Java对象大多都有朝生夕死的特性，MinorGC非常频繁，回收速度也比较快。老年代GC（MajorGC/FullGC）:发生在老年代，出现 MajorGC经常至少伴随一次的MinorGC，但非绝对。MajorGC的速度一般比 MinorGC 慢 10倍以上。下面是最普遍的内存分配规则","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648398550331-f66fe7ce-115e-4b49-bdcc-f17ee4cc2a0b.png#clientId=uc6b6d1e2-f7d5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3769d526&margin=%5Bobject%20Object%5D&name=image.png&originHeight=269&originWidth=626&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=15172&status=done&style=none&taskId=u60ea5eca-8ee0-4d4c-b13f-2a9271bd3b0&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648398550385-d0b55dea-87c7-4f39-8f90-b57013c543bf.png#clientId=uc6b6d1e2-f7d5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u59b841d2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=357&originWidth=723&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=31084&status=done&style=none&taskId=ub70f10b6-edf4-40a0-9701-0aaa3ad6b09&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648398550299-cad9a607-6e9f-4ab8-a9ef-04dee9a81e74.png#clientId=uc6b6d1e2-f7d5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u30b7ea0d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=151&originWidth=726&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=14065&status=done&style=none&taskId=u27f99744-0684-4846-a839-f4a029094c2&title="],"content":"<p>对象的分配的细节取决于当前使用哪一种垃圾收集器组合，以及和内存相关参数有关，本文主要讨论 Serial&#x2F;SerialOld 收集器的内存分配和回收的策略，其他几种垃圾收集器可以自己去探讨。<br>先介绍下 MinorGC 和 FullGC 的概念。<br><strong>新生代 GC（MinorGC</strong>）: 发生在新生代，Java 对象大多都有朝生夕死的特性，MinorGC 非常频繁，回收速度也比较快。<br><strong>老年代 GC（MajorGC&#x2F;FullGC）</strong>: 发生在老年代，出现 MajorGC 经常至少伴随一次的 MinorGC，但非绝对。MajorGC 的速度一般比 MinorGC 慢 10 倍以上。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648398550331-f66fe7ce-115e-4b49-bdcc-f17ee4cc2a0b.png#clientId=uc6b6d1e2-f7d5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3769d526&margin=%5Bobject%20Object%5D&name=image.png&originHeight=269&originWidth=626&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=15172&status=done&style=none&taskId=u60ea5eca-8ee0-4d4c-b13f-2a9271bd3b0&title=\" alt=\"image.png\"><br>下面是最普遍的内存分配规则。</p>\n<h2 id=\"1、对象优先在-eden-分配\"><a href=\"#1、对象优先在-eden-分配\" class=\"headerlink\" title=\"1、对象优先在 eden 分配\"></a>1、对象优先在 eden 分配</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 对象优先在Eden分配\n * vm参数，新生代10M, eden区8M，surivior区1M(from,to)\n * -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio&#x3D;8 -XX:+UseSerialGC -XX:+PrintGCDetails\n *&#x2F;\npublic static void testAllocation() &#123;\n    byte[] allocation1, allocation2 ,allocation3 ,allocation4;\n    allocation1 &#x3D; new byte[2 * _1MB];\n    allocation2 &#x3D; new byte[2 * _1MB];\n    allocation3 &#x3D; new byte[2 * _1MB];\n    allocation4 &#x3D; new byte[4 * _1MB]; &#x2F;&#x2F;出现一次Minor GC\n&#125;</code></pre>\n\n<p>使用串行垃圾回收，新生代 10M, eden 区 8M，surivior 区 1M(from,to)<br>从输出结果看 执行 allocation4 &#x3D; new byte[4 * _1MB];会发生一次 GC，GC 的结果是 7458K→601K，而总内存占用量几乎没有减少，因为 allocation1，allocation2，allocation3 都是存活，发现 Eden 区已经占用了 6M，剩余空间不足以分配 allocation4 的 4M 的空间，因此发生 MinorGC，GC 期间发现已有的 3 个 2MB 大小的对象无法放入到 Survivor 空间（只有 1M 大小），所以只好通过分配担保机制提前转移到老年代中去。<br>GC 结束后， eden 被占用 4M（allocation4），survivor 空闲，老年代占用 6M （allocation1，allocation2，allocation3） 。</p>\n<h2 id=\"2、大对象直接进入老年代\"><a href=\"#2、大对象直接进入老年代\" class=\"headerlink\" title=\"2、大对象直接进入老年代\"></a>2、大对象直接进入老年代</h2><p>虚拟机提供-XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做可以避免在 Eden 和两个 Survivor 区域之间发生大量的内存复制操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 大对象直接进入老年代\n * vm参数，新生代10M, eden区8M，surivior区1M(from,to)\n * -XX:PretenureSizeThreshold&#x3D;3145728 -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio&#x3D;8 -XX:+UseSerialGC\n *&#x2F;\npublic static void testPretenureSizeThreshold() &#123;\n    byte[] allocation;\n    allocation &#x3D; new byte[4 * _1MB]; &#x2F;&#x2F;直接分配在老年代(大于3M)\n&#125;</code></pre>\n\n<p>PretenureSizeThreshold 参数在 UseParallelGC 或者 UseG1GC 的时候都是不起作用的，只在 Serial 和 ParNew 新生代收集器中有效。</p>\n<h2 id=\"3、长期存活对象将进入老年代\"><a href=\"#3、长期存活对象将进入老年代\" class=\"headerlink\" title=\"3、长期存活对象将进入老年代\"></a>3、长期存活对象将进入老年代</h2><p>对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold 设置，当对象达到这个年龄后就将进入老年代。<br>如果对象在 Eden 出生并且经过第一次 MinorGC 后仍然存活，并且能够被 Survivor 容纳的话，被移动到 Survivor 空间中，并将对象年龄设置成 1，对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁。年龄到一定程度（默认为 15 岁），就会被晋升到到老年代中。可以通过参数-XX:MaxTenuringThreshold 设置。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 长期存活的对象进入老年代\n * vm参数，新生代10M, eden区16M，surivior区2M(from,to)\n * -XX:MaxTenuringThreshold&#x3D;1 -Xms40M -Xmx40M -Xmn20M -XX:SurvivorRatio&#x3D;8 -XX:+UseSerialGC  -XX:+PrintTenuringDistribution -XX:+PrintGCDetails\n *&#x2F;\npublic static void testTenuringThreshold() &#123;\n    byte[] allocation1, allocation2 ,allocation3;\n    allocation1 &#x3D; new byte[1&#x2F;2 * _1MB];\n    &#x2F;&#x2F; 什么时候进入老年代取决于MaxTenuringThreshold的设置\n    allocation2 &#x3D; new byte[8 * _1MB];\n    allocation3 &#x3D; new byte[8 * _1MB];\n    allocation3 &#x3D; null;\n    allocation3 &#x3D; new byte[8 * _1MB];\n&#125;</code></pre>\n\n<p>-XX:MaxTenuringThreshold&#x3D;1 -XX:MaxTenuringThreshold&#x3D;15 发生了两次 Minor GC，第一次是在给 allocation3 进行分配的时候会出现一次 Minor GC，此时 survivor 区域不能容纳 allocation2，但是可以容纳 allocation1，所以 allocation1 将会进入 survivor 区域并且年龄为 1，达到了阈值，将在下一次 GC 时晋升到老年代，而 allocation2 则会通过担保机制进入老年代。第二次发生 GC 是在第二次给 allocation3 分配空间时，这时，allocation1 的年龄加 1，晋升到老年代，此次 GC 也可以清理出原来 allocation3 占据的 4MB 空间，将 allocation3 分配在 Eden 区。所以，最后的结果是 allocation1、allocation2 在老年代，allocation3 在 Eden 区。</p>\n<h2 id=\"4、动态对象年龄判定\"><a href=\"#4、动态对象年龄判定\" class=\"headerlink\" title=\"4、动态对象年龄判定\"></a>4、动态对象年龄判定</h2><p>为了更好地适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代；如果在 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 动态对象年龄判断\n * vm参数，新生代10M, eden区16M，surivior区2M(from,to)\n * -Xms40M -Xmx40M -Xmn20M -XX:SurvivorRatio&#x3D;8 -XX:+UseSerialGC -XX:+PrintTenuringDistribution -XX:+PrintGCDetails\n *&#x2F;\npublic static void testDynamicTenuringThreshold() &#123;\n    byte[] allocation1, allocation2 ,allocation3,allocation4;\n    allocation1 &#x3D; new byte[_1MB &#x2F; 2];\n    allocation2 &#x3D; new byte[_1MB &#x2F; 2];\n    &#x2F;&#x2F; allocation1 + allocation2 大于surivior空间的一半\n    allocation3 &#x3D; new byte[8 * _1MB];\n    allocation4 &#x3D; new byte[8 * _1MB];\n    allocation4 &#x3D; null;\n    allocation4 &#x3D; new byte[8 * _1MB];\n&#125;</code></pre>\n\n<p>发生了两次 Minor GC，第一次发生在给 allocation4 分配内存时，此时 allocation1、allocation2 将会进入 survivor 区，而 allocation3 通过担保机制将会进入老年代。第二次发生在给 allocation4 分配内存时，此时，survivor 区的 allocation1、allocation2 达到了 survivor 区容量的一半，将会进入老年代，此次 GC 可以清理出 allocation4 原来的 4MB 空间，并将 allocation4 分配在 Eden 区。最终，allocation1、allocation2、allocation3 在老年代，allocation4 在 Eden 区。</p>\n<h2 id=\"5、空间分配担保\"><a href=\"#5、空间分配担保\" class=\"headerlink\" title=\"5、空间分配担保\"></a>5、空间分配担保</h2><h3 id=\"jdk1-6-update24-之前的担保流程\"><a href=\"#jdk1-6-update24-之前的担保流程\" class=\"headerlink\" title=\"jdk1.6 update24 之前的担保流程\"></a>jdk1.6 update24 之前的担保流程</h3><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行一次 Minor GC。如果小于或者没有设置 HandlePromotionFailure，则要进行一次 Full GC。<br>取平均值进行比较其实仍然是一种动态概率的手段，如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败。如果出现了 HandlePromotionFailure 失败，则会重新发起一次 Full GC，大部分情况都会将 HandlePromotionFailure 打开，避免过于频繁的 Full GC。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648398550385-d0b55dea-87c7-4f39-8f90-b57013c543bf.png#clientId=uc6b6d1e2-f7d5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u59b841d2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=357&originWidth=723&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=31084&status=done&style=none&taskId=ub70f10b6-edf4-40a0-9701-0aaa3ad6b09&title=\" alt=\"image.png\"></p>\n<h3 id=\"jdk1-6-update24-之后的担保流程\"><a href=\"#jdk1-6-update24-之后的担保流程\" class=\"headerlink\" title=\"jdk1.6 update24 之后的担保流程\"></a>jdk1.6 update24 之后的担保流程</h3><p>在 jdk1.6 update24 之后，HandlePromotionFailure 参数不会影响虚拟机空间分配担保策略，虚拟机改为，只要老年代最大连续空间大于新生代对象总和或者大于历次晋升平均大小，都将进行 minor gc，否则将进行 Full gc。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648398550299-cad9a607-6e9f-4ab8-a9ef-04dee9a81e74.png#clientId=uc6b6d1e2-f7d5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u30b7ea0d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=151&originWidth=726&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=14065&status=done&style=none&taskId=u27f99744-0684-4846-a839-f4a029094c2&title=\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 空间分配担保\n * vm参数，新生代10M, eden区8M，surivior区1M(from,to)\n * -XX:HandlePromotionFailure\n * -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintTenuringDistribution -XX:SurvivorRatio&#x3D;8\n *&#x2F;\npublic static void testHandlePromotionFailure() &#123;\n    byte[] allocation1, allocation2 ,allocation3,allocation4, allocation5, allocation6 ,allocation7;\n    allocation1 &#x3D; new byte[2 * _1MB];\n    allocation2 &#x3D; new byte[2 * _1MB];\n    allocation3 &#x3D; new byte[2 * _1MB];\n    allocation1 &#x3D; null;\n    allocation4 &#x3D; new byte[2 * _1MB];\n    allocation5 &#x3D; new byte[2 * _1MB];\n    allocation6 &#x3D; new byte[2 * _1MB];\n    allocation4 &#x3D; null;\n    allocation5 &#x3D; null;\n    allocation6 &#x3D; null;\n    allocation7 &#x3D; new byte[2 * _1MB];\n&#125;</code></pre>\n\n<p>发生了两次 GC，第一次发生在给 allocation4 分配内存空间时，由于老年代的连续可用空间大于存活的对象总和， 所以 allocation2、allocation3 将会进入老年代，allocation1 的空间将被回收，allocation4 分配在新生代；第二次发生在给 allocation7 分配内存空间时，此次 GC 将 allocation4、allocation5、allocation6 所占的内存全部回收。最后，allocation2、allocation3 在老年代，allocation7 在新生代。</p>\n","more":"<p>对象的分配的细节取决于当前使用哪一种垃圾收集器组合，以及和内存相关参数有关，本文主要讨论 Serial&#x2F;SerialOld 收集器的内存分配和回收的策略，其他几种垃圾收集器可以自己去探讨。<br>先介绍下 MinorGC 和 FullGC 的概念。<br><strong>新生代 GC（MinorGC</strong>）: 发生在新生代，Java 对象大多都有朝生夕死的特性，MinorGC 非常频繁，回收速度也比较快。<br><strong>老年代 GC（MajorGC&#x2F;FullGC）</strong>: 发生在老年代，出现 MajorGC 经常至少伴随一次的 MinorGC，但非绝对。MajorGC 的速度一般比 MinorGC 慢 10 倍以上。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648398550331-f66fe7ce-115e-4b49-bdcc-f17ee4cc2a0b.png#clientId=uc6b6d1e2-f7d5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3769d526&margin=%5Bobject%20Object%5D&name=image.png&originHeight=269&originWidth=626&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=15172&status=done&style=none&taskId=u60ea5eca-8ee0-4d4c-b13f-2a9271bd3b0&title=\" alt=\"image.png\"><br>下面是最普遍的内存分配规则。</p>\n<h2 id=\"1、对象优先在-eden-分配\"><a href=\"#1、对象优先在-eden-分配\" class=\"headerlink\" title=\"1、对象优先在 eden 分配\"></a>1、对象优先在 eden 分配</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 对象优先在Eden分配\n * vm参数，新生代10M, eden区8M，surivior区1M(from,to)\n * -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio&#x3D;8 -XX:+UseSerialGC -XX:+PrintGCDetails\n *&#x2F;\npublic static void testAllocation() &#123;\n    byte[] allocation1, allocation2 ,allocation3 ,allocation4;\n    allocation1 &#x3D; new byte[2 * _1MB];\n    allocation2 &#x3D; new byte[2 * _1MB];\n    allocation3 &#x3D; new byte[2 * _1MB];\n    allocation4 &#x3D; new byte[4 * _1MB]; &#x2F;&#x2F;出现一次Minor GC\n&#125;</code></pre>\n\n<p>使用串行垃圾回收，新生代 10M, eden 区 8M，surivior 区 1M(from,to)<br>从输出结果看 执行 allocation4 &#x3D; new byte[4 * _1MB];会发生一次 GC，GC 的结果是 7458K→601K，而总内存占用量几乎没有减少，因为 allocation1，allocation2，allocation3 都是存活，发现 Eden 区已经占用了 6M，剩余空间不足以分配 allocation4 的 4M 的空间，因此发生 MinorGC，GC 期间发现已有的 3 个 2MB 大小的对象无法放入到 Survivor 空间（只有 1M 大小），所以只好通过分配担保机制提前转移到老年代中去。<br>GC 结束后， eden 被占用 4M（allocation4），survivor 空闲，老年代占用 6M （allocation1，allocation2，allocation3） 。</p>\n<h2 id=\"2、大对象直接进入老年代\"><a href=\"#2、大对象直接进入老年代\" class=\"headerlink\" title=\"2、大对象直接进入老年代\"></a>2、大对象直接进入老年代</h2><p>虚拟机提供-XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做可以避免在 Eden 和两个 Survivor 区域之间发生大量的内存复制操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 大对象直接进入老年代\n * vm参数，新生代10M, eden区8M，surivior区1M(from,to)\n * -XX:PretenureSizeThreshold&#x3D;3145728 -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio&#x3D;8 -XX:+UseSerialGC\n *&#x2F;\npublic static void testPretenureSizeThreshold() &#123;\n    byte[] allocation;\n    allocation &#x3D; new byte[4 * _1MB]; &#x2F;&#x2F;直接分配在老年代(大于3M)\n&#125;</code></pre>\n\n<p>PretenureSizeThreshold 参数在 UseParallelGC 或者 UseG1GC 的时候都是不起作用的，只在 Serial 和 ParNew 新生代收集器中有效。</p>\n<h2 id=\"3、长期存活对象将进入老年代\"><a href=\"#3、长期存活对象将进入老年代\" class=\"headerlink\" title=\"3、长期存活对象将进入老年代\"></a>3、长期存活对象将进入老年代</h2><p>对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold 设置，当对象达到这个年龄后就将进入老年代。<br>如果对象在 Eden 出生并且经过第一次 MinorGC 后仍然存活，并且能够被 Survivor 容纳的话，被移动到 Survivor 空间中，并将对象年龄设置成 1，对象在 Survivor 中每熬过一次 MinorGC，年龄就增加 1 岁。年龄到一定程度（默认为 15 岁），就会被晋升到到老年代中。可以通过参数-XX:MaxTenuringThreshold 设置。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 长期存活的对象进入老年代\n * vm参数，新生代10M, eden区16M，surivior区2M(from,to)\n * -XX:MaxTenuringThreshold&#x3D;1 -Xms40M -Xmx40M -Xmn20M -XX:SurvivorRatio&#x3D;8 -XX:+UseSerialGC  -XX:+PrintTenuringDistribution -XX:+PrintGCDetails\n *&#x2F;\npublic static void testTenuringThreshold() &#123;\n    byte[] allocation1, allocation2 ,allocation3;\n    allocation1 &#x3D; new byte[1&#x2F;2 * _1MB];\n    &#x2F;&#x2F; 什么时候进入老年代取决于MaxTenuringThreshold的设置\n    allocation2 &#x3D; new byte[8 * _1MB];\n    allocation3 &#x3D; new byte[8 * _1MB];\n    allocation3 &#x3D; null;\n    allocation3 &#x3D; new byte[8 * _1MB];\n&#125;</code></pre>\n\n<p>-XX:MaxTenuringThreshold&#x3D;1 -XX:MaxTenuringThreshold&#x3D;15 发生了两次 Minor GC，第一次是在给 allocation3 进行分配的时候会出现一次 Minor GC，此时 survivor 区域不能容纳 allocation2，但是可以容纳 allocation1，所以 allocation1 将会进入 survivor 区域并且年龄为 1，达到了阈值，将在下一次 GC 时晋升到老年代，而 allocation2 则会通过担保机制进入老年代。第二次发生 GC 是在第二次给 allocation3 分配空间时，这时，allocation1 的年龄加 1，晋升到老年代，此次 GC 也可以清理出原来 allocation3 占据的 4MB 空间，将 allocation3 分配在 Eden 区。所以，最后的结果是 allocation1、allocation2 在老年代，allocation3 在 Eden 区。</p>\n<h2 id=\"4、动态对象年龄判定\"><a href=\"#4、动态对象年龄判定\" class=\"headerlink\" title=\"4、动态对象年龄判定\"></a>4、动态对象年龄判定</h2><p>为了更好地适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代；如果在 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 动态对象年龄判断\n * vm参数，新生代10M, eden区16M，surivior区2M(from,to)\n * -Xms40M -Xmx40M -Xmn20M -XX:SurvivorRatio&#x3D;8 -XX:+UseSerialGC -XX:+PrintTenuringDistribution -XX:+PrintGCDetails\n *&#x2F;\npublic static void testDynamicTenuringThreshold() &#123;\n    byte[] allocation1, allocation2 ,allocation3,allocation4;\n    allocation1 &#x3D; new byte[_1MB &#x2F; 2];\n    allocation2 &#x3D; new byte[_1MB &#x2F; 2];\n    &#x2F;&#x2F; allocation1 + allocation2 大于surivior空间的一半\n    allocation3 &#x3D; new byte[8 * _1MB];\n    allocation4 &#x3D; new byte[8 * _1MB];\n    allocation4 &#x3D; null;\n    allocation4 &#x3D; new byte[8 * _1MB];\n&#125;</code></pre>\n\n<p>发生了两次 Minor GC，第一次发生在给 allocation4 分配内存时，此时 allocation1、allocation2 将会进入 survivor 区，而 allocation3 通过担保机制将会进入老年代。第二次发生在给 allocation4 分配内存时，此时，survivor 区的 allocation1、allocation2 达到了 survivor 区容量的一半，将会进入老年代，此次 GC 可以清理出 allocation4 原来的 4MB 空间，并将 allocation4 分配在 Eden 区。最终，allocation1、allocation2、allocation3 在老年代，allocation4 在 Eden 区。</p>\n<h2 id=\"5、空间分配担保\"><a href=\"#5、空间分配担保\" class=\"headerlink\" title=\"5、空间分配担保\"></a>5、空间分配担保</h2><h3 id=\"jdk1-6-update24-之前的担保流程\"><a href=\"#jdk1-6-update24-之前的担保流程\" class=\"headerlink\" title=\"jdk1.6 update24 之前的担保流程\"></a>jdk1.6 update24 之前的担保流程</h3><p>在发生 Minor GC 之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行一次 Minor GC。如果小于或者没有设置 HandlePromotionFailure，则要进行一次 Full GC。<br>取平均值进行比较其实仍然是一种动态概率的手段，如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败。如果出现了 HandlePromotionFailure 失败，则会重新发起一次 Full GC，大部分情况都会将 HandlePromotionFailure 打开，避免过于频繁的 Full GC。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648398550385-d0b55dea-87c7-4f39-8f90-b57013c543bf.png#clientId=uc6b6d1e2-f7d5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u59b841d2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=357&originWidth=723&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=31084&status=done&style=none&taskId=ub70f10b6-edf4-40a0-9701-0aaa3ad6b09&title=\" alt=\"image.png\"></p>\n<h3 id=\"jdk1-6-update24-之后的担保流程\"><a href=\"#jdk1-6-update24-之后的担保流程\" class=\"headerlink\" title=\"jdk1.6 update24 之后的担保流程\"></a>jdk1.6 update24 之后的担保流程</h3><p>在 jdk1.6 update24 之后，HandlePromotionFailure 参数不会影响虚拟机空间分配担保策略，虚拟机改为，只要老年代最大连续空间大于新生代对象总和或者大于历次晋升平均大小，都将进行 minor gc，否则将进行 Full gc。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648398550299-cad9a607-6e9f-4ab8-a9ef-04dee9a81e74.png#clientId=uc6b6d1e2-f7d5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u30b7ea0d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=151&originWidth=726&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=14065&status=done&style=none&taskId=u27f99744-0684-4846-a839-f4a029094c2&title=\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 空间分配担保\n * vm参数，新生代10M, eden区8M，surivior区1M(from,to)\n * -XX:HandlePromotionFailure\n * -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintTenuringDistribution -XX:SurvivorRatio&#x3D;8\n *&#x2F;\npublic static void testHandlePromotionFailure() &#123;\n    byte[] allocation1, allocation2 ,allocation3,allocation4, allocation5, allocation6 ,allocation7;\n    allocation1 &#x3D; new byte[2 * _1MB];\n    allocation2 &#x3D; new byte[2 * _1MB];\n    allocation3 &#x3D; new byte[2 * _1MB];\n    allocation1 &#x3D; null;\n    allocation4 &#x3D; new byte[2 * _1MB];\n    allocation5 &#x3D; new byte[2 * _1MB];\n    allocation6 &#x3D; new byte[2 * _1MB];\n    allocation4 &#x3D; null;\n    allocation5 &#x3D; null;\n    allocation6 &#x3D; null;\n    allocation7 &#x3D; new byte[2 * _1MB];\n&#125;</code></pre>\n\n<p>发生了两次 GC，第一次发生在给 allocation4 分配内存空间时，由于老年代的连续可用空间大于存活的对象总和， 所以 allocation2、allocation3 将会进入老年代，allocation1 的空间将被回收，allocation4 分配在新生代；第二次发生在给 allocation7 分配内存空间时，此次 GC 将 allocation4、allocation5、allocation6 所占的内存全部回收。最后，allocation2、allocation3 在老年代，allocation7 在新生代。</p>\n","categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]}