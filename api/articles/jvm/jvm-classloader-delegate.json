{"title":"JVM（六）虚拟机类加载委派模型","slug":"yuque/JVM（六）虚拟机类加载委派模型","date":"2016-08-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-classloader-delegate.json","excerpt":"双亲委派模型当一个类装载器（classloader）被请求装载类时，它首先按照顺序在上层装载器、父装载器以及自身的装载器的缓存里检查这个类是否已经存在。简单来说，就是在缓存里查看这个类是否已经被自己装载过了，如果没有的话，继续查找父类的缓存，直到在bootstrap类装载器里也没有找到的话，它就会自己在文件系统里去查找并且加载这个类。ClassLoader 的loadClass 方法protected Class loadClass(String name, boolean resolve)            throws ClassNotFoundExcepti","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648399628171-785f1ba4-e962-4d19-ae98-ca31a4cc8ce3.png#clientId=u48792fe7-b3c5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u272e4341&margin=%5Bobject%20Object%5D&name=image.png&originHeight=463&originWidth=574&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=25025&status=done&style=none&taskId=ub33bb7ca-0d15-4681-bd85-318ee1778ba&title="],"content":"<h2 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h2><p>当一个类装载器（class loader）被请求装载类时，它首先按照顺序在上层装载器、父装载器以及自身的装载器的缓存里检查这个类是否已经存在。简单来说，就是在缓存里查看这个类是否已经被自己装载过了，如果没有的话，继续查找父类的缓存，直到在 bootstrap 类装载器里也没有找到的话，它就会自己在文件系统里去查找并且加载这个类。<br>ClassLoader 的 loadClass 方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Class&lt;?&gt; loadClass(String name, boolean resolve)\n            throws ClassNotFoundException &#123;\n    synchronized (getClassLoadingLock(name)) &#123;\n        &#x2F;&#x2F; First, check if the class has already been loaded\n        Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n        if (c &#x3D;&#x3D; null) &#123;\n            long t0 &#x3D; System.nanoTime();\n            try &#123;\n                if (parent !&#x3D; null) &#123;\n                    c &#x3D; parent.loadClass(name, false);\n                &#125; else &#123;\n                    c &#x3D; findBootstrapClassOrNull(name);\n                &#125;\n            &#125; catch (ClassNotFoundException e) &#123;\n                &#x2F;&#x2F; ClassNotFoundException thrown if class not found\n                &#x2F;&#x2F; from the non-null parent class loader\n            &#125;\n\n            if (c &#x3D;&#x3D; null) &#123;\n                &#x2F;&#x2F; If still not found, then invoke findClass in order\n                &#x2F;&#x2F; to find the class.\n                long t1 &#x3D; System.nanoTime();\n                c &#x3D; findClass(name);\n                &#x2F;&#x2F; this is the defining class loader; record the stats\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            &#125;\n        &#125;\n        if (resolve) &#123;\n            resolveClass(c);\n        &#125;\n        return c;\n    &#125;\n&#125;</code></pre>\n\n<p>1）先找缓存（findLoadedClass），没有的话就判断有没有 parent，有的话就用 parent 来递归的 loadClass，然而 ExtClassLoader 并没有设置 parent，则会通过 findBootstrapClassOrNull 来加载 class，而 findBootstrapClassOrNull 则会通过 JNI 方法“private native Class findBootstrapClass(String name)“来使用 BootStrapClassLoader 来加载 class。<br>2）然后如果 parent 未找到 class，则会调用 findClass 来加载 class，findClass 是一个 protected 的空方法，可以覆盖它以便自定义 class 加载过程。另外，虽然 ClassLoader 加载类是使用 loadClass 方法，<strong>但是鼓励用 ClassLoader 的子类重写 findClass(String)，而不是重写 loadClass</strong>，这样就不会覆盖了类加载默认的双亲委派机制。<br>双亲委派模型有一个缺陷，如果父 ClassLoader 想加载子 ClassLoader 中的类比较困难，而在有的应用中这种加载方式是需要的，比如 JNDI,Servlet 等。</p>\n<h2 id=\"破坏双亲委派模型\"><a href=\"#破坏双亲委派模型\" class=\"headerlink\" title=\"破坏双亲委派模型\"></a>破坏双亲委派模型</h2><p>1） JDK1.2 java.lang.ClassLoader 提供新的 protected 方法 findClass()和 public 方法 loadClass()，来实现自定义类加载和破坏委派模型。<br>2）JDK1.3 使用线程上下文（ThreadContextClassLoader）解决让父类加载器请求子类完成类的加载，例如 JNDI，JDBC，JCE，JAXB，以及应用服务器 Tocmat 等<br>3）OSGi，代码热替换（HotSwap），代码热部署（HotDeployment）<br>关于 JDBC 的 SPI 加载，可参照 ServiceLoader 深入解析，本文主要讲解下 jetty 的类加载机制。<br>Jetty 的 ClassLoader 体系结构如下所示：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648399628171-785f1ba4-e962-4d19-ae98-ca31a4cc8ce3.png#clientId=u48792fe7-b3c5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u272e4341&margin=%5Bobject%20Object%5D&name=image.png&originHeight=463&originWidth=574&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=25025&status=done&style=none&taskId=ub33bb7ca-0d15-4681-bd85-318ee1778ba&title=\" alt=\"image.png\"><br>Jetty 有两种运行方式，一种进程内运行(通过反射执行 MainClass),一种是进程外执行 ( 通过 Runtime.getRuntime().exec()), 进程外执行时由于线程上下文不能进程之间传递。<br>Jetty 至少要保证其内部运行的多个 webapp 之间私有的类库不受影响，并且公有的类库可以共享。Jetty 中有一个 org.mortbay.jetty.webapp.WebAppClassLoader，负责加载一个 webapp context 中的应用类，WebAppClassLoader 以系统类加载器作为 parent，用于加载系统类。不过 servlet 规范使得 web 容器的 ClassLoader 比正常的 ClassLoader 委托模型稍稍复杂，Servlet 规范要求：<br>1）WEB-INF&#x2F;lib 和 WEB-INF&#x2F;classes 优先于父容器中的类加载，比如 WEB-INF&#x2F;classes 下有个 XYZ 类，classpath 下也有个 XYZ 类，jetty 中优先加载的是 WEB-INF&#x2F;classes 下的，这与正常的父加载器优先相反(child-first)。<br>2）系统类比如 java.lang.String 不遵循第一条，WEB-INF&#x2F;classes 或 WEB-INF&#x2F;lib 下的类不能替换系统类。不过规范中没有明确规定哪些是系统类，jetty 中的实现是按照类的全路径名判断。<br>3）Server 的实现类不被应用中的类引用，即 Server 的实现类不能被任何应用类加载器加载。不过，同样的，规范里没有明确规定哪些是 Server 的实现类，jetty 中同样是按照类的全路径名判断。<br>为了处理上述三个问题，jetty 的应用类加载器(org.mortbay.jetty.webapp.WebAppClassLoader)做了些特殊处理。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public WebAppClassLoader(ClassLoader parent, Context context)\n        throws IOException &#123;\n    super(new URL[] &#123;&#125;, parent !&#x3D; null ? parent\n            : (Thread.currentThread().getContextClassLoader() !&#x3D; null ? Thread.currentThread().getContextClassLoader()\n            : (WebAppClassLoader.class.getClassLoader() !&#x3D; null ? WebAppClassLoader.class.getClassLoader()\n            : ClassLoader.getSystemClassLoader())));\n    _parent &#x3D; getParent();\n    _context &#x3D; context;\n    if (_parent &#x3D;&#x3D; null)\n        throw new IllegalArgumentException(&quot;no parent classloader!&quot;);\n\n    _extensions.add(&quot;.jar&quot;);\n    _extensions.add(&quot;.zip&quot;);\n\n    &#x2F;&#x2F; TODO remove this system property\n    String extensions &#x3D; System.getProperty(WebAppClassLoader.class.getName() + &quot;.extensions&quot;);\n    if (extensions !&#x3D; null) &#123;\n        StringTokenizer tokenizer &#x3D; new StringTokenizer(extensions, &quot;,;&quot;);\n        while (tokenizer.hasMoreTokens())\n            _extensions.add(tokenizer.nextToken().trim());\n    &#125;\n    if (context.getExtraClasspath() !&#x3D; null)\n        addClassPath(context.getExtraClasspath());\n&#125;</code></pre>\n\n<p>他是以当前线程上下文的 ClassLoader 为父 classloader, 如果上下文没有设定 classLoader ，就使用加载 WebAppClassLoader 的加载器，如果还是没有，则采用系统类加载器。很明显，默认情况下，如果采用进程内运行，那么这个 parent 就是 Loader( 系统自定义类加载器 ) ，如果是进程外， parent 就是系统类加载器。<br>WebAppClassLoader 可以设定是否由 parent 优先加载 lib&#x2F; 、 classes 下的类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;\n    Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n    ClassNotFoundException ex &#x3D; null;\n    boolean tried_parent &#x3D; false;\n\n    boolean system_class &#x3D; _context.isSystemClass(name);\n    boolean server_class &#x3D; _context.isServerClass(name);\n\n    if (system_class &amp;&amp; server_class) &#123;\n        return null;\n    &#125;\n\n    if (c &#x3D;&#x3D; null &amp;&amp; _parent !&#x3D; null &amp;&amp; (_context.isParentLoaderPriority() || system_class) &amp;&amp; !server_class) &#123;\n        tried_parent &#x3D; true;\n        try &#123;\n            c &#x3D; _parent.loadClass(name);\n            if (LOG.isDebugEnabled())\n                LOG.debug(&quot;loaded &quot; + c);\n        &#125;\n        catch (ClassNotFoundException e) &#123;\n            ex &#x3D; e;\n        &#125;\n    &#125;\n\n    if (c &#x3D;&#x3D; null) &#123;\n        try &#123;\n            c &#x3D; this.findClass(name);\n        &#125;\n        catch (ClassNotFoundException e) &#123;\n            ex &#x3D; e;\n        &#125;\n    &#125;\n\n    if (c &#x3D;&#x3D; null &amp;&amp; _parent !&#x3D; null &amp;&amp; !tried_parent &amp;&amp; !server_class)\n        c &#x3D; _parent.loadClass(name);\n\n    if (c &#x3D;&#x3D; null &amp;&amp; ex !&#x3D; null)\n        throw ex;\n\n    if (resolve)\n        resolveClass(c);\n\n    if (LOG.isDebugEnabled())\n        LOG.debug(&quot;loaded &#123;&#125; from &#123;&#125;&quot;, c, c &#x3D;&#x3D; null ? null : c.getClassLoader());\n\n    return c;\n&#125;</code></pre>\n\n<p>findLoadedClass(name)-检查类是否已经加载<br>1）判断该类是否为系统类或 server 类<br>2）如果该类未加载且父加载器不为空且设置了父加载器优先或类类为系统类，且该类不是 server 类，则尝试使用父加载器加载该类<br>3）如果不是父加载器优先或者父加载器未加载到该类，使用 WebAppClassLoader 加载该类<br>4）如果是不是父加载器优先，并且 WebAppClassLoader 未加载到该类，尝试使用父加载器加载该类<br>5）找到则返回，否则抛出 ClassNotFoundException<br>再看下 findClass 方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Class&lt;?&gt; findClass(final String name) throws ClassNotFoundException &#123;\n    Class&lt;?&gt; clazz &#x3D; null;\n\n    if (_transformers.isEmpty())\n        clazz &#x3D; super.findClass(name);\n    else &#123;\n        String path &#x3D; name.replace(&#39;.&#39;, &#39;&#x2F;&#39;).concat(&quot;.class&quot;);\n        URL url &#x3D; getResource(path);\n        if (url &#x3D;&#x3D; null)\n            throw new ClassNotFoundException(name);\n\n        InputStream content &#x3D; null;\n        try &#123;\n            content &#x3D; url.openStream();\n            byte[] bytes &#x3D; IO.readBytes(content);\n\n            for (ClassFileTransformer transformer : _transformers) &#123;\n                byte[] tmp &#x3D; transformer.transform(this, name, null, null, bytes);\n                if (tmp !&#x3D; null)\n                    bytes &#x3D; tmp;\n            &#125;\n\n            clazz &#x3D; defineClass(name, bytes, 0, bytes.length);\n        &#125;\n        catch (IOException e) &#123;\n            throw new ClassNotFoundException(name, e);\n        &#125;\n        catch (IllegalClassFormatException e) &#123;\n            throw new ClassNotFoundException(name, e);\n        &#125;\n        finally &#123;\n            if (content !&#x3D; null) &#123;\n                try &#123;\n                    content.close();\n                &#125;\n                catch (IOException e) &#123;\n                    throw new ClassNotFoundException(name, e);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return clazz;\n&#125;</code></pre>\n\n<p>_transformers 为空调用父类的 findClass，不为空找到对应的类文件对其进行转换。</p>\n<h3 id=\"1、设置-ClassLoader-Priority\"><a href=\"#1、设置-ClassLoader-Priority\" class=\"headerlink\" title=\"1、设置 ClassLoader Priority\"></a>1、设置 ClassLoader Priority</h3><p>上述过程涉及一个加载器优先级的概念，这也是针对前述第一条规范中 WEB-INF&#x2F;lib 和 WEB-INF&#x2F;classes 类优先的处理。jetty 中父加载器优先的配置项可以通过环境变量<br>org.eclipse.jetty.server.webapp.parentLoaderPriority&#x3D;false(默认)&#x2F;true 来设置<br>也可以通过<br>org.eclipse.jetty.webapp.WebAppContext.setParentLoaderPriority(boolean)方法来设置<br>优于该<strong>配置默认是 false</strong>，因此在 load class 过程中优先使用 WebAppClassLoader 加载 WEB-INF&#x2F;lib 和 WEB-INF&#x2F;classes 中的类。<strong>当将该配置项设为 true 时需要确认类加载顺序没有问题</strong>。</p>\n<h3 id=\"2、设置系统类\"><a href=\"#2、设置系统类\" class=\"headerlink\" title=\"2、设置系统类\"></a>2、设置系统类</h3><p>规范 2 中约定系统类不能被应用类覆盖，但是没有明确规定哪些时系统类，jetty 中以类的 package 路径名来区分，当类的 package 路径名位包含于</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; System classes are classes that cannot be replaced by\n&#x2F;&#x2F; the web application, and they are *always* loaded via\n&#x2F;&#x2F; system classloader.\npublic final static String[] __dftSystemClasses &#x3D;\n&#123;\n       &quot;java.&quot;,                            &#x2F;&#x2F; Java SE classes (per servlet spec v2.5 &#x2F; SRV.9.7.2)\n       &quot;javax.&quot;,                           &#x2F;&#x2F; Java SE classes (per servlet spec v2.5 &#x2F; SRV.9.7.2)\n       &quot;org.xml.&quot;,                         &#x2F;&#x2F; needed by javax.xml\n       &quot;org.w3c.&quot;,                         &#x2F;&#x2F; needed by javax.xml\n       &quot;org.eclipse.jetty.jmx.&quot;,           &#x2F;&#x2F; webapp cannot change jmx classes\n       &quot;org.eclipse.jetty.util.annotation.&quot;,  &#x2F;&#x2F; webapp cannot change jmx annotations\n       &quot;org.eclipse.jetty.continuation.&quot;,  &#x2F;&#x2F; webapp cannot change continuation classes\n       &quot;org.eclipse.jetty.jndi.&quot;,          &#x2F;&#x2F; webapp cannot change naming classes\n       &quot;org.eclipse.jetty.jaas.&quot;,          &#x2F;&#x2F; webapp cannot change jaas classes\n       &quot;org.eclipse.jetty.websocket.&quot;,     &#x2F;&#x2F; webapp cannot change &#x2F; replace websocket classes\n       &quot;org.eclipse.jetty.util.log.&quot;,      &#x2F;&#x2F; webapp should use server log\n       &quot;org.eclipse.jetty.servlet.ServletContextHandler.Decorator&quot;, &#x2F;&#x2F; for CDI &#x2F; weld use\n       &quot;org.eclipse.jetty.servlet.DefaultServlet&quot;, &#x2F;&#x2F; webapp cannot change default servlets\n       &quot;org.eclipse.jetty.jsp.JettyJspServlet&quot;, &#x2F;&#x2F;webapp cannot change jetty jsp servlet\n       &quot;org.eclipse.jetty.servlets.AsyncGzipFilter&quot; &#x2F;&#x2F; special case for AsyncGzipFilter\n&#125; ;</code></pre>\n\n<p>时，会被认为是系统类。（该定义位于 WebAppContext 中）<br>因此，我们可以通过 org.eclipse.jetty.webapp.WebAppContext.setSystemClasses(String Array)或者 org.eclipse.jetty.webapp.WebAppContext.addSystemClass(String)来设置系统类。 再次提醒，系统类是对多有应用都可见。</p>\n<h3 id=\"3、设置-Server-类\"><a href=\"#3、设置-Server-类\" class=\"headerlink\" title=\"3、设置 Server 类\"></a>3、设置 Server 类</h3><p>规范 3 中约定 Server 类不对任何应用可见。jetty 同样是用 package 路径名来区分哪些是 Server 类。Server 类包括：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Server classes are classes that are hidden from being\n&#x2F;&#x2F; loaded by the web application using system classloader,\n&#x2F;&#x2F; so if web application needs to load any of such classes,\n&#x2F;&#x2F; it has to include them in its distribution.\npublic final static String[] __dftServerClasses &#x3D;\n&#123;\n       &quot;-org.eclipse.jetty.jmx.&quot;,          &#x2F;&#x2F; don&#39;t hide jmx classes\n       &quot;-org.eclipse.jetty.util.annotation.&quot;, &#x2F;&#x2F; don&#39;t hide jmx annotation\n       &quot;-org.eclipse.jetty.continuation.&quot;, &#x2F;&#x2F; don&#39;t hide continuation classes\n       &quot;-org.eclipse.jetty.jndi.&quot;,         &#x2F;&#x2F; don&#39;t hide naming classes\n       &quot;-org.eclipse.jetty.jaas.&quot;,         &#x2F;&#x2F; don&#39;t hide jaas classes\n       &quot;-org.eclipse.jetty.servlets.&quot;,     &#x2F;&#x2F; don&#39;t hide jetty servlets\n       &quot;-org.eclipse.jetty.servlet.DefaultServlet&quot;, &#x2F;&#x2F; don&#39;t hide default servlet\n       &quot;-org.eclipse.jetty.jsp.&quot;,          &#x2F;&#x2F;don&#39;t hide jsp servlet\n       &quot;-org.eclipse.jetty.servlet.listener.&quot;, &#x2F;&#x2F; don&#39;t hide useful listeners\n       &quot;-org.eclipse.jetty.websocket.&quot;,    &#x2F;&#x2F; don&#39;t hide websocket classes from webapps (allow webapp to use ones from system classloader)\n       &quot;-org.eclipse.jetty.apache.&quot;,       &#x2F;&#x2F; don&#39;t hide jetty apache impls\n       &quot;-org.eclipse.jetty.util.log.&quot;,     &#x2F;&#x2F; don&#39;t hide server log\n       &quot;-org.eclipse.jetty.servlet.ServletContextHandler.Decorator&quot;, &#x2F;&#x2F; don&#39;t hide CDI &#x2F; weld interface\n       &quot;org.objectweb.asm.&quot;,               &#x2F;&#x2F; hide asm used by jetty\n       &quot;org.eclipse.jdt.&quot;,                 &#x2F;&#x2F; hide jdt used by jetty\n       &quot;org.eclipse.jetty.&quot;                &#x2F;&#x2F; hide other jetty classes\n&#125; ;</code></pre>\n\n<p>我们可以通过， org.eclipse.jetty.webapp.WebAppContext.setServerClasses(String Array) 或 org.eclipse.jetty.webapp.WebAppContext.addServerClass(String)方法设置 Server 类。 注意，Server 类是对所有应用都不可见的，但是 WEB-INF&#x2F;lib 下的类可以替换 Server 类。<br>当默认的 WebAppClassLoader 不能满足需求时，可以自定义 WebApp ClassLoader，不过 jetty 建议自定义的 classloader 要扩展于默认的 WebAppClassLoader 实现。</p>\n","more":"<h2 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h2><p>当一个类装载器（class loader）被请求装载类时，它首先按照顺序在上层装载器、父装载器以及自身的装载器的缓存里检查这个类是否已经存在。简单来说，就是在缓存里查看这个类是否已经被自己装载过了，如果没有的话，继续查找父类的缓存，直到在 bootstrap 类装载器里也没有找到的话，它就会自己在文件系统里去查找并且加载这个类。<br>ClassLoader 的 loadClass 方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Class&lt;?&gt; loadClass(String name, boolean resolve)\n            throws ClassNotFoundException &#123;\n    synchronized (getClassLoadingLock(name)) &#123;\n        &#x2F;&#x2F; First, check if the class has already been loaded\n        Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n        if (c &#x3D;&#x3D; null) &#123;\n            long t0 &#x3D; System.nanoTime();\n            try &#123;\n                if (parent !&#x3D; null) &#123;\n                    c &#x3D; parent.loadClass(name, false);\n                &#125; else &#123;\n                    c &#x3D; findBootstrapClassOrNull(name);\n                &#125;\n            &#125; catch (ClassNotFoundException e) &#123;\n                &#x2F;&#x2F; ClassNotFoundException thrown if class not found\n                &#x2F;&#x2F; from the non-null parent class loader\n            &#125;\n\n            if (c &#x3D;&#x3D; null) &#123;\n                &#x2F;&#x2F; If still not found, then invoke findClass in order\n                &#x2F;&#x2F; to find the class.\n                long t1 &#x3D; System.nanoTime();\n                c &#x3D; findClass(name);\n                &#x2F;&#x2F; this is the defining class loader; record the stats\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            &#125;\n        &#125;\n        if (resolve) &#123;\n            resolveClass(c);\n        &#125;\n        return c;\n    &#125;\n&#125;</code></pre>\n\n<p>1）先找缓存（findLoadedClass），没有的话就判断有没有 parent，有的话就用 parent 来递归的 loadClass，然而 ExtClassLoader 并没有设置 parent，则会通过 findBootstrapClassOrNull 来加载 class，而 findBootstrapClassOrNull 则会通过 JNI 方法“private native Class findBootstrapClass(String name)“来使用 BootStrapClassLoader 来加载 class。<br>2）然后如果 parent 未找到 class，则会调用 findClass 来加载 class，findClass 是一个 protected 的空方法，可以覆盖它以便自定义 class 加载过程。另外，虽然 ClassLoader 加载类是使用 loadClass 方法，<strong>但是鼓励用 ClassLoader 的子类重写 findClass(String)，而不是重写 loadClass</strong>，这样就不会覆盖了类加载默认的双亲委派机制。<br>双亲委派模型有一个缺陷，如果父 ClassLoader 想加载子 ClassLoader 中的类比较困难，而在有的应用中这种加载方式是需要的，比如 JNDI,Servlet 等。</p>\n<h2 id=\"破坏双亲委派模型\"><a href=\"#破坏双亲委派模型\" class=\"headerlink\" title=\"破坏双亲委派模型\"></a>破坏双亲委派模型</h2><p>1） JDK1.2 java.lang.ClassLoader 提供新的 protected 方法 findClass()和 public 方法 loadClass()，来实现自定义类加载和破坏委派模型。<br>2）JDK1.3 使用线程上下文（ThreadContextClassLoader）解决让父类加载器请求子类完成类的加载，例如 JNDI，JDBC，JCE，JAXB，以及应用服务器 Tocmat 等<br>3）OSGi，代码热替换（HotSwap），代码热部署（HotDeployment）<br>关于 JDBC 的 SPI 加载，可参照 ServiceLoader 深入解析，本文主要讲解下 jetty 的类加载机制。<br>Jetty 的 ClassLoader 体系结构如下所示：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648399628171-785f1ba4-e962-4d19-ae98-ca31a4cc8ce3.png#clientId=u48792fe7-b3c5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u272e4341&margin=%5Bobject%20Object%5D&name=image.png&originHeight=463&originWidth=574&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=25025&status=done&style=none&taskId=ub33bb7ca-0d15-4681-bd85-318ee1778ba&title=\" alt=\"image.png\"><br>Jetty 有两种运行方式，一种进程内运行(通过反射执行 MainClass),一种是进程外执行 ( 通过 Runtime.getRuntime().exec()), 进程外执行时由于线程上下文不能进程之间传递。<br>Jetty 至少要保证其内部运行的多个 webapp 之间私有的类库不受影响，并且公有的类库可以共享。Jetty 中有一个 org.mortbay.jetty.webapp.WebAppClassLoader，负责加载一个 webapp context 中的应用类，WebAppClassLoader 以系统类加载器作为 parent，用于加载系统类。不过 servlet 规范使得 web 容器的 ClassLoader 比正常的 ClassLoader 委托模型稍稍复杂，Servlet 规范要求：<br>1）WEB-INF&#x2F;lib 和 WEB-INF&#x2F;classes 优先于父容器中的类加载，比如 WEB-INF&#x2F;classes 下有个 XYZ 类，classpath 下也有个 XYZ 类，jetty 中优先加载的是 WEB-INF&#x2F;classes 下的，这与正常的父加载器优先相反(child-first)。<br>2）系统类比如 java.lang.String 不遵循第一条，WEB-INF&#x2F;classes 或 WEB-INF&#x2F;lib 下的类不能替换系统类。不过规范中没有明确规定哪些是系统类，jetty 中的实现是按照类的全路径名判断。<br>3）Server 的实现类不被应用中的类引用，即 Server 的实现类不能被任何应用类加载器加载。不过，同样的，规范里没有明确规定哪些是 Server 的实现类，jetty 中同样是按照类的全路径名判断。<br>为了处理上述三个问题，jetty 的应用类加载器(org.mortbay.jetty.webapp.WebAppClassLoader)做了些特殊处理。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public WebAppClassLoader(ClassLoader parent, Context context)\n        throws IOException &#123;\n    super(new URL[] &#123;&#125;, parent !&#x3D; null ? parent\n            : (Thread.currentThread().getContextClassLoader() !&#x3D; null ? Thread.currentThread().getContextClassLoader()\n            : (WebAppClassLoader.class.getClassLoader() !&#x3D; null ? WebAppClassLoader.class.getClassLoader()\n            : ClassLoader.getSystemClassLoader())));\n    _parent &#x3D; getParent();\n    _context &#x3D; context;\n    if (_parent &#x3D;&#x3D; null)\n        throw new IllegalArgumentException(&quot;no parent classloader!&quot;);\n\n    _extensions.add(&quot;.jar&quot;);\n    _extensions.add(&quot;.zip&quot;);\n\n    &#x2F;&#x2F; TODO remove this system property\n    String extensions &#x3D; System.getProperty(WebAppClassLoader.class.getName() + &quot;.extensions&quot;);\n    if (extensions !&#x3D; null) &#123;\n        StringTokenizer tokenizer &#x3D; new StringTokenizer(extensions, &quot;,;&quot;);\n        while (tokenizer.hasMoreTokens())\n            _extensions.add(tokenizer.nextToken().trim());\n    &#125;\n    if (context.getExtraClasspath() !&#x3D; null)\n        addClassPath(context.getExtraClasspath());\n&#125;</code></pre>\n\n<p>他是以当前线程上下文的 ClassLoader 为父 classloader, 如果上下文没有设定 classLoader ，就使用加载 WebAppClassLoader 的加载器，如果还是没有，则采用系统类加载器。很明显，默认情况下，如果采用进程内运行，那么这个 parent 就是 Loader( 系统自定义类加载器 ) ，如果是进程外， parent 就是系统类加载器。<br>WebAppClassLoader 可以设定是否由 parent 优先加载 lib&#x2F; 、 classes 下的类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;\n    Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n    ClassNotFoundException ex &#x3D; null;\n    boolean tried_parent &#x3D; false;\n\n    boolean system_class &#x3D; _context.isSystemClass(name);\n    boolean server_class &#x3D; _context.isServerClass(name);\n\n    if (system_class &amp;&amp; server_class) &#123;\n        return null;\n    &#125;\n\n    if (c &#x3D;&#x3D; null &amp;&amp; _parent !&#x3D; null &amp;&amp; (_context.isParentLoaderPriority() || system_class) &amp;&amp; !server_class) &#123;\n        tried_parent &#x3D; true;\n        try &#123;\n            c &#x3D; _parent.loadClass(name);\n            if (LOG.isDebugEnabled())\n                LOG.debug(&quot;loaded &quot; + c);\n        &#125;\n        catch (ClassNotFoundException e) &#123;\n            ex &#x3D; e;\n        &#125;\n    &#125;\n\n    if (c &#x3D;&#x3D; null) &#123;\n        try &#123;\n            c &#x3D; this.findClass(name);\n        &#125;\n        catch (ClassNotFoundException e) &#123;\n            ex &#x3D; e;\n        &#125;\n    &#125;\n\n    if (c &#x3D;&#x3D; null &amp;&amp; _parent !&#x3D; null &amp;&amp; !tried_parent &amp;&amp; !server_class)\n        c &#x3D; _parent.loadClass(name);\n\n    if (c &#x3D;&#x3D; null &amp;&amp; ex !&#x3D; null)\n        throw ex;\n\n    if (resolve)\n        resolveClass(c);\n\n    if (LOG.isDebugEnabled())\n        LOG.debug(&quot;loaded &#123;&#125; from &#123;&#125;&quot;, c, c &#x3D;&#x3D; null ? null : c.getClassLoader());\n\n    return c;\n&#125;</code></pre>\n\n<p>findLoadedClass(name)-检查类是否已经加载<br>1）判断该类是否为系统类或 server 类<br>2）如果该类未加载且父加载器不为空且设置了父加载器优先或类类为系统类，且该类不是 server 类，则尝试使用父加载器加载该类<br>3）如果不是父加载器优先或者父加载器未加载到该类，使用 WebAppClassLoader 加载该类<br>4）如果是不是父加载器优先，并且 WebAppClassLoader 未加载到该类，尝试使用父加载器加载该类<br>5）找到则返回，否则抛出 ClassNotFoundException<br>再看下 findClass 方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Class&lt;?&gt; findClass(final String name) throws ClassNotFoundException &#123;\n    Class&lt;?&gt; clazz &#x3D; null;\n\n    if (_transformers.isEmpty())\n        clazz &#x3D; super.findClass(name);\n    else &#123;\n        String path &#x3D; name.replace(&#39;.&#39;, &#39;&#x2F;&#39;).concat(&quot;.class&quot;);\n        URL url &#x3D; getResource(path);\n        if (url &#x3D;&#x3D; null)\n            throw new ClassNotFoundException(name);\n\n        InputStream content &#x3D; null;\n        try &#123;\n            content &#x3D; url.openStream();\n            byte[] bytes &#x3D; IO.readBytes(content);\n\n            for (ClassFileTransformer transformer : _transformers) &#123;\n                byte[] tmp &#x3D; transformer.transform(this, name, null, null, bytes);\n                if (tmp !&#x3D; null)\n                    bytes &#x3D; tmp;\n            &#125;\n\n            clazz &#x3D; defineClass(name, bytes, 0, bytes.length);\n        &#125;\n        catch (IOException e) &#123;\n            throw new ClassNotFoundException(name, e);\n        &#125;\n        catch (IllegalClassFormatException e) &#123;\n            throw new ClassNotFoundException(name, e);\n        &#125;\n        finally &#123;\n            if (content !&#x3D; null) &#123;\n                try &#123;\n                    content.close();\n                &#125;\n                catch (IOException e) &#123;\n                    throw new ClassNotFoundException(name, e);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    return clazz;\n&#125;</code></pre>\n\n<p>_transformers 为空调用父类的 findClass，不为空找到对应的类文件对其进行转换。</p>\n<h3 id=\"1、设置-ClassLoader-Priority\"><a href=\"#1、设置-ClassLoader-Priority\" class=\"headerlink\" title=\"1、设置 ClassLoader Priority\"></a>1、设置 ClassLoader Priority</h3><p>上述过程涉及一个加载器优先级的概念，这也是针对前述第一条规范中 WEB-INF&#x2F;lib 和 WEB-INF&#x2F;classes 类优先的处理。jetty 中父加载器优先的配置项可以通过环境变量<br>org.eclipse.jetty.server.webapp.parentLoaderPriority&#x3D;false(默认)&#x2F;true 来设置<br>也可以通过<br>org.eclipse.jetty.webapp.WebAppContext.setParentLoaderPriority(boolean)方法来设置<br>优于该<strong>配置默认是 false</strong>，因此在 load class 过程中优先使用 WebAppClassLoader 加载 WEB-INF&#x2F;lib 和 WEB-INF&#x2F;classes 中的类。<strong>当将该配置项设为 true 时需要确认类加载顺序没有问题</strong>。</p>\n<h3 id=\"2、设置系统类\"><a href=\"#2、设置系统类\" class=\"headerlink\" title=\"2、设置系统类\"></a>2、设置系统类</h3><p>规范 2 中约定系统类不能被应用类覆盖，但是没有明确规定哪些时系统类，jetty 中以类的 package 路径名来区分，当类的 package 路径名位包含于</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; System classes are classes that cannot be replaced by\n&#x2F;&#x2F; the web application, and they are *always* loaded via\n&#x2F;&#x2F; system classloader.\npublic final static String[] __dftSystemClasses &#x3D;\n&#123;\n       &quot;java.&quot;,                            &#x2F;&#x2F; Java SE classes (per servlet spec v2.5 &#x2F; SRV.9.7.2)\n       &quot;javax.&quot;,                           &#x2F;&#x2F; Java SE classes (per servlet spec v2.5 &#x2F; SRV.9.7.2)\n       &quot;org.xml.&quot;,                         &#x2F;&#x2F; needed by javax.xml\n       &quot;org.w3c.&quot;,                         &#x2F;&#x2F; needed by javax.xml\n       &quot;org.eclipse.jetty.jmx.&quot;,           &#x2F;&#x2F; webapp cannot change jmx classes\n       &quot;org.eclipse.jetty.util.annotation.&quot;,  &#x2F;&#x2F; webapp cannot change jmx annotations\n       &quot;org.eclipse.jetty.continuation.&quot;,  &#x2F;&#x2F; webapp cannot change continuation classes\n       &quot;org.eclipse.jetty.jndi.&quot;,          &#x2F;&#x2F; webapp cannot change naming classes\n       &quot;org.eclipse.jetty.jaas.&quot;,          &#x2F;&#x2F; webapp cannot change jaas classes\n       &quot;org.eclipse.jetty.websocket.&quot;,     &#x2F;&#x2F; webapp cannot change &#x2F; replace websocket classes\n       &quot;org.eclipse.jetty.util.log.&quot;,      &#x2F;&#x2F; webapp should use server log\n       &quot;org.eclipse.jetty.servlet.ServletContextHandler.Decorator&quot;, &#x2F;&#x2F; for CDI &#x2F; weld use\n       &quot;org.eclipse.jetty.servlet.DefaultServlet&quot;, &#x2F;&#x2F; webapp cannot change default servlets\n       &quot;org.eclipse.jetty.jsp.JettyJspServlet&quot;, &#x2F;&#x2F;webapp cannot change jetty jsp servlet\n       &quot;org.eclipse.jetty.servlets.AsyncGzipFilter&quot; &#x2F;&#x2F; special case for AsyncGzipFilter\n&#125; ;</code></pre>\n\n<p>时，会被认为是系统类。（该定义位于 WebAppContext 中）<br>因此，我们可以通过 org.eclipse.jetty.webapp.WebAppContext.setSystemClasses(String Array)或者 org.eclipse.jetty.webapp.WebAppContext.addSystemClass(String)来设置系统类。 再次提醒，系统类是对多有应用都可见。</p>\n<h3 id=\"3、设置-Server-类\"><a href=\"#3、设置-Server-类\" class=\"headerlink\" title=\"3、设置 Server 类\"></a>3、设置 Server 类</h3><p>规范 3 中约定 Server 类不对任何应用可见。jetty 同样是用 package 路径名来区分哪些是 Server 类。Server 类包括：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Server classes are classes that are hidden from being\n&#x2F;&#x2F; loaded by the web application using system classloader,\n&#x2F;&#x2F; so if web application needs to load any of such classes,\n&#x2F;&#x2F; it has to include them in its distribution.\npublic final static String[] __dftServerClasses &#x3D;\n&#123;\n       &quot;-org.eclipse.jetty.jmx.&quot;,          &#x2F;&#x2F; don&#39;t hide jmx classes\n       &quot;-org.eclipse.jetty.util.annotation.&quot;, &#x2F;&#x2F; don&#39;t hide jmx annotation\n       &quot;-org.eclipse.jetty.continuation.&quot;, &#x2F;&#x2F; don&#39;t hide continuation classes\n       &quot;-org.eclipse.jetty.jndi.&quot;,         &#x2F;&#x2F; don&#39;t hide naming classes\n       &quot;-org.eclipse.jetty.jaas.&quot;,         &#x2F;&#x2F; don&#39;t hide jaas classes\n       &quot;-org.eclipse.jetty.servlets.&quot;,     &#x2F;&#x2F; don&#39;t hide jetty servlets\n       &quot;-org.eclipse.jetty.servlet.DefaultServlet&quot;, &#x2F;&#x2F; don&#39;t hide default servlet\n       &quot;-org.eclipse.jetty.jsp.&quot;,          &#x2F;&#x2F;don&#39;t hide jsp servlet\n       &quot;-org.eclipse.jetty.servlet.listener.&quot;, &#x2F;&#x2F; don&#39;t hide useful listeners\n       &quot;-org.eclipse.jetty.websocket.&quot;,    &#x2F;&#x2F; don&#39;t hide websocket classes from webapps (allow webapp to use ones from system classloader)\n       &quot;-org.eclipse.jetty.apache.&quot;,       &#x2F;&#x2F; don&#39;t hide jetty apache impls\n       &quot;-org.eclipse.jetty.util.log.&quot;,     &#x2F;&#x2F; don&#39;t hide server log\n       &quot;-org.eclipse.jetty.servlet.ServletContextHandler.Decorator&quot;, &#x2F;&#x2F; don&#39;t hide CDI &#x2F; weld interface\n       &quot;org.objectweb.asm.&quot;,               &#x2F;&#x2F; hide asm used by jetty\n       &quot;org.eclipse.jdt.&quot;,                 &#x2F;&#x2F; hide jdt used by jetty\n       &quot;org.eclipse.jetty.&quot;                &#x2F;&#x2F; hide other jetty classes\n&#125; ;</code></pre>\n\n<p>我们可以通过， org.eclipse.jetty.webapp.WebAppContext.setServerClasses(String Array) 或 org.eclipse.jetty.webapp.WebAppContext.addServerClass(String)方法设置 Server 类。 注意，Server 类是对所有应用都不可见的，但是 WEB-INF&#x2F;lib 下的类可以替换 Server 类。<br>当默认的 WebAppClassLoader 不能满足需求时，可以自定义 WebApp ClassLoader，不过 jetty 建议自定义的 classloader 要扩展于默认的 WebAppClassLoader 实现。</p>\n","categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]}