{"title":"JVM（五）虚拟机类加载机制","slug":"yuque/JVM（五）虚拟机类加载机制","date":"2016-08-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-classloader.json","excerpt":"Java提供了动态的装载特性；它会在运行时的第一次引用到一个class的时候对它进行装载和链接，而不是在编译期进行。JVM的类装载器负责动态装载，基本上所有的类加载器都是java.lang.ClassLoader类的一个实例。Java 类装载器有如下几个特点： * 层级结构：Java   里的类装载器被组织成了有父子关系的层级结构。Bootstrap   类装载器是所有装载器的父亲。 * 代理模式：基于层级结构，类的装载可以在装载器之间进行代理。当装载器装载一个类时，首先会检查它是否在父装载器中进行装载了。如果上层的装载器已经装载了这个类，这个类会被直接使用。反","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648399366418-3969f698-05c9-4cff-add1-293b1155152d.png#clientId=u306ac21e-5323-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubed89250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=462&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=16966&status=done&style=none&taskId=u223acd15-5d93-4b1c-ae01-9341960c4b0&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1648399366431-5776227c-885b-4b1a-98a0-30342d03a183.png#clientId=u306ac21e-5323-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3de9051c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=584&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=23564&status=done&style=none&taskId=ucb17e3d8-fa5e-4875-932d-82e7c9904d7&title="],"content":"<p>Java 提供了动态的装载特性；它会在运行时的第一次引用到一个 class 的时候对它进行装载和链接，而不是在编译期进行。JVM 的类装载器负责动态装载，基本上所有的类加载器都是 java.lang.ClassLoader 类的一个实例。</p>\n<h2 id=\"Java-类装载器\"><a href=\"#Java-类装载器\" class=\"headerlink\" title=\"Java 类装载器\"></a>Java 类装载器</h2><p>有如下几个特点：</p>\n<ul>\n<li><strong>层级结构</strong>：Java 里的类装载器被组织成了有父子关系的层级结构。Bootstrap 类装载器是所有装载器的父亲。</li>\n<li><strong>代理模式</strong>：基于层级结构，类的装载可以在装载器之间进行代理。当装载器装载一个类时，首先会检查它是否在父装载器中进行装载了。如果上层的装载器已经装载了这个类，这个类会被直接使用。反之，类装载器会请求装载这个类。</li>\n<li><strong>可见性限制</strong>：一个子装载器可以查找父装载器中的类，但是一个父装载器不能查找子装载器里的类。</li>\n<li><strong>不允许卸载</strong>：类装载器可以装载一个类但是不可以卸载它，不过可以删除当前的类装载器，然后创建一个新的类装载器。</li>\n</ul>\n<p>每个类装载器都有一个自己的命名空间用来保存已装载的类。当一个类装载器装载一个类时，它会通过保存在命名空间里的类全局限定名(Fully Qualified Class Name)进行搜索来检测这个类是否已经被加载了。如果两个类的全局限定名是一样的，但是如果命名空间不一样的话，那么它们还是不同的类。不同的命名空间表示 class 被不同的类装载器装载。<br>目前 Java 类装载器的代理模型如下所示：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648399366418-3969f698-05c9-4cff-add1-293b1155152d.png#clientId=u306ac21e-5323-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubed89250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=462&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=16966&status=done&style=none&taskId=u223acd15-5d93-4b1c-ae01-9341960c4b0&title=\" alt=\"image.png\"><br>当一个类装载器<strong>（class loader）</strong>被请求装载类时，它首先按照顺序在上层装载器、父装载器以及自身的装载器的缓存里检查这个类是否已经存在。简单来说，就是在缓存里查看这个类是否已经被自己装载过了，如果没有的话，继续查找父类的缓存，直到在 bootstrap 类装载器里也没有找到的话，它就会自己在文件系统里去查找并且加载这个类。</p>\n<ul>\n<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>: 这个类装载器是在 JVM 启动的时候创建的。用于加载 $JAVA_HOME&#x2F;jre&#x2F;lib 下面的类库（或者通过参数-Xbootclasspath 指定），由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不能直接通过引用进行操作。</li>\n<li><strong>扩展类加载器（ExtClassLoader）</strong>: 它装载除了基本的 Java API 以外的扩展类。它也负责装载其他的安全扩展功能。在 sun.misc.Launcher 里作为一个内部类 ExtClassLoader 定义的（即 sun.misc.Launcher$ExtClassLoader），ExtClassLoader 会加载 $JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下的类库（或者通过参数-Djava.ext.dirs 指定）。</li>\n<li><strong>系统类加载器（AppClassloader）</strong>: 如果说 bootstrap class loader 和 extension class loader 负责加载的是 JVM 的组件，那么 system class loader 负责加载的是应用程序类。它负责加载用户在$CLASSPATH里指定的类，是在sun.misc.Launcher里作为一个内部类AppClassLoader定义的（即 sun.misc.Launcher$AppClassLoader），AppClassLoader 会加载 java 环境变量 CLASSPATH 所指定的路径下的类库，而 CLASSPATH 所指定的路径可以通过 System.getProperty(“java.class.path”)获取；当然，该变量也可以覆盖，可以使用参数-cp，例如：java -cp 路径 （可以指定要执行的 class 目录）。</li>\n<li><strong>用户自定义类加载器（UserDefined ClassLoader）</strong>: 这是应用程序开发者用直接用代码实现的类装载器。比如 tomcat 的 StandardClassLoader 属于这一类；当然，大部分情况下使用 AppClassLoader 就足够了。</li>\n</ul>\n<p>如果类装载器查找到一个没有装载的类，它会按照下图的流程来装载和链接这个类：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648399366431-5776227c-885b-4b1a-98a0-30342d03a183.png#clientId=u306ac21e-5323-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3de9051c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=584&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=23564&status=done&style=none&taskId=ucb17e3d8-fa5e-4875-932d-82e7c9904d7&title=\" alt=\"image.png\"></p>\n<h2 id=\"类装载器阶段\"><a href=\"#类装载器阶段\" class=\"headerlink\" title=\"类装载器阶段\"></a>类装载器阶段</h2><p>各阶段描述如下：<br>**Loading: **类的信息从文件中获取并且载入到 JVM 的内存里。<br>**Verifying:**检查读入的结构是否符合 Java 语言规范以及 JVM 规范的描述。这是类装载中最复杂的过程，并且花费的时间也是最长的。并且 JVM TCK 工具的大部分场景的用例也用来测试在装载错误的类的时候是否会出现错误。<br>**Preparing:**分配一个结构用来存储类信息，这个结构中包含了类中定义的成员变量，方法和接口的信息。<br>**Resolving:**把这个类的常量池中的所有的符号引用改变成直接引用。<br>**Initializing:**把类中的变量初始化成合适的值。执行静态初始化程序，把静态变量初始化成指定的值。<br>JVM 规范定义了上面的几个任务，不过它允许具体执行的时候能够有些灵活的变动。</p>\n<h2 id=\"ClassLoader-加载原理\"><a href=\"#ClassLoader-加载原理\" class=\"headerlink\" title=\"ClassLoader 加载原理\"></a>ClassLoader 加载原理</h2><p>下面贴下 jdk 关于类加载的源码，上述四种类加载器中 CustomClassLoader 是用户自定义的，BootStrapClassLoader 是 jvm 创建的，就不展示了；这里展示下 AppClassLoader 和 ExtClassLoader 的启动过程，前面介绍过，AppClassLoader 和 ExtClassLoader 都是在 sun.misc.Launcher 里定义的，大家可以下载 openjdk 来查看。</p>\n<h3 id=\"1、Launcher-初始化\"><a href=\"#1、Launcher-初始化\" class=\"headerlink\" title=\"1、Launcher 初始化\"></a>1、Launcher 初始化</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Launcher() &#123;\n    &#x2F;&#x2F; Create the extension class loader\n    ClassLoader extcl;\n    try &#123;\n        extcl &#x3D; ExtClassLoader.getExtClassLoader();\n    &#125; catch (IOException e) &#123;\n        throw new InternalError(\n            &quot;Could not create extension class loader&quot;, e);\n    &#125;\n\n    &#x2F;&#x2F; Now create the class loader to use to launch the application\n    try &#123;\n        loader &#x3D; AppClassLoader.getAppClassLoader(extcl);\n    &#125; catch (IOException e) &#123;\n        throw new InternalError(\n            &quot;Could not create application class loader&quot;, e);\n    &#125;\n\n    &#x2F;&#x2F; Also set the context class loader for the primordial thread.\n    Thread.currentThread().setContextClassLoader(loader);\n\n    &#x2F;&#x2F; Finally, install a security manager if requested\n    String s &#x3D; System.getProperty(&quot;java.security.manager&quot;);\n    if (s !&#x3D; null) &#123;\n        SecurityManager sm &#x3D; null;\n        if (&quot;&quot;.equals(s) || &quot;default&quot;.equals(s)) &#123;\n            sm &#x3D; new java.lang.SecurityManager();\n        &#125; else &#123;\n            try &#123;\n                sm &#x3D; (SecurityManager)loader.loadClass(s).newInstance();\n            &#125; catch (IllegalAccessException e) &#123;\n            &#125; catch (InstantiationException e) &#123;\n            &#125; catch (ClassNotFoundException e) &#123;\n            &#125; catch (ClassCastException e) &#123;\n            &#125;\n        &#125;\n        if (sm !&#x3D; null) &#123;\n            System.setSecurityManager(sm);\n        &#125; else &#123;\n            throw new InternalError(\n                &quot;Could not create SecurityManager: &quot; + s);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>1）通过 ExtClassLoader.getExtClassLoader()创建了 ExtClassLoader；<br>2）通过 AppClassLoader.getAppClassLoader(ExtClassLoader)创建了 AppClassLoader，并将 ExtClassLoader 设为 AppClassLoader 的 parent ClassLoader；<br>3）通过 Thread.currentThread().setContextClassLoader(loader)把 AppClassLoader 设为线程的上下文 ClassLoader；<br>4）根据 jvm 参数-Djava.security.manager 创建安全管理器，”java.security.manager”默认系统属性为空字符串””。</p>\n<h3 id=\"2、ExtClassLoader-初始化过程\"><a href=\"#2、ExtClassLoader-初始化过程\" class=\"headerlink\" title=\"2、ExtClassLoader 初始化过程\"></a>2、ExtClassLoader 初始化过程</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n * The class loader used for loading installed extensions.\n *&#x2F;\nstatic class ExtClassLoader extends URLClassLoader &#123;\n\n    static &#123;\n        ClassLoader.registerAsParallelCapable();\n    &#125;\n\n    &#x2F;**\n     * create an ExtClassLoader. The ExtClassLoader is created\n     * within a context that limits which files it can read\n     *&#x2F;\n    public static ExtClassLoader getExtClassLoader() throws IOException\n    &#123;\n        final File[] dirs &#x3D; getExtDirs();\n\n        try &#123;\n            &#x2F;&#x2F; Prior implementations of this doPrivileged() block supplied\n            &#x2F;&#x2F; aa synthesized ACC via a call to the private method\n            &#x2F;&#x2F; ExtClassLoader.getContext().\n\n            return AccessController.doPrivileged(\n                new PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;\n                    public ExtClassLoader run() throws IOException &#123;\n                        int len &#x3D; dirs.length;\n                        for (int i &#x3D; 0; i &lt;len; i++) &#123;\n                            MetaIndex.registerDirectory(dirs[i]);\n                        &#125;\n                        return new ExtClassLoader(dirs);\n                    &#125;\n                &#125;);\n        &#125; catch (java.security.PrivilegedActionException e) &#123;\n            throw (IOException) e.getException();\n        &#125;\n    &#125;\n\n    void addExtURL(URL url) &#123;\n        super.addURL(url);\n    &#125;\n\n    &#x2F;*\n     * Creates a new ExtClassLoader for the specified directories.\n     *&#x2F;\n    public ExtClassLoader(File[] dirs) throws IOException &#123;\n        super(getExtURLs(dirs), null, factory);\n        SharedSecrets.getJavaNetAccess().\n            getURLClassPath(this).initLookupCache(this);\n    &#125;\n\n    private static File[] getExtDirs() &#123;\n        String s &#x3D; System.getProperty(&quot;java.ext.dirs&quot;);\n        File[] dirs;\n        if (s !&#x3D; null) &#123;\n            StringTokenizer st &#x3D;\n                new StringTokenizer(s, File.pathSeparator);\n            int count &#x3D; st.countTokens();\n            dirs &#x3D; new File[count];\n            for (int i &#x3D; 0; i &lt;count; i++) &#123;\n                dirs[i] &#x3D; new File(st.nextToken());\n            &#125;\n        &#125; else &#123;\n            dirs &#x3D; new File[0];\n        &#125;\n        return dirs;\n    &#125;\n\n    private static URL[] getExtURLs(File[] dirs) throws IOException &#123;\n        Vector&lt;URL&gt; urls &#x3D; new Vector&lt;URL&gt;();\n        for (int i &#x3D; 0; i &lt;dirs.length; i++) &#123;\n            String[] files &#x3D; dirs[i].list();\n            if (files !&#x3D; null) &#123;\n                for (int j &#x3D; 0; j &lt;files.length; j++) &#123;\n                    if (!files[j].equals(&quot;meta-index&quot;)) &#123;\n                        File f &#x3D; new File(dirs[i], files[j]);\n                        urls.add(getFileURL(f));\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        URL[] ua &#x3D; new URL[urls.size()];\n        urls.copyInto(ua);\n        return ua;\n    &#125;\n\n    &#x2F;*\n     * Searches the installed extension directories for the specified\n     * library name. For each extension directory, we first look for\n     * the native library in the subdirectory whose name is the value\n     * of the system property &lt;code&gt;os.arch&lt;&#x2F;code&gt;. Failing that, we\n     * look in the extension directory itself.\n     *&#x2F;\n    public String findLibrary(String name) &#123;\n        name &#x3D; System.mapLibraryName(name);\n        URL[] urls &#x3D; super.getURLs();\n        File prevDir &#x3D; null;\n        for (int i &#x3D; 0; i &lt;urls.length; i++) &#123;\n            &#x2F;&#x2F; Get the ext directory from the URL\n            File dir &#x3D; new File(urls[i].getPath()).getParentFile();\n            if (dir !&#x3D; null &amp;&amp; !dir.equals(prevDir)) &#123;\n                &#x2F;&#x2F; Look in architecture-specific subdirectory first\n                &#x2F;&#x2F; Read from the saved system properties to avoid deadlock\n                String arch &#x3D; VM.getSavedProperty(&quot;os.arch&quot;);\n                if (arch !&#x3D; null) &#123;\n                    File file &#x3D; new File(new File(dir, arch), name);\n                    if (file.exists()) &#123;\n                        return file.getAbsolutePath();\n                    &#125;\n                &#125;\n                &#x2F;&#x2F; Then check the extension directory\n                File file &#x3D; new File(dir, name);\n                if (file.exists()) &#123;\n                    return file.getAbsolutePath();\n                &#125;\n            &#125;\n            prevDir &#x3D; dir;\n        &#125;\n        return null;\n    &#125;\n\n    private static AccessControlContext getContext(File[] dirs)\n        throws IOException\n    &#123;\n        PathPermissions perms &#x3D;\n            new PathPermissions(dirs);\n\n        ProtectionDomain domain &#x3D; new ProtectionDomain(\n            new CodeSource(perms.getCodeBase(),\n                (java.security.cert.Certificate[]) null),\n            perms);\n\n        AccessControlContext acc &#x3D;\n            new AccessControlContext(new ProtectionDomain[] &#123; domain &#125;);\n\n        return acc;\n    &#125;\n&#125;</code></pre>\n\n<p>这里大家关注下 getExtDirs()这个方法，它会获取属性”java.ext.dirs”所对应的值，然后通过系统分隔符分割，然后加载分割后的字符串对应的目录作为 ClassLoader 的类加载库。</p>\n<h3 id=\"3、AppClassLoader-初始化\"><a href=\"#3、AppClassLoader-初始化\" class=\"headerlink\" title=\"3、AppClassLoader 初始化\"></a>3、AppClassLoader 初始化</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * The class loader used for loading from java.class.path.\n * runs in a restricted security context.\n *&#x2F;\nstatic class AppClassLoader extends URLClassLoader &#123;\n\n    static &#123;\n        ClassLoader.registerAsParallelCapable();\n    &#125;\n\n    public static ClassLoader getAppClassLoader(final ClassLoader extcl)\n        throws IOException\n    &#123;\n        final String s &#x3D; System.getProperty(&quot;java.class.path&quot;);\n        final File[] path &#x3D; (s &#x3D;&#x3D; null) ? new File[0] : getClassPath(s);\n\n        &#x2F;&#x2F; Note: on bugid 4256530\n        &#x2F;&#x2F; Prior implementations of this doPrivileged() block supplied\n        &#x2F;&#x2F; a rather restrictive ACC via a call to the private method\n        &#x2F;&#x2F; AppClassLoader.getContext(). This proved overly restrictive\n        &#x2F;&#x2F; when loading  classes. Specifically it prevent\n        &#x2F;&#x2F; accessClassInPackage.sun.* grants from being honored.\n        &#x2F;&#x2F;\n        return AccessController.doPrivileged(\n            new PrivilegedAction&lt;AppClassLoader&gt;() &#123;\n                public AppClassLoader run() &#123;\n                URL[] urls &#x3D;\n                    (s &#x3D;&#x3D; null) ? new URL[0] : pathToURLs(path);\n                return new AppClassLoader(urls, extcl);\n            &#125;\n        &#125;);\n    &#125;\n\n    final URLClassPath ucp;\n\n    &#x2F;*\n     * Creates a new AppClassLoader\n     *&#x2F;\n    AppClassLoader(URL[] urls, ClassLoader parent) &#123;\n        super(urls, parent, factory);\n        ucp &#x3D; SharedSecrets.getJavaNetAccess().getURLClassPath(this);\n        ucp.initLookupCache(this);\n    &#125;\n\n    &#x2F;**\n     * Override loadClass so we can checkPackageAccess.\n     *&#x2F;\n    public Class&lt;?&gt; loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    &#123;\n        int i &#x3D; name.lastIndexOf(&#39;.&#39;);\n        if (i !&#x3D; -1) &#123;\n            SecurityManager sm &#x3D; System.getSecurityManager();\n            if (sm !&#x3D; null) &#123;\n                sm.checkPackageAccess(name.substring(0, i));\n            &#125;\n        &#125;\n\n        if (ucp.knownToNotExist(name)) &#123;\n            &#x2F;&#x2F; The class of the given name is not found in the parent\n            &#x2F;&#x2F; class loader as well as its local URLClassPath.\n            &#x2F;&#x2F; Check if this class has already been defined dynamically;\n            &#x2F;&#x2F; if so, return the loaded class; otherwise, skip the parent\n            &#x2F;&#x2F; delegation and findClass.\n            Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n            if (c !&#x3D; null) &#123;\n                if (resolve) &#123;\n                    resolveClass(c);\n                &#125;\n                return c;\n            &#125;\n            throw new ClassNotFoundException(name);\n        &#125;\n\n        return (super.loadClass(name, resolve));\n    &#125;\n\n    &#x2F;**\n     * allow any classes loaded from classpath to exit the VM.\n     *&#x2F;\n    protected PermissionCollection getPermissions(CodeSource codesource)\n    &#123;\n        PermissionCollection perms &#x3D; super.getPermissions(codesource);\n        perms.add(new RuntimePermission(&quot;exitVM&quot;));\n        return perms;\n    &#125;\n\n    &#x2F;**\n     * This class loader supports dynamic additions to the class path\n     * at runtime.\n     *\n     * @see java.lang.instrument.Instrumentation&#x3D;appendToSystemClassPathSearch\n     *&#x2F;\n    private void appendToClassPathForInstrumentation(String path) &#123;\n        assert(Thread.holdsLock(this));\n\n        &#x2F;&#x2F; addURL is a no-op if path already contains the URL\n        super.addURL( getFileURL(new File(path)) );\n    &#125;\n\n    &#x2F;**\n     * create a context that can read any directories (recursively)\n     * mentioned in the class path. In the case of a jar, it has to\n     * be the directory containing the jar, not just the jar, as jar\n     * files might refer to other jar files.\n     *&#x2F;\n\n    private static AccessControlContext getContext(File[] cp)\n        throws java.net.MalformedURLException\n    &#123;\n        PathPermissions perms &#x3D;\n            new PathPermissions(cp);\n\n        ProtectionDomain domain &#x3D;\n            new ProtectionDomain(new CodeSource(perms.getCodeBase(),\n                (java.security.cert.Certificate[]) null),\n            perms);\n\n        AccessControlContext acc &#x3D;\n            new AccessControlContext(new ProtectionDomain[] &#123; domain &#125;);\n\n        return acc;\n    &#125;\n&#125;</code></pre>\n\n<p>首先获取”java.class.path”对应的属性，并转换为 URL[]并设置为 ClassLoader 的类加载库，注意这里的方法入参 classloader 就是 ExtClassLoader，在创 AppClassLoader 会传入 ExtClassLoader 作为 parent ClassLoader。<br>上面就是 ClassLoader 的启动和初始化过程，后面会把 loader 作为应用程序的默认 ClassLoader 使用，看下面的测试用例:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String... args) &#123;\n    ClassLoader loader &#x3D; Test.class.getClassLoader();\n    System.err.println(loader);\n    while (loader !&#x3D; null) &#123;\n        loader &#x3D; loader.getParent();\n        System.err.println(loader);\n    &#125;\n&#125;</code></pre>\n\n<p>结果输出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">sun.misc.Launcher$AppClassLoader@75b84c92\nsun.misc.Launcher$ExtClassLoader@1540e19d\nnull</code></pre>\n","more":"<p>Java 提供了动态的装载特性；它会在运行时的第一次引用到一个 class 的时候对它进行装载和链接，而不是在编译期进行。JVM 的类装载器负责动态装载，基本上所有的类加载器都是 java.lang.ClassLoader 类的一个实例。</p>\n<h2 id=\"Java-类装载器\"><a href=\"#Java-类装载器\" class=\"headerlink\" title=\"Java 类装载器\"></a>Java 类装载器</h2><p>有如下几个特点：</p>\n<ul>\n<li><strong>层级结构</strong>：Java 里的类装载器被组织成了有父子关系的层级结构。Bootstrap 类装载器是所有装载器的父亲。</li>\n<li><strong>代理模式</strong>：基于层级结构，类的装载可以在装载器之间进行代理。当装载器装载一个类时，首先会检查它是否在父装载器中进行装载了。如果上层的装载器已经装载了这个类，这个类会被直接使用。反之，类装载器会请求装载这个类。</li>\n<li><strong>可见性限制</strong>：一个子装载器可以查找父装载器中的类，但是一个父装载器不能查找子装载器里的类。</li>\n<li><strong>不允许卸载</strong>：类装载器可以装载一个类但是不可以卸载它，不过可以删除当前的类装载器，然后创建一个新的类装载器。</li>\n</ul>\n<p>每个类装载器都有一个自己的命名空间用来保存已装载的类。当一个类装载器装载一个类时，它会通过保存在命名空间里的类全局限定名(Fully Qualified Class Name)进行搜索来检测这个类是否已经被加载了。如果两个类的全局限定名是一样的，但是如果命名空间不一样的话，那么它们还是不同的类。不同的命名空间表示 class 被不同的类装载器装载。<br>目前 Java 类装载器的代理模型如下所示：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648399366418-3969f698-05c9-4cff-add1-293b1155152d.png#clientId=u306ac21e-5323-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubed89250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=462&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=16966&status=done&style=none&taskId=u223acd15-5d93-4b1c-ae01-9341960c4b0&title=\" alt=\"image.png\"><br>当一个类装载器<strong>（class loader）</strong>被请求装载类时，它首先按照顺序在上层装载器、父装载器以及自身的装载器的缓存里检查这个类是否已经存在。简单来说，就是在缓存里查看这个类是否已经被自己装载过了，如果没有的话，继续查找父类的缓存，直到在 bootstrap 类装载器里也没有找到的话，它就会自己在文件系统里去查找并且加载这个类。</p>\n<ul>\n<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>: 这个类装载器是在 JVM 启动的时候创建的。用于加载 $JAVA_HOME&#x2F;jre&#x2F;lib 下面的类库（或者通过参数-Xbootclasspath 指定），由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不能直接通过引用进行操作。</li>\n<li><strong>扩展类加载器（ExtClassLoader）</strong>: 它装载除了基本的 Java API 以外的扩展类。它也负责装载其他的安全扩展功能。在 sun.misc.Launcher 里作为一个内部类 ExtClassLoader 定义的（即 sun.misc.Launcher$ExtClassLoader），ExtClassLoader 会加载 $JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下的类库（或者通过参数-Djava.ext.dirs 指定）。</li>\n<li><strong>系统类加载器（AppClassloader）</strong>: 如果说 bootstrap class loader 和 extension class loader 负责加载的是 JVM 的组件，那么 system class loader 负责加载的是应用程序类。它负责加载用户在$CLASSPATH里指定的类，是在sun.misc.Launcher里作为一个内部类AppClassLoader定义的（即 sun.misc.Launcher$AppClassLoader），AppClassLoader 会加载 java 环境变量 CLASSPATH 所指定的路径下的类库，而 CLASSPATH 所指定的路径可以通过 System.getProperty(“java.class.path”)获取；当然，该变量也可以覆盖，可以使用参数-cp，例如：java -cp 路径 （可以指定要执行的 class 目录）。</li>\n<li><strong>用户自定义类加载器（UserDefined ClassLoader）</strong>: 这是应用程序开发者用直接用代码实现的类装载器。比如 tomcat 的 StandardClassLoader 属于这一类；当然，大部分情况下使用 AppClassLoader 就足够了。</li>\n</ul>\n<p>如果类装载器查找到一个没有装载的类，它会按照下图的流程来装载和链接这个类：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648399366431-5776227c-885b-4b1a-98a0-30342d03a183.png#clientId=u306ac21e-5323-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3de9051c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=584&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=23564&status=done&style=none&taskId=ucb17e3d8-fa5e-4875-932d-82e7c9904d7&title=\" alt=\"image.png\"></p>\n<h2 id=\"类装载器阶段\"><a href=\"#类装载器阶段\" class=\"headerlink\" title=\"类装载器阶段\"></a>类装载器阶段</h2><p>各阶段描述如下：<br>**Loading: **类的信息从文件中获取并且载入到 JVM 的内存里。<br>**Verifying:**检查读入的结构是否符合 Java 语言规范以及 JVM 规范的描述。这是类装载中最复杂的过程，并且花费的时间也是最长的。并且 JVM TCK 工具的大部分场景的用例也用来测试在装载错误的类的时候是否会出现错误。<br>**Preparing:**分配一个结构用来存储类信息，这个结构中包含了类中定义的成员变量，方法和接口的信息。<br>**Resolving:**把这个类的常量池中的所有的符号引用改变成直接引用。<br>**Initializing:**把类中的变量初始化成合适的值。执行静态初始化程序，把静态变量初始化成指定的值。<br>JVM 规范定义了上面的几个任务，不过它允许具体执行的时候能够有些灵活的变动。</p>\n<h2 id=\"ClassLoader-加载原理\"><a href=\"#ClassLoader-加载原理\" class=\"headerlink\" title=\"ClassLoader 加载原理\"></a>ClassLoader 加载原理</h2><p>下面贴下 jdk 关于类加载的源码，上述四种类加载器中 CustomClassLoader 是用户自定义的，BootStrapClassLoader 是 jvm 创建的，就不展示了；这里展示下 AppClassLoader 和 ExtClassLoader 的启动过程，前面介绍过，AppClassLoader 和 ExtClassLoader 都是在 sun.misc.Launcher 里定义的，大家可以下载 openjdk 来查看。</p>\n<h3 id=\"1、Launcher-初始化\"><a href=\"#1、Launcher-初始化\" class=\"headerlink\" title=\"1、Launcher 初始化\"></a>1、Launcher 初始化</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Launcher() &#123;\n    &#x2F;&#x2F; Create the extension class loader\n    ClassLoader extcl;\n    try &#123;\n        extcl &#x3D; ExtClassLoader.getExtClassLoader();\n    &#125; catch (IOException e) &#123;\n        throw new InternalError(\n            &quot;Could not create extension class loader&quot;, e);\n    &#125;\n\n    &#x2F;&#x2F; Now create the class loader to use to launch the application\n    try &#123;\n        loader &#x3D; AppClassLoader.getAppClassLoader(extcl);\n    &#125; catch (IOException e) &#123;\n        throw new InternalError(\n            &quot;Could not create application class loader&quot;, e);\n    &#125;\n\n    &#x2F;&#x2F; Also set the context class loader for the primordial thread.\n    Thread.currentThread().setContextClassLoader(loader);\n\n    &#x2F;&#x2F; Finally, install a security manager if requested\n    String s &#x3D; System.getProperty(&quot;java.security.manager&quot;);\n    if (s !&#x3D; null) &#123;\n        SecurityManager sm &#x3D; null;\n        if (&quot;&quot;.equals(s) || &quot;default&quot;.equals(s)) &#123;\n            sm &#x3D; new java.lang.SecurityManager();\n        &#125; else &#123;\n            try &#123;\n                sm &#x3D; (SecurityManager)loader.loadClass(s).newInstance();\n            &#125; catch (IllegalAccessException e) &#123;\n            &#125; catch (InstantiationException e) &#123;\n            &#125; catch (ClassNotFoundException e) &#123;\n            &#125; catch (ClassCastException e) &#123;\n            &#125;\n        &#125;\n        if (sm !&#x3D; null) &#123;\n            System.setSecurityManager(sm);\n        &#125; else &#123;\n            throw new InternalError(\n                &quot;Could not create SecurityManager: &quot; + s);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>1）通过 ExtClassLoader.getExtClassLoader()创建了 ExtClassLoader；<br>2）通过 AppClassLoader.getAppClassLoader(ExtClassLoader)创建了 AppClassLoader，并将 ExtClassLoader 设为 AppClassLoader 的 parent ClassLoader；<br>3）通过 Thread.currentThread().setContextClassLoader(loader)把 AppClassLoader 设为线程的上下文 ClassLoader；<br>4）根据 jvm 参数-Djava.security.manager 创建安全管理器，”java.security.manager”默认系统属性为空字符串””。</p>\n<h3 id=\"2、ExtClassLoader-初始化过程\"><a href=\"#2、ExtClassLoader-初始化过程\" class=\"headerlink\" title=\"2、ExtClassLoader 初始化过程\"></a>2、ExtClassLoader 初始化过程</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n * The class loader used for loading installed extensions.\n *&#x2F;\nstatic class ExtClassLoader extends URLClassLoader &#123;\n\n    static &#123;\n        ClassLoader.registerAsParallelCapable();\n    &#125;\n\n    &#x2F;**\n     * create an ExtClassLoader. The ExtClassLoader is created\n     * within a context that limits which files it can read\n     *&#x2F;\n    public static ExtClassLoader getExtClassLoader() throws IOException\n    &#123;\n        final File[] dirs &#x3D; getExtDirs();\n\n        try &#123;\n            &#x2F;&#x2F; Prior implementations of this doPrivileged() block supplied\n            &#x2F;&#x2F; aa synthesized ACC via a call to the private method\n            &#x2F;&#x2F; ExtClassLoader.getContext().\n\n            return AccessController.doPrivileged(\n                new PrivilegedExceptionAction&lt;ExtClassLoader&gt;() &#123;\n                    public ExtClassLoader run() throws IOException &#123;\n                        int len &#x3D; dirs.length;\n                        for (int i &#x3D; 0; i &lt;len; i++) &#123;\n                            MetaIndex.registerDirectory(dirs[i]);\n                        &#125;\n                        return new ExtClassLoader(dirs);\n                    &#125;\n                &#125;);\n        &#125; catch (java.security.PrivilegedActionException e) &#123;\n            throw (IOException) e.getException();\n        &#125;\n    &#125;\n\n    void addExtURL(URL url) &#123;\n        super.addURL(url);\n    &#125;\n\n    &#x2F;*\n     * Creates a new ExtClassLoader for the specified directories.\n     *&#x2F;\n    public ExtClassLoader(File[] dirs) throws IOException &#123;\n        super(getExtURLs(dirs), null, factory);\n        SharedSecrets.getJavaNetAccess().\n            getURLClassPath(this).initLookupCache(this);\n    &#125;\n\n    private static File[] getExtDirs() &#123;\n        String s &#x3D; System.getProperty(&quot;java.ext.dirs&quot;);\n        File[] dirs;\n        if (s !&#x3D; null) &#123;\n            StringTokenizer st &#x3D;\n                new StringTokenizer(s, File.pathSeparator);\n            int count &#x3D; st.countTokens();\n            dirs &#x3D; new File[count];\n            for (int i &#x3D; 0; i &lt;count; i++) &#123;\n                dirs[i] &#x3D; new File(st.nextToken());\n            &#125;\n        &#125; else &#123;\n            dirs &#x3D; new File[0];\n        &#125;\n        return dirs;\n    &#125;\n\n    private static URL[] getExtURLs(File[] dirs) throws IOException &#123;\n        Vector&lt;URL&gt; urls &#x3D; new Vector&lt;URL&gt;();\n        for (int i &#x3D; 0; i &lt;dirs.length; i++) &#123;\n            String[] files &#x3D; dirs[i].list();\n            if (files !&#x3D; null) &#123;\n                for (int j &#x3D; 0; j &lt;files.length; j++) &#123;\n                    if (!files[j].equals(&quot;meta-index&quot;)) &#123;\n                        File f &#x3D; new File(dirs[i], files[j]);\n                        urls.add(getFileURL(f));\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        URL[] ua &#x3D; new URL[urls.size()];\n        urls.copyInto(ua);\n        return ua;\n    &#125;\n\n    &#x2F;*\n     * Searches the installed extension directories for the specified\n     * library name. For each extension directory, we first look for\n     * the native library in the subdirectory whose name is the value\n     * of the system property &lt;code&gt;os.arch&lt;&#x2F;code&gt;. Failing that, we\n     * look in the extension directory itself.\n     *&#x2F;\n    public String findLibrary(String name) &#123;\n        name &#x3D; System.mapLibraryName(name);\n        URL[] urls &#x3D; super.getURLs();\n        File prevDir &#x3D; null;\n        for (int i &#x3D; 0; i &lt;urls.length; i++) &#123;\n            &#x2F;&#x2F; Get the ext directory from the URL\n            File dir &#x3D; new File(urls[i].getPath()).getParentFile();\n            if (dir !&#x3D; null &amp;&amp; !dir.equals(prevDir)) &#123;\n                &#x2F;&#x2F; Look in architecture-specific subdirectory first\n                &#x2F;&#x2F; Read from the saved system properties to avoid deadlock\n                String arch &#x3D; VM.getSavedProperty(&quot;os.arch&quot;);\n                if (arch !&#x3D; null) &#123;\n                    File file &#x3D; new File(new File(dir, arch), name);\n                    if (file.exists()) &#123;\n                        return file.getAbsolutePath();\n                    &#125;\n                &#125;\n                &#x2F;&#x2F; Then check the extension directory\n                File file &#x3D; new File(dir, name);\n                if (file.exists()) &#123;\n                    return file.getAbsolutePath();\n                &#125;\n            &#125;\n            prevDir &#x3D; dir;\n        &#125;\n        return null;\n    &#125;\n\n    private static AccessControlContext getContext(File[] dirs)\n        throws IOException\n    &#123;\n        PathPermissions perms &#x3D;\n            new PathPermissions(dirs);\n\n        ProtectionDomain domain &#x3D; new ProtectionDomain(\n            new CodeSource(perms.getCodeBase(),\n                (java.security.cert.Certificate[]) null),\n            perms);\n\n        AccessControlContext acc &#x3D;\n            new AccessControlContext(new ProtectionDomain[] &#123; domain &#125;);\n\n        return acc;\n    &#125;\n&#125;</code></pre>\n\n<p>这里大家关注下 getExtDirs()这个方法，它会获取属性”java.ext.dirs”所对应的值，然后通过系统分隔符分割，然后加载分割后的字符串对应的目录作为 ClassLoader 的类加载库。</p>\n<h3 id=\"3、AppClassLoader-初始化\"><a href=\"#3、AppClassLoader-初始化\" class=\"headerlink\" title=\"3、AppClassLoader 初始化\"></a>3、AppClassLoader 初始化</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * The class loader used for loading from java.class.path.\n * runs in a restricted security context.\n *&#x2F;\nstatic class AppClassLoader extends URLClassLoader &#123;\n\n    static &#123;\n        ClassLoader.registerAsParallelCapable();\n    &#125;\n\n    public static ClassLoader getAppClassLoader(final ClassLoader extcl)\n        throws IOException\n    &#123;\n        final String s &#x3D; System.getProperty(&quot;java.class.path&quot;);\n        final File[] path &#x3D; (s &#x3D;&#x3D; null) ? new File[0] : getClassPath(s);\n\n        &#x2F;&#x2F; Note: on bugid 4256530\n        &#x2F;&#x2F; Prior implementations of this doPrivileged() block supplied\n        &#x2F;&#x2F; a rather restrictive ACC via a call to the private method\n        &#x2F;&#x2F; AppClassLoader.getContext(). This proved overly restrictive\n        &#x2F;&#x2F; when loading  classes. Specifically it prevent\n        &#x2F;&#x2F; accessClassInPackage.sun.* grants from being honored.\n        &#x2F;&#x2F;\n        return AccessController.doPrivileged(\n            new PrivilegedAction&lt;AppClassLoader&gt;() &#123;\n                public AppClassLoader run() &#123;\n                URL[] urls &#x3D;\n                    (s &#x3D;&#x3D; null) ? new URL[0] : pathToURLs(path);\n                return new AppClassLoader(urls, extcl);\n            &#125;\n        &#125;);\n    &#125;\n\n    final URLClassPath ucp;\n\n    &#x2F;*\n     * Creates a new AppClassLoader\n     *&#x2F;\n    AppClassLoader(URL[] urls, ClassLoader parent) &#123;\n        super(urls, parent, factory);\n        ucp &#x3D; SharedSecrets.getJavaNetAccess().getURLClassPath(this);\n        ucp.initLookupCache(this);\n    &#125;\n\n    &#x2F;**\n     * Override loadClass so we can checkPackageAccess.\n     *&#x2F;\n    public Class&lt;?&gt; loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    &#123;\n        int i &#x3D; name.lastIndexOf(&#39;.&#39;);\n        if (i !&#x3D; -1) &#123;\n            SecurityManager sm &#x3D; System.getSecurityManager();\n            if (sm !&#x3D; null) &#123;\n                sm.checkPackageAccess(name.substring(0, i));\n            &#125;\n        &#125;\n\n        if (ucp.knownToNotExist(name)) &#123;\n            &#x2F;&#x2F; The class of the given name is not found in the parent\n            &#x2F;&#x2F; class loader as well as its local URLClassPath.\n            &#x2F;&#x2F; Check if this class has already been defined dynamically;\n            &#x2F;&#x2F; if so, return the loaded class; otherwise, skip the parent\n            &#x2F;&#x2F; delegation and findClass.\n            Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n            if (c !&#x3D; null) &#123;\n                if (resolve) &#123;\n                    resolveClass(c);\n                &#125;\n                return c;\n            &#125;\n            throw new ClassNotFoundException(name);\n        &#125;\n\n        return (super.loadClass(name, resolve));\n    &#125;\n\n    &#x2F;**\n     * allow any classes loaded from classpath to exit the VM.\n     *&#x2F;\n    protected PermissionCollection getPermissions(CodeSource codesource)\n    &#123;\n        PermissionCollection perms &#x3D; super.getPermissions(codesource);\n        perms.add(new RuntimePermission(&quot;exitVM&quot;));\n        return perms;\n    &#125;\n\n    &#x2F;**\n     * This class loader supports dynamic additions to the class path\n     * at runtime.\n     *\n     * @see java.lang.instrument.Instrumentation&#x3D;appendToSystemClassPathSearch\n     *&#x2F;\n    private void appendToClassPathForInstrumentation(String path) &#123;\n        assert(Thread.holdsLock(this));\n\n        &#x2F;&#x2F; addURL is a no-op if path already contains the URL\n        super.addURL( getFileURL(new File(path)) );\n    &#125;\n\n    &#x2F;**\n     * create a context that can read any directories (recursively)\n     * mentioned in the class path. In the case of a jar, it has to\n     * be the directory containing the jar, not just the jar, as jar\n     * files might refer to other jar files.\n     *&#x2F;\n\n    private static AccessControlContext getContext(File[] cp)\n        throws java.net.MalformedURLException\n    &#123;\n        PathPermissions perms &#x3D;\n            new PathPermissions(cp);\n\n        ProtectionDomain domain &#x3D;\n            new ProtectionDomain(new CodeSource(perms.getCodeBase(),\n                (java.security.cert.Certificate[]) null),\n            perms);\n\n        AccessControlContext acc &#x3D;\n            new AccessControlContext(new ProtectionDomain[] &#123; domain &#125;);\n\n        return acc;\n    &#125;\n&#125;</code></pre>\n\n<p>首先获取”java.class.path”对应的属性，并转换为 URL[]并设置为 ClassLoader 的类加载库，注意这里的方法入参 classloader 就是 ExtClassLoader，在创 AppClassLoader 会传入 ExtClassLoader 作为 parent ClassLoader。<br>上面就是 ClassLoader 的启动和初始化过程，后面会把 loader 作为应用程序的默认 ClassLoader 使用，看下面的测试用例:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String... args) &#123;\n    ClassLoader loader &#x3D; Test.class.getClassLoader();\n    System.err.println(loader);\n    while (loader !&#x3D; null) &#123;\n        loader &#x3D; loader.getParent();\n        System.err.println(loader);\n    &#125;\n&#125;</code></pre>\n\n<p>结果输出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">sun.misc.Launcher$AppClassLoader@75b84c92\nsun.misc.Launcher$ExtClassLoader@1540e19d\nnull</code></pre>\n","categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]}