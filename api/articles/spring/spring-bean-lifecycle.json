{"title":"Spring Bean的生命周期","slug":"yuque/Spring Bean的生命周期","date":"2018-07-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/spring/spring-bean-lifecycle.json","excerpt":"要彻底搞清楚 Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应构造方法和setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段。 1. 实例化->Instantiation 2. 属性赋值->Populate 3. 初始化->Initialization 4. 销毁->Destruction实例化 -> 属性赋值 -> 初始化-> 销毁1、影响多个 Bean 的接口实现了这些接口的 Bean 会切入到多个Bean的生命周期中。正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1649521466271-63972c73-03ba-4d2e-a4a0-69cdd8a179c6.png#clientId=u437c72b1-3eed-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=354&id=u714da385&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=562&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=47256&status=done&style=none&taskId=uef4c9713-7b08-483d-860f-b78efc2a756&title=&width=422"],"content":"<p>要彻底搞清楚 Spring 的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应<strong>构造方法</strong>和<strong>setter 方法</strong>的注入，初始化和销毁是用户能自定义扩展的两个阶段。</p>\n<ol>\n<li>实例化-&gt;Instantiation</li>\n<li>属性赋值-&gt;Populate</li>\n<li>初始化-&gt;Initialization</li>\n<li>销毁-&gt;Destruction</li>\n</ol>\n<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>\n<h2 id=\"1、影响多个-Bean-的接口\"><a href=\"#1、影响多个-Bean-的接口\" class=\"headerlink\" title=\"1、影响多个 Bean 的接口\"></a>1、影响多个 Bean 的接口</h2><p>实现了这些接口的 Bean 会切入到多个 Bean 的生命周期中。正因为如此，这些接口的功能非常强大，Spring 内部扩展也经常使用这些接口，例如自动注入以及 AOP 的实现都和他们有关。</p>\n<ul>\n<li>InstantiationAwareBeanPostProcessor</li>\n<li>BeanPostProcessor</li>\n</ul>\n<p>这两兄弟可能是 Spring 扩展中最重要的两个接口！InstantiationAwareBeanPostProcessor 作用于实例化阶段的前后，BeanPostProcessor 作用于初始化阶段的前后。如图：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649521466271-63972c73-03ba-4d2e-a4a0-69cdd8a179c6.png#clientId=u437c72b1-3eed-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=354&id=u714da385&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=562&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=47256&status=done&style=none&taskId=uef4c9713-7b08-483d-860f-b78efc2a756&title=&width=422\" alt=\"image.png\" width=\"422\"><br><strong>其中 InstantiationAwareBeanPostProcessor 继承自 BeanPostProcessor 是 Spring 非常重要的拓展接口</strong><br>1、postProcessBeforeInstantiation 调用时机为 bean 实例化(Instantiation)之前 如果返回了 bean 实例, 则会替代原来正常通过 target bean 生成的 bean 的流程. 典型的例如 aop 返回 proxy 对象. 此时 bean 的执行流程将会缩短, 只会执行 BeanPostProcessor#postProcessAfterInitialization 接口完成初始化。<br>2、postProcessAfterInstantiation 调用时机为 bean 实例化(Instantiation)之后和任何初始化(Initialization)之前。<br>3、postProcessProperties 调用时机为 postProcessAfterInstantiation 执行之后并返回 true, 返回的 PropertyValues 将作用于给定 bean 属性赋值。Spring 5.1 之后出现以替换@Deprecated 标注的 postProcessPropertyValues<br>4、postProcessPropertyValues 已经被标注@Deprecated，后续将会被 postProcessProperties 取代。<br>进入执行流程<br>步骤 1 ：InstantiationAwareBeanPostProcessor 的触发入口 AbstractAutowireCapableBeanFactory #createBean 开始。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Central method of this class: creates a bean instance,\n* populates the bean instance, applies post-processors, etc.\n*\n* @see #doCreateBean\n*&#x2F;\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n    throws BeanCreationException &#123;\n\n    &#x2F;&#x2F; 省略......\n    try &#123;\n        &#x2F;**\n        * 注释1. InstantiationAwareBeanPostProcessor#postProcessorsBeforeInstantiation触发入口\n        *&#x2F;\n        Object bean &#x3D; resolveBeforeInstantiation(beanName, mbdToUse);\n        if (bean !&#x3D; null) &#123;\n            return bean;\n        &#125;\n    &#125; catch (Throwable ex) &#123;\n        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n                                        &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);\n    &#125;\n    &#x2F;&#x2F; 省略......\n    try &#123;\n        &#x2F;**\n        * 注释2. postProcessAfterInstantiation、postProcessProperties 触发入口\n        * 主要逻辑都在doCreateBean()方法中，\n        * 方法中包含了实例化、属性赋值、初始化过程。逻辑很清晰\n        * 这三个方法与三个生命周期阶段一一对应，非常重要\n        *&#x2F;\n        Object beanInstance &#x3D; doCreateBean(beanName, mbdToUse, args);\n        if (logger.isTraceEnabled()) &#123;\n            logger.trace(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n        &#125;\n        return beanInstance;\n    &#125; catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;\n        &#x2F;&#x2F; A previously detected exception with proper bean creation context already,\n        &#x2F;&#x2F; or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\n        throw ex;\n    &#125; catch (Throwable ex) &#123;\n        throw new BeanCreationException(\n            mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);\n    &#125;\n&#125;</code></pre>\n\n<p>步骤 2：注释 1 中，跟进 AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation， 分析 postProcessorsBeforeInstantiation 执行时机 ：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;** 注释1 代码进入后执行InstantiationAwareBeanPostProcessor#ostProcessBeforeInstantiation方法*&#x2F;\n@Nullable\nprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123;\n    Object bean &#x3D; null;\n    if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;\n        &#x2F;&#x2F; Make sure bean class is actually resolved at this point.\n        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;\n            Class&lt;?&gt; targetType &#x3D; determineTargetType(beanName, mbd);\n            if (targetType !&#x3D; null) &#123;\n                &#x2F;**\n                * 注释3：回调beanPostProcessorsBeforeInstantiation实例化，如果返回bean非null则直接执行\n                * 不为空null就直接返回了而不执行doCreateBean()方法了，而该方法是创建Bean对象的方法\n                * beanPostProcessorsAfterInitialization进行实例初始化\n                *&#x2F;\n                bean &#x3D; applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n                if (bean !&#x3D; null) &#123;\n                    &#x2F;** 注释4 *&#x2F;\n                    bean &#x3D; applyBeanPostProcessorsAfterInitialization(bean, beanName);\n                &#125;\n            &#125;\n        &#125;\n        mbd.beforeInstantiationResolved &#x3D; (bean !&#x3D; null);\n    &#125;\n    return bean;\n&#125;\n\n&#x2F;**注释3 代码跟进*&#x2F;\n@Nullable\nprotected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123;\n    for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;\n        if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;\n            &#x2F;**\n            * 注释5：只要其中一个postProcessBeforeInstantiation返回实例bean即结束回调，\n            * 这个bean将会直接返回给bean容器管理\n            *&#x2F;\n            InstantiationAwareBeanPostProcessor ibp &#x3D; (InstantiationAwareBeanPostProcessor) bp;\n            Object result &#x3D; ibp.postProcessBeforeInstantiation(beanClass, beanName);\n            if (result !&#x3D; null) &#123;\n                return result;\n            &#125;\n        &#125;\n    &#125;\n    return null;\n&#125;\n\n&#x2F;** 注释4 代码跟进*&#x2F;\n@Override\npublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n    throws BeansException &#123;\n    Object result &#x3D; existingBean;\n    for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;\n        &#x2F;**注释6 *&#x2F;\n        Object current &#x3D; processor.postProcessAfterInitialization(result, beanName);\n        if (current &#x3D;&#x3D; null) &#123;\n            return result;\n        &#125;\n        result &#x3D; current;\n    &#125;\n    return result;\n&#125;</code></pre>\n\n<p>可以看到，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 Aop 等功能实现的关键点。</p>\n<blockquote>\n<p>代码说明：</p>\n</blockquote>\n<ol>\n<li>注释 5 中，如果 postProcessBeforeInstantiation 方法返回了 Object 是 null;那么就直接返回，调用 doCreateBean 方法();</li>\n<li>注释 5 中，如果 postProcessBeforeInstantiation 返回不为 null;说明修改了 bean 对象;然后这个时候就立马执行 postProcessAfterInitialization 方法(注意这个是初始化之后的方法,也就是通过这个方法实例化了之后，直接执行初始化之后的方法;中间的实例化之后 和 初始化之前都不执行);</li>\n<li>注释 6 中，在调用 postProcessAfterInitialization 方法时候如果返回 null;那么就直接返回，调用 doCreateBean 方法();(初始化之后的方法返回了 null,那就需要调用 doCreateBean 生成对象了)</li>\n<li>在调用 postProcessAfterInitialization 时返回不为 null;那这个 bean 就直接返回给 ioc 容器了初始化之后的操作是这里面最后一个方法了；</li>\n</ol>\n<p>步骤 2：跟进 AbstractAutowireCapableBeanFactory#doCreateBean， 分析 postProcessAfterInstantiation、postProcessProperties 执行时机 ：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n    throws BeanCreationException &#123;\n\n    BeanWrapper instanceWrapper &#x3D; null;\n    if (mbd.isSingleton()) &#123;\n        instanceWrapper &#x3D; this.factoryBeanInstanceCache.remove(beanName);\n    &#125;\n    if (instanceWrapper &#x3D;&#x3D; null) &#123;\n        &#x2F;**  注释7 实例化阶段！ *&#x2F;\n        instanceWrapper &#x3D; createBeanInstance(beanName, mbd, args);\n    &#125;\n    &#x2F;&#x2F; 省略......\n    &#x2F;&#x2F; Initialize the bean instance.\n    Object exposedObject &#x3D; bean;\n    try &#123;\n        &#x2F;** 注释8 依据bean definition 完成bean属性赋值 *&#x2F;\n        populateBean(beanName, mbd, instanceWrapper);\n        &#x2F;** 注释9 执行bean初始化 *&#x2F;\n        exposedObject &#x3D; initializeBean(beanName, exposedObject, mbd);\n    &#125; catch (Throwable ex) &#123;\n        if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;\n            throw (BeanCreationException) ex;\n        &#125; else &#123;\n            throw new BeanCreationException(\n                mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 省略......\n    return exposedObject;\n&#125;</code></pre>\n\n<blockquote>\n<p>这三个方法与三个生命周期阶段一一对应，非常重要</p>\n<ol>\n<li>createBeanInstance() -&gt; 实例化（注释 7）</li>\n<li>populateBean() -&gt; 属性赋值（注释 8）</li>\n<li>initializeBean() -&gt; 初始化（注释 9）</li>\n</ol>\n</blockquote>\n<p>注释 8 中，继续跟进 AbstractAutowireCapableBeanFactory#populateBean</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123;\n\n    &#x2F;&#x2F; Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n    &#x2F;&#x2F; state of the bean before properties are set. This can be used, for example,\n    &#x2F;&#x2F; to support styles of field injection.\n    boolean continueWithPropertyPopulation &#x3D; true;\n    &#x2F;&#x2F; InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation()\n    &#x2F;**\n    * 注释10：满足两个要求：\n    * 1、BeanDefinition为应用程序bean，而非基础框架bean信息。\n    * 2、注册过InstantiationAwareBeanPostProcessor类型接口，上文有提到这个标志位。\n    * 3、注册了多个接口时，只要其中一个postProcessAfterInstantiation返回false，即停止后续执行。\n    *&#x2F;\n    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;\n        for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;\n            if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;\n                InstantiationAwareBeanPostProcessor ibp &#x3D; (InstantiationAwareBeanPostProcessor) bp;\n                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;\n                    continueWithPropertyPopulation &#x3D; false;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 忽略后续的属性赋值操作代码\n&#125;</code></pre>\n\n<p>可以看到该方法在属性赋值方法内，但是在真正执行赋值操作之前。其返回值为 boolean，返回 false 时可以阻断属性赋值阶段（continueWithPropertyPopulation &#x3D; false;）<br>关于 BeanPostProcessor 执行阶段的源码穿插在下文 Aware 接口的调用时机分析中，因为部分 Aware 功能的就是通过他实现的!只需要先记住 BeanPostProcessor 在初始化前后调用就可以了。</p>\n<h2 id=\"2、只调用一次的接口\"><a href=\"#2、只调用一次的接口\" class=\"headerlink\" title=\"2、只调用一次的接口\"></a>2、只调用一次的接口</h2><p>这一大类接口的特点是功能丰富，常用于用户自定义扩展。<br>第二大类中又可以分为两类：</p>\n<ol>\n<li>Aware 类型的接口</li>\n<li>生命周期接口</li>\n</ol>\n<p>Aware 类型的接口的作用就是让我们能够拿到 Spring 容器中的一些资源。基本都能够见名知意，Aware 之前的名字就是可以拿到什么资源，例如 BeanNameAware 可以拿到 BeanName，以此类推。调用时机需要注意：所有的 Aware 方法都是在初始化阶段之前调用的！<br>Aware 接口众多，这里同样通过分类的方式帮助大家记忆。<br>Aware 接口具体可以分为两组，至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是 Aware 接口的执行顺序，能够见名知意的接口不再解释。<br><strong>Aware Group1</strong></p>\n<ol>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ol>\n<p><strong>Aware Group2</strong></p>\n<ol>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware (这个知道的人可能不多，实现该接口能够获取 Spring EL 解析器，用户的自定义注解需要支持 spel 表达式的时候可以使用，非常方便。)</li>\n<li>ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware) 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的 ApplicationContext 对象，因为 ApplicationContext 是一个复合接口，如下：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;\n&#125;</code></pre>\n\n<p>这里涉及常问的问题，<strong>ApplicationContext 和 BeanFactory 的区别</strong>，可以从 ApplicationContext 继承的这几个接口入手，除去 BeanFactory 相关的两个接口（ListableBeanFactory, HierarchicalBeanFactory）就是 ApplicationContext 独有的功能，这里不详细说明。</p>\n<h3 id=\"Aware-调用时机源码分析\"><a href=\"#Aware-调用时机源码分析\" class=\"headerlink\" title=\"Aware 调用时机源码分析\"></a>Aware 调用时机源码分析</h3><p>详情如下，忽略了部分无关代码。代码位置就是我们上文提到的 initializeBean 方法详情，这也说明了 Aware 都是在初始化阶段之前调用的！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 注释9 代码进入 调用初始化阶段\nprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) &#123;\n\n    &#x2F;&#x2F; 注释11 这里调用的是Group1中的三个Bean开头的Aware\n    invokeAwareMethods(beanName, bean);\n\n    Object wrappedBean &#x3D; bean;\n\n    &#x2F;**\n    * 这里调用的是Group2中的几个Aware，\n    * 而实质上这里就是前面所说的BeanPostProcessor的调用点！\n    * 也就是说与Group1中的Aware不同，这里是通过BeanPostProcessor（ApplicationContextAwareProcessor）实现的。\n    *&#x2F;\n    &#x2F;** 注释12 *&#x2F;\n    wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n    &#x2F;** 注释13 下文即将介绍的InitializingBean调用点 *&#x2F;\n    invokeInitMethods(beanName, wrappedBean, mbd);\n    &#x2F;** 注释14 BeanPostProcessor的另一个调用点*&#x2F;\n    wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\n    return wrappedBean;\n&#125;\n\n&#x2F;**注释11 代码进入 *&#x2F;\nprivate void invokeAwareMethods(final String beanName, final Object bean) &#123;\n    if (bean instanceof Aware) &#123;\n        if (bean instanceof BeanNameAware) &#123;\n            ((BeanNameAware) bean).setBeanName(beanName);\n        &#125;\n        if (bean instanceof BeanClassLoaderAware) &#123;\n            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());\n        &#125;\n        if (bean instanceof BeanFactoryAware) &#123;\n            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>注释 11 代码进入后，可以看到并不是所有的 Aware 接口都使用同样的方式调用。Bean××Aware 都是在代码中直接调用的。<br>而 ApplicationContext 相关的 Aware 都是通过 applyBeanPostProcessorsBeforeInitialization 来调用 BeanPostProcessor#postProcessBeforeInitialization()实现的。感兴趣的可以自己看一下 ApplicationContextAwareProcessor 这个类的源码，就是判断当前创建的 Bean 是否实现了相关的 Aware 方法，如果实现了会调用回调方法将资源传递给 Bean。<br>至于 Spring 为什么这么实现，应该没什么特殊的考量。也许和 Spring 的版本升级有关。基于对修改关闭，对扩展开放的原则，Spring 对一些新的 Aware 采用了扩展的方式添加。<br>BeanPostProcessor 的调用时机也能在这里体现，包围住 invokeInitMethods 方法，也就说明了在初始化阶段的前后执行。<br>关于 Aware 接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了。每组中各个 Aware 方法的调用顺序其实没有必要记，有需要的时候点进源码一看便知。</p>\n<h3 id=\"简单的两个生命周期接口\"><a href=\"#简单的两个生命周期接口\" class=\"headerlink\" title=\"简单的两个生命周期接口\"></a>简单的两个生命周期接口</h3><p>至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是 Spring 帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。</p>\n<ol>\n<li>InitializingBean 对应生命周期的初始化阶段，在上面源码的 invokeInitMethods(beanName, wrappedBean, mbd);方法中调用。<br>有一点需要注意，因为 Aware 方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用 Aware 接口获取的资源，这也是我们自定义扩展 Spring 的常用方式。<br>除了实现 InitializingBean 接口之外还能通过注解或者 xml 配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</li>\n<li>DisposableBean 类似于 InitializingBean，对应生命周期的销毁阶段，以 ConfigurableApplicationContext#close()方法作为入口，实现是通过循环取所有实现了 DisposableBean 接口的 Bean 然后调用其 destroy()方法 。感兴趣的可以自行跟一下源码。</li>\n</ol>\n<p>扩展阅读: BeanPostProcessor 注册时机与执行顺序</p>\n<h3 id=\"注册时机\"><a href=\"#注册时机\" class=\"headerlink\" title=\"注册时机\"></a>注册时机</h3><p>我们知道 BeanPostProcessor 也会注册为 Bean，那么 Spring 是如何保证 BeanPostProcessor 在我们的业务 Bean 之前初始化完成呢？请看我们熟悉的 refresh()方法的源码，省略部分无关代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void refresh() throws BeansException, IllegalStateException &#123;\n    synchronized (this.startupShutdownMonitor) &#123;\n\n        try &#123;\n            &#x2F;&#x2F; Allows post-processing of the bean factory in context subclasses.\n            postProcessBeanFactory(beanFactory);\n\n            &#x2F;&#x2F; Invoke factory processors registered as beans in the context.\n            invokeBeanFactoryPostProcessors(beanFactory);\n\n            &#x2F;&#x2F; Register bean processors that intercept bean creation.\n            &#x2F;&#x2F; 所有BeanPostProcesser初始化的调用点\n            registerBeanPostProcessors(beanFactory);\n\n            &#x2F;&#x2F; Initialize message source for this context.\n            initMessageSource();\n\n            &#x2F;&#x2F; Initialize event multicaster for this context.\n            initApplicationEventMulticaster();\n\n            &#x2F;&#x2F; Initialize other special beans in specific context subclasses.\n            onRefresh();\n\n            &#x2F;&#x2F; Check for listener beans and register them.\n            registerListeners();\n\n            &#x2F;&#x2F; Instantiate all remaining (non-lazy-init) singletons.\n            &#x2F;&#x2F; 所有单例非懒加载Bean的调用点\n            finishBeanFactoryInitialization(beanFactory);\n\n            &#x2F;&#x2F; Last step: publish corresponding event.\n            finishRefresh();\n        &#125;\n\n&#125;</code></pre>\n\n<p>可以看出，Spring 是先执行 registerBeanPostProcessors()进行 BeanPostProcessors 的注册，然后再执行 finishBeanFactoryInitialization 初始化我们的单例非懒加载的 Bean。</p>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><p>BeanPostProcessor 有很多个，而且每个 BeanPostProcessor 都影响多个 Bean，其执行顺序至关重要，必须能够控制其执行顺序才行。关于执行顺序这里需要引入两个排序相关的接口：PriorityOrdered、Ordered</p>\n<ul>\n<li>PriorityOrdered 是一等公民，首先被执行，PriorityOrdered 公民之间通过接口返回值排序</li>\n<li>Ordered 是二等公民，然后执行，Ordered 公民之间通过接口返回值排序</li>\n<li>都没有实现是三等公民，最后执行</li>\n</ul>\n<p>在以下源码中，可以很清晰的看到 Spring 注册各种类型 BeanPostProcessor 的逻辑，根据实现不同排序接口进行分组。优先级高的先加入，优先级低的后加入。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n&#x2F;&#x2F; 首先，加入实现了PriorityOrdered接口的BeanPostProcessors，顺便根据PriorityOrdered排了序\nString[] postProcessorNames &#x3D;\n    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) &#123;\n    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    &#125;\n&#125;\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n\n&#x2F;&#x2F; Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n&#x2F;&#x2F; 然后，加入实现了Ordered接口的BeanPostProcessors，顺便根据Ordered排了序\npostProcessorNames &#x3D; beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) &#123;\n    if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    &#125;\n&#125;\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n\n&#x2F;&#x2F; Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n&#x2F;&#x2F; 最后加入其他常规的BeanPostProcessors\nboolean reiterate &#x3D; true;\nwhile (reiterate) &#123;\n    reiterate &#x3D; false;\n    postProcessorNames &#x3D; beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n    for (String ppName : postProcessorNames) &#123;\n        if (!processedBeans.contains(ppName)) &#123;\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n            reiterate &#x3D; true;\n        &#125;\n    &#125;\n    sortPostProcessors(currentRegistryProcessors, beanFactory);\n    registryProcessors.addAll(currentRegistryProcessors);\n    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n    currentRegistryProcessors.clear();\n&#125;&#x2F;&#x2F; First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n&#x2F;&#x2F; 首先，加入实现了PriorityOrdered接口的BeanPostProcessors，顺便根据PriorityOrdered排了序\nString[] postProcessorNames &#x3D;\n    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) &#123;\n    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    &#125;\n&#125;\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n\n&#x2F;&#x2F; Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n&#x2F;&#x2F; 然后，加入实现了Ordered接口的BeanPostProcessors，顺便根据Ordered排了序\npostProcessorNames &#x3D; beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) &#123;\n    if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    &#125;\n&#125;\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n\n&#x2F;&#x2F; Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n&#x2F;&#x2F; 最后加入其他常规的BeanPostProcessors\nboolean reiterate &#x3D; true;\nwhile (reiterate) &#123;\n    reiterate &#x3D; false;\n    postProcessorNames &#x3D; beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n    for (String ppName : postProcessorNames) &#123;\n        if (!processedBeans.contains(ppName)) &#123;\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n            reiterate &#x3D; true;\n        &#125;\n    &#125;\n    sortPostProcessors(currentRegistryProcessors, beanFactory);\n    registryProcessors.addAll(currentRegistryProcessors);\n    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n    currentRegistryProcessors.clear();\n&#125;</code></pre>\n\n<p>根据排序接口返回值排序，默认升序排序，返回值越低优先级越高。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Useful constant for the highest precedence value.\n* @see java.lang.Integer#MIN_VALUE\n*&#x2F;\nint HIGHEST_PRECEDENCE &#x3D; Integer.MIN_VALUE;\n\n&#x2F;**\n* Useful constant for the lowest precedence value.\n* @see java.lang.Integer#MAX_VALUE\n*&#x2F;\nint LOWEST_PRECEDENCE &#x3D; Integer.MAX_VALUE;&#125;</code></pre>\n\n<p>PriorityOrdered、Ordered 接口作为 Spring 整个框架通用的排序接口，在 Spring 中应用广泛，也是非常重要的接口。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Spring Bean 的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个 Bean 和影响单个 Bean。整理如下：</p>\n<blockquote>\n<p><strong>四个阶段</strong></p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>多个扩展点</strong></p>\n<ul>\n<li>影响多个 Bean<ul>\n<li>BeanPostProcessor</li>\n<li>InstantiationAwareBeanPostProcessor</li>\n</ul>\n</li>\n<li>影响单个 Bean<ul>\n<li>Aware<ul>\n<li>Aware Group1<ul>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ul>\n</li>\n<li>Aware Group2<ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware</li>\n<li>ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生命周期<ul>\n<li>InitializingBean</li>\n<li>DisposableBean</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ol>\n<li>如果实现了 BeanFactoryPostProcessor 接口，那么在容器启动的时候，该接口中的 postProcessBeanFactory 方法可以修改 Bean 中元数据中的信息。该方法是在实例化对象之前执行</li>\n<li>如果实现了 InstantiationAwareBeanPostProcessor 接口，那么在实例化 Bean 对象之前会调用<strong>postProcessBeforeInstantiation</strong>方法，该方法如果返回的不为 null 则会直接调用 postProcessAfterInitialization 方法，而跳过了 Bean 实例化后及初始化前的相关方法，如果返回 null 则正常流程，<strong>postProcessAfterInstantiation</strong>在实例化成功后执行，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是 null。因为它的返回值是决定要不要调用 postProcessPropertyValues 方法的其中一个因素，因为还有一个因素是 mbd.getDependencyCheck()；如果该方法返回 false,并且不需要 check，那么 postProcessPropertyValues 就会被忽略不执行；如果返回 true, postProcessPropertyValues 就会被执行,<strong>postProcessPropertyValues</strong>用来修改属性，在初始化方法之前执行。</li>\n<li>如果实现了 Aware 相关的结果，那么相关的 set 方法会在初始化之前执行。</li>\n<li>如果实现了 BeanPostProcessor 接口，那么该接口的方法会在实例化后的初始化方法前后执行。</li>\n<li>如果实现了 InitializingBean 接口则在初始化的时候执行 afterPropertiesSet</li>\n<li>如果指定了 init-method 属性则在初始化的时候会执行指定的方法。</li>\n<li>如果指定了@PostConstruct 则在初始化的时候会执行标注的方法。</li>\n<li>到此对象创建完成</li>\n<li>当对象需要销毁的时候。</li>\n<li>如果实现了 DisposableBean 接口会执行 destroy 方法</li>\n<li>如果指定了 destroy-method 属性则会执行指定的方法</li>\n<li>如果指定了@PreDestroy 注解则会执行标注的方法</li>\n</ol>\n</blockquote>\n<p>至此，Spring Bean 的生命周期介绍完毕。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/zrtqsk/p/3735273.html\">Spring Bean 的生命周期（详细）</a><br><a href=\"https://blog.csdn.net/qq_20021569/article/details/109178816\">Spring Bean 的生命周期（Spring5）</a><br><a href=\"https://blog.csdn.net/riemann_/article/details/118500805\">一文读懂 Spring Bean 的生命周期</a></p>\n","more":"<p>要彻底搞清楚 Spring 的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应<strong>构造方法</strong>和<strong>setter 方法</strong>的注入，初始化和销毁是用户能自定义扩展的两个阶段。</p>\n<ol>\n<li>实例化-&gt;Instantiation</li>\n<li>属性赋值-&gt;Populate</li>\n<li>初始化-&gt;Initialization</li>\n<li>销毁-&gt;Destruction</li>\n</ol>\n<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>\n<h2 id=\"1、影响多个-Bean-的接口\"><a href=\"#1、影响多个-Bean-的接口\" class=\"headerlink\" title=\"1、影响多个 Bean 的接口\"></a>1、影响多个 Bean 的接口</h2><p>实现了这些接口的 Bean 会切入到多个 Bean 的生命周期中。正因为如此，这些接口的功能非常强大，Spring 内部扩展也经常使用这些接口，例如自动注入以及 AOP 的实现都和他们有关。</p>\n<ul>\n<li>InstantiationAwareBeanPostProcessor</li>\n<li>BeanPostProcessor</li>\n</ul>\n<p>这两兄弟可能是 Spring 扩展中最重要的两个接口！InstantiationAwareBeanPostProcessor 作用于实例化阶段的前后，BeanPostProcessor 作用于初始化阶段的前后。如图：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649521466271-63972c73-03ba-4d2e-a4a0-69cdd8a179c6.png#clientId=u437c72b1-3eed-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=354&id=u714da385&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=562&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=47256&status=done&style=none&taskId=uef4c9713-7b08-483d-860f-b78efc2a756&title=&width=422\" alt=\"image.png\" width=\"422\"><br><strong>其中 InstantiationAwareBeanPostProcessor 继承自 BeanPostProcessor 是 Spring 非常重要的拓展接口</strong><br>1、postProcessBeforeInstantiation 调用时机为 bean 实例化(Instantiation)之前 如果返回了 bean 实例, 则会替代原来正常通过 target bean 生成的 bean 的流程. 典型的例如 aop 返回 proxy 对象. 此时 bean 的执行流程将会缩短, 只会执行 BeanPostProcessor#postProcessAfterInitialization 接口完成初始化。<br>2、postProcessAfterInstantiation 调用时机为 bean 实例化(Instantiation)之后和任何初始化(Initialization)之前。<br>3、postProcessProperties 调用时机为 postProcessAfterInstantiation 执行之后并返回 true, 返回的 PropertyValues 将作用于给定 bean 属性赋值。Spring 5.1 之后出现以替换@Deprecated 标注的 postProcessPropertyValues<br>4、postProcessPropertyValues 已经被标注@Deprecated，后续将会被 postProcessProperties 取代。<br>进入执行流程<br>步骤 1 ：InstantiationAwareBeanPostProcessor 的触发入口 AbstractAutowireCapableBeanFactory #createBean 开始。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Central method of this class: creates a bean instance,\n* populates the bean instance, applies post-processors, etc.\n*\n* @see #doCreateBean\n*&#x2F;\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n    throws BeanCreationException &#123;\n\n    &#x2F;&#x2F; 省略......\n    try &#123;\n        &#x2F;**\n        * 注释1. InstantiationAwareBeanPostProcessor#postProcessorsBeforeInstantiation触发入口\n        *&#x2F;\n        Object bean &#x3D; resolveBeforeInstantiation(beanName, mbdToUse);\n        if (bean !&#x3D; null) &#123;\n            return bean;\n        &#125;\n    &#125; catch (Throwable ex) &#123;\n        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n                                        &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);\n    &#125;\n    &#x2F;&#x2F; 省略......\n    try &#123;\n        &#x2F;**\n        * 注释2. postProcessAfterInstantiation、postProcessProperties 触发入口\n        * 主要逻辑都在doCreateBean()方法中，\n        * 方法中包含了实例化、属性赋值、初始化过程。逻辑很清晰\n        * 这三个方法与三个生命周期阶段一一对应，非常重要\n        *&#x2F;\n        Object beanInstance &#x3D; doCreateBean(beanName, mbdToUse, args);\n        if (logger.isTraceEnabled()) &#123;\n            logger.trace(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);\n        &#125;\n        return beanInstance;\n    &#125; catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;\n        &#x2F;&#x2F; A previously detected exception with proper bean creation context already,\n        &#x2F;&#x2F; or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\n        throw ex;\n    &#125; catch (Throwable ex) &#123;\n        throw new BeanCreationException(\n            mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);\n    &#125;\n&#125;</code></pre>\n\n<p>步骤 2：注释 1 中，跟进 AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation， 分析 postProcessorsBeforeInstantiation 执行时机 ：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;** 注释1 代码进入后执行InstantiationAwareBeanPostProcessor#ostProcessBeforeInstantiation方法*&#x2F;\n@Nullable\nprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123;\n    Object bean &#x3D; null;\n    if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;\n        &#x2F;&#x2F; Make sure bean class is actually resolved at this point.\n        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;\n            Class&lt;?&gt; targetType &#x3D; determineTargetType(beanName, mbd);\n            if (targetType !&#x3D; null) &#123;\n                &#x2F;**\n                * 注释3：回调beanPostProcessorsBeforeInstantiation实例化，如果返回bean非null则直接执行\n                * 不为空null就直接返回了而不执行doCreateBean()方法了，而该方法是创建Bean对象的方法\n                * beanPostProcessorsAfterInitialization进行实例初始化\n                *&#x2F;\n                bean &#x3D; applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n                if (bean !&#x3D; null) &#123;\n                    &#x2F;** 注释4 *&#x2F;\n                    bean &#x3D; applyBeanPostProcessorsAfterInitialization(bean, beanName);\n                &#125;\n            &#125;\n        &#125;\n        mbd.beforeInstantiationResolved &#x3D; (bean !&#x3D; null);\n    &#125;\n    return bean;\n&#125;\n\n&#x2F;**注释3 代码跟进*&#x2F;\n@Nullable\nprotected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123;\n    for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;\n        if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;\n            &#x2F;**\n            * 注释5：只要其中一个postProcessBeforeInstantiation返回实例bean即结束回调，\n            * 这个bean将会直接返回给bean容器管理\n            *&#x2F;\n            InstantiationAwareBeanPostProcessor ibp &#x3D; (InstantiationAwareBeanPostProcessor) bp;\n            Object result &#x3D; ibp.postProcessBeforeInstantiation(beanClass, beanName);\n            if (result !&#x3D; null) &#123;\n                return result;\n            &#125;\n        &#125;\n    &#125;\n    return null;\n&#125;\n\n&#x2F;** 注释4 代码跟进*&#x2F;\n@Override\npublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n    throws BeansException &#123;\n    Object result &#x3D; existingBean;\n    for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;\n        &#x2F;**注释6 *&#x2F;\n        Object current &#x3D; processor.postProcessAfterInitialization(result, beanName);\n        if (current &#x3D;&#x3D; null) &#123;\n            return result;\n        &#125;\n        result &#x3D; current;\n    &#125;\n    return result;\n&#125;</code></pre>\n\n<p>可以看到，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 Aop 等功能实现的关键点。</p>\n<blockquote>\n<p>代码说明：</p>\n</blockquote>\n<ol>\n<li>注释 5 中，如果 postProcessBeforeInstantiation 方法返回了 Object 是 null;那么就直接返回，调用 doCreateBean 方法();</li>\n<li>注释 5 中，如果 postProcessBeforeInstantiation 返回不为 null;说明修改了 bean 对象;然后这个时候就立马执行 postProcessAfterInitialization 方法(注意这个是初始化之后的方法,也就是通过这个方法实例化了之后，直接执行初始化之后的方法;中间的实例化之后 和 初始化之前都不执行);</li>\n<li>注释 6 中，在调用 postProcessAfterInitialization 方法时候如果返回 null;那么就直接返回，调用 doCreateBean 方法();(初始化之后的方法返回了 null,那就需要调用 doCreateBean 生成对象了)</li>\n<li>在调用 postProcessAfterInitialization 时返回不为 null;那这个 bean 就直接返回给 ioc 容器了初始化之后的操作是这里面最后一个方法了；</li>\n</ol>\n<p>步骤 2：跟进 AbstractAutowireCapableBeanFactory#doCreateBean， 分析 postProcessAfterInstantiation、postProcessProperties 执行时机 ：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n    throws BeanCreationException &#123;\n\n    BeanWrapper instanceWrapper &#x3D; null;\n    if (mbd.isSingleton()) &#123;\n        instanceWrapper &#x3D; this.factoryBeanInstanceCache.remove(beanName);\n    &#125;\n    if (instanceWrapper &#x3D;&#x3D; null) &#123;\n        &#x2F;**  注释7 实例化阶段！ *&#x2F;\n        instanceWrapper &#x3D; createBeanInstance(beanName, mbd, args);\n    &#125;\n    &#x2F;&#x2F; 省略......\n    &#x2F;&#x2F; Initialize the bean instance.\n    Object exposedObject &#x3D; bean;\n    try &#123;\n        &#x2F;** 注释8 依据bean definition 完成bean属性赋值 *&#x2F;\n        populateBean(beanName, mbd, instanceWrapper);\n        &#x2F;** 注释9 执行bean初始化 *&#x2F;\n        exposedObject &#x3D; initializeBean(beanName, exposedObject, mbd);\n    &#125; catch (Throwable ex) &#123;\n        if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;\n            throw (BeanCreationException) ex;\n        &#125; else &#123;\n            throw new BeanCreationException(\n                mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 省略......\n    return exposedObject;\n&#125;</code></pre>\n\n<blockquote>\n<p>这三个方法与三个生命周期阶段一一对应，非常重要</p>\n<ol>\n<li>createBeanInstance() -&gt; 实例化（注释 7）</li>\n<li>populateBean() -&gt; 属性赋值（注释 8）</li>\n<li>initializeBean() -&gt; 初始化（注释 9）</li>\n</ol>\n</blockquote>\n<p>注释 8 中，继续跟进 AbstractAutowireCapableBeanFactory#populateBean</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123;\n\n    &#x2F;&#x2F; Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n    &#x2F;&#x2F; state of the bean before properties are set. This can be used, for example,\n    &#x2F;&#x2F; to support styles of field injection.\n    boolean continueWithPropertyPopulation &#x3D; true;\n    &#x2F;&#x2F; InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation()\n    &#x2F;**\n    * 注释10：满足两个要求：\n    * 1、BeanDefinition为应用程序bean，而非基础框架bean信息。\n    * 2、注册过InstantiationAwareBeanPostProcessor类型接口，上文有提到这个标志位。\n    * 3、注册了多个接口时，只要其中一个postProcessAfterInstantiation返回false，即停止后续执行。\n    *&#x2F;\n    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;\n        for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;\n            if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;\n                InstantiationAwareBeanPostProcessor ibp &#x3D; (InstantiationAwareBeanPostProcessor) bp;\n                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;\n                    continueWithPropertyPopulation &#x3D; false;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; 忽略后续的属性赋值操作代码\n&#125;</code></pre>\n\n<p>可以看到该方法在属性赋值方法内，但是在真正执行赋值操作之前。其返回值为 boolean，返回 false 时可以阻断属性赋值阶段（continueWithPropertyPopulation &#x3D; false;）<br>关于 BeanPostProcessor 执行阶段的源码穿插在下文 Aware 接口的调用时机分析中，因为部分 Aware 功能的就是通过他实现的!只需要先记住 BeanPostProcessor 在初始化前后调用就可以了。</p>\n<h2 id=\"2、只调用一次的接口\"><a href=\"#2、只调用一次的接口\" class=\"headerlink\" title=\"2、只调用一次的接口\"></a>2、只调用一次的接口</h2><p>这一大类接口的特点是功能丰富，常用于用户自定义扩展。<br>第二大类中又可以分为两类：</p>\n<ol>\n<li>Aware 类型的接口</li>\n<li>生命周期接口</li>\n</ol>\n<p>Aware 类型的接口的作用就是让我们能够拿到 Spring 容器中的一些资源。基本都能够见名知意，Aware 之前的名字就是可以拿到什么资源，例如 BeanNameAware 可以拿到 BeanName，以此类推。调用时机需要注意：所有的 Aware 方法都是在初始化阶段之前调用的！<br>Aware 接口众多，这里同样通过分类的方式帮助大家记忆。<br>Aware 接口具体可以分为两组，至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是 Aware 接口的执行顺序，能够见名知意的接口不再解释。<br><strong>Aware Group1</strong></p>\n<ol>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ol>\n<p><strong>Aware Group2</strong></p>\n<ol>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware (这个知道的人可能不多，实现该接口能够获取 Spring EL 解析器，用户的自定义注解需要支持 spel 表达式的时候可以使用，非常方便。)</li>\n<li>ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware) 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的 ApplicationContext 对象，因为 ApplicationContext 是一个复合接口，如下：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;\n&#125;</code></pre>\n\n<p>这里涉及常问的问题，<strong>ApplicationContext 和 BeanFactory 的区别</strong>，可以从 ApplicationContext 继承的这几个接口入手，除去 BeanFactory 相关的两个接口（ListableBeanFactory, HierarchicalBeanFactory）就是 ApplicationContext 独有的功能，这里不详细说明。</p>\n<h3 id=\"Aware-调用时机源码分析\"><a href=\"#Aware-调用时机源码分析\" class=\"headerlink\" title=\"Aware 调用时机源码分析\"></a>Aware 调用时机源码分析</h3><p>详情如下，忽略了部分无关代码。代码位置就是我们上文提到的 initializeBean 方法详情，这也说明了 Aware 都是在初始化阶段之前调用的！</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 注释9 代码进入 调用初始化阶段\nprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) &#123;\n\n    &#x2F;&#x2F; 注释11 这里调用的是Group1中的三个Bean开头的Aware\n    invokeAwareMethods(beanName, bean);\n\n    Object wrappedBean &#x3D; bean;\n\n    &#x2F;**\n    * 这里调用的是Group2中的几个Aware，\n    * 而实质上这里就是前面所说的BeanPostProcessor的调用点！\n    * 也就是说与Group1中的Aware不同，这里是通过BeanPostProcessor（ApplicationContextAwareProcessor）实现的。\n    *&#x2F;\n    &#x2F;** 注释12 *&#x2F;\n    wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n    &#x2F;** 注释13 下文即将介绍的InitializingBean调用点 *&#x2F;\n    invokeInitMethods(beanName, wrappedBean, mbd);\n    &#x2F;** 注释14 BeanPostProcessor的另一个调用点*&#x2F;\n    wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\n    return wrappedBean;\n&#125;\n\n&#x2F;**注释11 代码进入 *&#x2F;\nprivate void invokeAwareMethods(final String beanName, final Object bean) &#123;\n    if (bean instanceof Aware) &#123;\n        if (bean instanceof BeanNameAware) &#123;\n            ((BeanNameAware) bean).setBeanName(beanName);\n        &#125;\n        if (bean instanceof BeanClassLoaderAware) &#123;\n            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());\n        &#125;\n        if (bean instanceof BeanFactoryAware) &#123;\n            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>注释 11 代码进入后，可以看到并不是所有的 Aware 接口都使用同样的方式调用。Bean××Aware 都是在代码中直接调用的。<br>而 ApplicationContext 相关的 Aware 都是通过 applyBeanPostProcessorsBeforeInitialization 来调用 BeanPostProcessor#postProcessBeforeInitialization()实现的。感兴趣的可以自己看一下 ApplicationContextAwareProcessor 这个类的源码，就是判断当前创建的 Bean 是否实现了相关的 Aware 方法，如果实现了会调用回调方法将资源传递给 Bean。<br>至于 Spring 为什么这么实现，应该没什么特殊的考量。也许和 Spring 的版本升级有关。基于对修改关闭，对扩展开放的原则，Spring 对一些新的 Aware 采用了扩展的方式添加。<br>BeanPostProcessor 的调用时机也能在这里体现，包围住 invokeInitMethods 方法，也就说明了在初始化阶段的前后执行。<br>关于 Aware 接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了。每组中各个 Aware 方法的调用顺序其实没有必要记，有需要的时候点进源码一看便知。</p>\n<h3 id=\"简单的两个生命周期接口\"><a href=\"#简单的两个生命周期接口\" class=\"headerlink\" title=\"简单的两个生命周期接口\"></a>简单的两个生命周期接口</h3><p>至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是 Spring 帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。</p>\n<ol>\n<li>InitializingBean 对应生命周期的初始化阶段，在上面源码的 invokeInitMethods(beanName, wrappedBean, mbd);方法中调用。<br>有一点需要注意，因为 Aware 方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用 Aware 接口获取的资源，这也是我们自定义扩展 Spring 的常用方式。<br>除了实现 InitializingBean 接口之外还能通过注解或者 xml 配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</li>\n<li>DisposableBean 类似于 InitializingBean，对应生命周期的销毁阶段，以 ConfigurableApplicationContext#close()方法作为入口，实现是通过循环取所有实现了 DisposableBean 接口的 Bean 然后调用其 destroy()方法 。感兴趣的可以自行跟一下源码。</li>\n</ol>\n<p>扩展阅读: BeanPostProcessor 注册时机与执行顺序</p>\n<h3 id=\"注册时机\"><a href=\"#注册时机\" class=\"headerlink\" title=\"注册时机\"></a>注册时机</h3><p>我们知道 BeanPostProcessor 也会注册为 Bean，那么 Spring 是如何保证 BeanPostProcessor 在我们的业务 Bean 之前初始化完成呢？请看我们熟悉的 refresh()方法的源码，省略部分无关代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void refresh() throws BeansException, IllegalStateException &#123;\n    synchronized (this.startupShutdownMonitor) &#123;\n\n        try &#123;\n            &#x2F;&#x2F; Allows post-processing of the bean factory in context subclasses.\n            postProcessBeanFactory(beanFactory);\n\n            &#x2F;&#x2F; Invoke factory processors registered as beans in the context.\n            invokeBeanFactoryPostProcessors(beanFactory);\n\n            &#x2F;&#x2F; Register bean processors that intercept bean creation.\n            &#x2F;&#x2F; 所有BeanPostProcesser初始化的调用点\n            registerBeanPostProcessors(beanFactory);\n\n            &#x2F;&#x2F; Initialize message source for this context.\n            initMessageSource();\n\n            &#x2F;&#x2F; Initialize event multicaster for this context.\n            initApplicationEventMulticaster();\n\n            &#x2F;&#x2F; Initialize other special beans in specific context subclasses.\n            onRefresh();\n\n            &#x2F;&#x2F; Check for listener beans and register them.\n            registerListeners();\n\n            &#x2F;&#x2F; Instantiate all remaining (non-lazy-init) singletons.\n            &#x2F;&#x2F; 所有单例非懒加载Bean的调用点\n            finishBeanFactoryInitialization(beanFactory);\n\n            &#x2F;&#x2F; Last step: publish corresponding event.\n            finishRefresh();\n        &#125;\n\n&#125;</code></pre>\n\n<p>可以看出，Spring 是先执行 registerBeanPostProcessors()进行 BeanPostProcessors 的注册，然后再执行 finishBeanFactoryInitialization 初始化我们的单例非懒加载的 Bean。</p>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><p>BeanPostProcessor 有很多个，而且每个 BeanPostProcessor 都影响多个 Bean，其执行顺序至关重要，必须能够控制其执行顺序才行。关于执行顺序这里需要引入两个排序相关的接口：PriorityOrdered、Ordered</p>\n<ul>\n<li>PriorityOrdered 是一等公民，首先被执行，PriorityOrdered 公民之间通过接口返回值排序</li>\n<li>Ordered 是二等公民，然后执行，Ordered 公民之间通过接口返回值排序</li>\n<li>都没有实现是三等公民，最后执行</li>\n</ul>\n<p>在以下源码中，可以很清晰的看到 Spring 注册各种类型 BeanPostProcessor 的逻辑，根据实现不同排序接口进行分组。优先级高的先加入，优先级低的后加入。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n&#x2F;&#x2F; 首先，加入实现了PriorityOrdered接口的BeanPostProcessors，顺便根据PriorityOrdered排了序\nString[] postProcessorNames &#x3D;\n    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) &#123;\n    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    &#125;\n&#125;\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n\n&#x2F;&#x2F; Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n&#x2F;&#x2F; 然后，加入实现了Ordered接口的BeanPostProcessors，顺便根据Ordered排了序\npostProcessorNames &#x3D; beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) &#123;\n    if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    &#125;\n&#125;\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n\n&#x2F;&#x2F; Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n&#x2F;&#x2F; 最后加入其他常规的BeanPostProcessors\nboolean reiterate &#x3D; true;\nwhile (reiterate) &#123;\n    reiterate &#x3D; false;\n    postProcessorNames &#x3D; beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n    for (String ppName : postProcessorNames) &#123;\n        if (!processedBeans.contains(ppName)) &#123;\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n            reiterate &#x3D; true;\n        &#125;\n    &#125;\n    sortPostProcessors(currentRegistryProcessors, beanFactory);\n    registryProcessors.addAll(currentRegistryProcessors);\n    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n    currentRegistryProcessors.clear();\n&#125;&#x2F;&#x2F; First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n&#x2F;&#x2F; 首先，加入实现了PriorityOrdered接口的BeanPostProcessors，顺便根据PriorityOrdered排了序\nString[] postProcessorNames &#x3D;\n    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) &#123;\n    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    &#125;\n&#125;\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n\n&#x2F;&#x2F; Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n&#x2F;&#x2F; 然后，加入实现了Ordered接口的BeanPostProcessors，顺便根据Ordered排了序\npostProcessorNames &#x3D; beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\nfor (String ppName : postProcessorNames) &#123;\n    if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;\n        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n        processedBeans.add(ppName);\n    &#125;\n&#125;\nsortPostProcessors(currentRegistryProcessors, beanFactory);\nregistryProcessors.addAll(currentRegistryProcessors);\ninvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\ncurrentRegistryProcessors.clear();\n\n&#x2F;&#x2F; Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n&#x2F;&#x2F; 最后加入其他常规的BeanPostProcessors\nboolean reiterate &#x3D; true;\nwhile (reiterate) &#123;\n    reiterate &#x3D; false;\n    postProcessorNames &#x3D; beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n    for (String ppName : postProcessorNames) &#123;\n        if (!processedBeans.contains(ppName)) &#123;\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n            reiterate &#x3D; true;\n        &#125;\n    &#125;\n    sortPostProcessors(currentRegistryProcessors, beanFactory);\n    registryProcessors.addAll(currentRegistryProcessors);\n    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n    currentRegistryProcessors.clear();\n&#125;</code></pre>\n\n<p>根据排序接口返回值排序，默认升序排序，返回值越低优先级越高。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Useful constant for the highest precedence value.\n* @see java.lang.Integer#MIN_VALUE\n*&#x2F;\nint HIGHEST_PRECEDENCE &#x3D; Integer.MIN_VALUE;\n\n&#x2F;**\n* Useful constant for the lowest precedence value.\n* @see java.lang.Integer#MAX_VALUE\n*&#x2F;\nint LOWEST_PRECEDENCE &#x3D; Integer.MAX_VALUE;&#125;</code></pre>\n\n<p>PriorityOrdered、Ordered 接口作为 Spring 整个框架通用的排序接口，在 Spring 中应用广泛，也是非常重要的接口。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Spring Bean 的生命周期分为四个阶段和多个扩展点。扩展点又可以分为影响多个 Bean 和影响单个 Bean。整理如下：</p>\n<blockquote>\n<p><strong>四个阶段</strong></p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>多个扩展点</strong></p>\n<ul>\n<li>影响多个 Bean<ul>\n<li>BeanPostProcessor</li>\n<li>InstantiationAwareBeanPostProcessor</li>\n</ul>\n</li>\n<li>影响单个 Bean<ul>\n<li>Aware<ul>\n<li>Aware Group1<ul>\n<li>BeanNameAware</li>\n<li>BeanClassLoaderAware</li>\n<li>BeanFactoryAware</li>\n</ul>\n</li>\n<li>Aware Group2<ul>\n<li>EnvironmentAware</li>\n<li>EmbeddedValueResolverAware</li>\n<li>ApplicationContextAware(ResourceLoaderAware\\ApplicationEventPublisherAware\\MessageSourceAware)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生命周期<ul>\n<li>InitializingBean</li>\n<li>DisposableBean</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ol>\n<li>如果实现了 BeanFactoryPostProcessor 接口，那么在容器启动的时候，该接口中的 postProcessBeanFactory 方法可以修改 Bean 中元数据中的信息。该方法是在实例化对象之前执行</li>\n<li>如果实现了 InstantiationAwareBeanPostProcessor 接口，那么在实例化 Bean 对象之前会调用<strong>postProcessBeforeInstantiation</strong>方法，该方法如果返回的不为 null 则会直接调用 postProcessAfterInitialization 方法，而跳过了 Bean 实例化后及初始化前的相关方法，如果返回 null 则正常流程，<strong>postProcessAfterInstantiation</strong>在实例化成功后执行，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是 null。因为它的返回值是决定要不要调用 postProcessPropertyValues 方法的其中一个因素，因为还有一个因素是 mbd.getDependencyCheck()；如果该方法返回 false,并且不需要 check，那么 postProcessPropertyValues 就会被忽略不执行；如果返回 true, postProcessPropertyValues 就会被执行,<strong>postProcessPropertyValues</strong>用来修改属性，在初始化方法之前执行。</li>\n<li>如果实现了 Aware 相关的结果，那么相关的 set 方法会在初始化之前执行。</li>\n<li>如果实现了 BeanPostProcessor 接口，那么该接口的方法会在实例化后的初始化方法前后执行。</li>\n<li>如果实现了 InitializingBean 接口则在初始化的时候执行 afterPropertiesSet</li>\n<li>如果指定了 init-method 属性则在初始化的时候会执行指定的方法。</li>\n<li>如果指定了@PostConstruct 则在初始化的时候会执行标注的方法。</li>\n<li>到此对象创建完成</li>\n<li>当对象需要销毁的时候。</li>\n<li>如果实现了 DisposableBean 接口会执行 destroy 方法</li>\n<li>如果指定了 destroy-method 属性则会执行指定的方法</li>\n<li>如果指定了@PreDestroy 注解则会执行标注的方法</li>\n</ol>\n</blockquote>\n<p>至此，Spring Bean 的生命周期介绍完毕。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/zrtqsk/p/3735273.html\">Spring Bean 的生命周期（详细）</a><br><a href=\"https://blog.csdn.net/qq_20021569/article/details/109178816\">Spring Bean 的生命周期（Spring5）</a><br><a href=\"https://blog.csdn.net/riemann_/article/details/118500805\">一文读懂 Spring Bean 的生命周期</a></p>\n","categories":[{"name":"spring","path":"api/categories/spring.json"}],"tags":[{"name":"Spring","path":"api/tags/Spring.json"}]}