{"title":"DDD（二）端口和适配器架构","slug":"yuque/DDD（二）端口和适配器架构","date":"2021-09-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/ddd/ports-adapters-architecture.json","excerpt":"> 原文链接：https://herbertograca.com/2017/09/14/ports-adapters-architecture/> 转载：https://www.jianshu.com/p/f39f4537857e这篇文章是软件架构编年史(译)的一部分，这部编年史由一系列关于软件架构的文章组成。在这一系列文章中，我将写下我对软件架构的学习和思考，以及我是如何运用这些知识的。如果你阅读了这个系列中之前的文章，本篇文章的的内容将更有意义。2005 年，AlistairCockburn 构思了端口和适配器架构(又称六边形架构)并记录在他的博客中。下面这句话就是他对该架构的","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1649603355048-a90a05bb-1922-455a-9f43-20ff9bcf1d85.png#clientId=u3394d0a2-5ada-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u01b2defd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=600&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=191413&status=done&style=none&taskId=uc1fa4e29-b3c3-4bc0-a7e3-3192bc0d39b&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1649603384744-dc10c804-2807-4dd4-a46a-07f3484efcb3.png#clientId=u3394d0a2-5ada-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9ba73af9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=262&originWidth=575&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=87576&status=done&style=none&taskId=ua76c3ff7-1602-43b5-9abb-2d8a7d3bd1c&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1649607675100-6acb67d1-cee5-4470-8a60-a265c6e8b256.png#clientId=udbfe8f8e-02a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u929c69dc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=513&originWidth=708&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=99467&status=done&style=none&taskId=uf6a0a72b-a5ba-4f52-b2ac-05b9ddb7ebd&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1649607958490-46f69631-5bbf-4d68-985c-1f56ca2fee20.png#clientId=udbfe8f8e-02a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf8b320f4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=764&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=310444&status=done&style=none&taskId=u4816a965-975f-4b8c-b205-51bbd8bb8d8&title="],"content":"<blockquote>\n<p>原文链接：<a href=\"https://herbertograca.com/2017/09/14/ports-adapters-architecture/\">https://herbertograca.com/2017/09/14/ports-adapters-architecture/</a><br>转载：<a href=\"https://www.jianshu.com/p/f39f4537857e\">https://www.jianshu.com/p/f39f4537857e</a></p>\n</blockquote>\n<p>这篇文章是<a href=\"https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/\">软件架构编年史</a>(<a href=\"https://www.jianshu.com/p/b477b2cc6cfa\">译</a>)的一部分，这部编年史由<a href=\"https://herbertograca.com/category/development/series/software-architecture/\">一系列关于软件架构的文章</a>组成。在这一系列文章中，我将写下我对软件架构的学习和思考，以及我是如何运用这些知识的。如果你阅读了这个系列中之前的文章，本篇文章的的内容将更有意义。<br>2005 年，Alistair Cockburn 构思了<a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">端口和适配器架构</a> (又称<a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">六边形架构</a>)并记录在他的博客中。下面这句话就是他对该架构的目标的定义：</p>\n<blockquote>\n<p>让用户、程序、自动化测试和批处理脚本可以平等地驱动应用，让应用的开发和测试可以独立于其最终运行的设备和数据库。——Alistair Cockburn 2005，<a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">端口和适配器</a></p>\n</blockquote>\n<p>但是，Alistair Cockburn 意识到 <strong>顶部和底部的层次从另一方面来说，就是应用的入口&#x2F;出口</strong>。尽管实际中它们不一样，却有着十分相似的目标，在设计上也是对称的。而且，如果我们想要隔离出应用中间的层次，这些入口和出口能以另一种相似的方式使用。<br>有许多文章在谈及端口和适配器架构时会花很多篇幅在分层上。然而， 我并没有在 Alistair Cockburn 的原文中找到关于分层的只言片语。<br>其思想是将我们的应用看作是一个系统的中心交付物，输入和输出都是通过端口出入应用，这些端口将应用和外部工具、技术以及传达机制隔离开来。应用不应该关心是谁在发送输入或接收输出。这就是为了保护产品免受技术和业务需求演进的影响。由于技术&#x2F;供应商锁定，这些演进可能导致产品刚开发没多久就被废弃。我将在本文中剖析以下主题：</p>\n<ul>\n<li>传统架构方式的问题</li>\n<li>分层架构的演化<ul>\n<li>什么是端口</li>\n<li>什么是适配器</li>\n<li>适配器的两种不同类型</li>\n</ul>\n</li>\n<li>端口和适配器架构优势<ul>\n<li>实现隔离和技术隔离</li>\n<li>传达机制的隔离</li>\n<li>测试</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"传统架构方式的问题\"><a href=\"#传统架构方式的问题\" class=\"headerlink\" title=\"传统架构方式的问题\"></a>传统架构方式的问题</h2><p>传统的架构方式在前端和后端都可能给我们带来问题。<br>在前端，业务逻辑最终可能会渗透到 UI(例如，我们把用例的逻辑放到控制器或视图里，导致这些逻辑不能在其它 UI 界面中重用)， 甚至 UI 会反过来渗透到业务逻辑中(例如，我们会为了模板中需要的业务逻辑在实体中创建对应的方法)。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649603355048-a90a05bb-1922-455a-9f43-20ff9bcf1d85.png#clientId=u3394d0a2-5ada-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u01b2defd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=600&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=191413&status=done&style=none&taskId=uc1fa4e29-b3c3-4bc0-a7e3-3192bc0d39b&title=\" alt=\"image.png\"><br>而在后端，我们可能会在自己的业务逻辑里使用外部类的类型提示、继承或者实例化它们，这会导致对这些外部的库和技术直接引用，最后任由它们渗透到业务逻辑中。</p>\n<h2 id=\"分层架构的演化\"><a href=\"#分层架构的演化\" class=\"headerlink\" title=\"分层架构的演化\"></a>分层架构的演化</h2><p>托<a href=\"https://herbertograca.com/2017/08/24/ebi-architecture/\">EBI</a> (<a href=\"https://www.jianshu.com/p/395814410cf5\">译</a>)和<a href=\"https://herbertograca.com/2017/09/07/domain-driven-design/\">DDD</a>(<a href=\"https://www.jianshu.com/p/812636d55677\">译</a>)的福, 2005 年我们已经知道了“系统中真正重要的是位于中间的层次”。业务逻辑(应该)存在于这些层次之中，它们才是我们和竞品的真正区别。这才是真正的“应用”。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649603384744-dc10c804-2807-4dd4-a46a-07f3484efcb3.png#clientId=u3394d0a2-5ada-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9ba73af9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=262&originWidth=575&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=87576&status=done&style=none&taskId=ua76c3ff7-1602-43b5-9abb-2d8a7d3bd1c&title=\" alt=\"image.png\"><br>但是，Alistair Cockburn 意识到 <strong>顶部和底部的层次从另一方面来说，就是应用的入口&#x2F;出口</strong>。尽管实际中它们不一样，却有着十分相似的目标，在设计上也是对称的。而且，如果我们想要隔离出应用中间的层次，这些入口和出口能以另一种相似的方式使用。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649603507253-bd3ab953-4263-4c3d-b22e-cb3d56e922a7.png#clientId=u3394d0a2-5ada-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u01344caa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=400&originWidth=496&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=161482&status=done&style=none&taskId=ua77e3432-e278-4a2e-83eb-0017d0e144b&title=\" alt=\"image.png\"><br>区别于典型的分层架构图，我们将它们画在系统的左右两侧，而不是上下两边。<br>虽然我们识别出了系统中对称的两侧，但<strong>两侧都可能有若干入口&#x2F;出口</strong>。例如， API 和 UI 就是位于应用左侧的两个不同的入口&#x2F;出口。为了表示应用有若干个入口&#x2F;出口，我们把应用的形状改成了多边形。<strong>应用的形状可以是有多条边的任意多边形</strong>，但最终六边形获得了青睐。这也是“六边形架构”的由来。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649607918007-5c1b4d23-cfdd-4d31-a381-de0f579c715d.png#clientId=udbfe8f8e-02a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud33f6313&margin=%5Bobject%20Object%5D&name=image.png&originHeight=513&originWidth=562&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=203122&status=done&style=none&taskId=u6dc2bbd3-85d0-427e-b368-73878baad76&title=\" alt=\"image.png\"></p>\n<p><a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">端口和适配器架构</a>使用了实现为端口和适配器的抽象层次，解决了传统架构方式带来的问题。</p>\n<h3 id=\"什么端口\"><a href=\"#什么端口\" class=\"headerlink\" title=\"什么端口\"></a>什么端口</h3><p>端口是对其消费者无感知的进入&#x2F;离开应用的入口和出口。在许多编程语言里，端口就是接口。例如，在搜索引擎里它可能是执行搜索的接口。在应用中，我们把这个接口当成入口&#x2F;出口使用，而不用去关心它的具体实现，实际上在所有将接口定义为类型提示的地方，这些实现会被注入。</p>\n<h3 id=\"什么是适配器\"><a href=\"#什么是适配器\" class=\"headerlink\" title=\"什么是适配器\"></a>什么是适配器</h3><p>适配器是将一个接口转换(适配)成另一个接口的类。<br>例如，一个适配器实现了接口 A 并被注入了接口 B。当这个适配器被实例化时，一个实现了接口 B 的对象将从构造方法注入进来。实现了接口 A 的 对象会被注入到需要接口 A 的地方，然后接收方法请求，将其转换并代理给那个实现了接口 B 的内部对象。<br>如果我说的不够明白，别慌，后面我会给出一个更具体的例子。</p>\n<h3 id=\"适配器的两种不同类型\"><a href=\"#适配器的两种不同类型\" class=\"headerlink\" title=\"适配器的两种不同类型\"></a>适配器的两种不同类型</h3><p>左侧代表 UI 的适配器被称为<strong>主适配器</strong>或者<strong>主动适配器</strong>，因为是它们发起了对应用的一些操作。而右侧表示和后端工具链接的适配器，被称为<strong>从适配器</strong>或者<strong>被动适配器</strong>，因为它们只会对主适配器的操作作出响应。<br>端口&#x2F;适配器的用法也有一点区别：</p>\n<ul>\n<li>在<strong>左侧</strong>，适配器依赖端口，该端口的具体实现会被注入到适配器，这个实现包含了用例。换句话说，<strong>端口和它的具体实现(用例)都在应用内部</strong>。</li>\n<li>在<strong>右侧</strong>，适配器<strong>就是</strong>端口的具体实现，它自己将被注入到我们的业务逻辑中，尽管业务逻辑只知道接口。换句话说，<strong>端口在应用内部，而它的具体实现在应用之外</strong>并包装了某个外部工具。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649607675100-6acb67d1-cee5-4470-8a60-a265c6e8b256.png#clientId=udbfe8f8e-02a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u929c69dc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=513&originWidth=708&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=99467&status=done&style=none&taskId=uf6a0a72b-a5ba-4f52-b2ac-05b9ddb7ebd&title=\" alt=\"image.png\"></p>\n<h2 id=\"端口和适配器架构优势\"><a href=\"#端口和适配器架构优势\" class=\"headerlink\" title=\"端口和适配器架构优势\"></a>端口和适配器架构优势</h2><p>使用这种应用位于系统中心的端口&#x2F;适配器设计，让我们可以保持应用和实现细节之间的隔离，这些实现细节包括昙花一现的技术、工具和传达机制。它还让可重用的概念更容易更快速地得到验证并被创建出来。</p>\n<h3 id=\"实现隔离和技术隔离\"><a href=\"#实现隔离和技术隔离\" class=\"headerlink\" title=\"实现隔离和技术隔离\"></a>实现隔离和技术隔离</h3><h4 id=\"上下文\"><a href=\"#上下文\" class=\"headerlink\" title=\"上下文\"></a>上下文</h4><p>我们的应用使用 SOLR 作为搜索引擎，并使用一个开源库连接它并执行搜索。</p>\n<h4 id=\"传统架构方式\"><a href=\"#传统架构方式\" class=\"headerlink\" title=\"传统架构方式\"></a>传统架构方式</h4><p>传统架构方式下，我们会直接在我们的代码中使用库(SOLR)里的类，作为类型提示，或者实例化和&#x2F;或作为我们实现的基类。</p>\n<h4 id=\"端口和适配器架构方式\"><a href=\"#端口和适配器架构方式\" class=\"headerlink\" title=\"端口和适配器架构方式\"></a>端口和适配器架构方式</h4><p>如果采用端口和适配器架构的话，我们会创建一个接口，比如叫做 UserSearchInterface，在代码中用这个接口作为类型提示。我们还会为 SOLR 创建一个实现该接口的适配器，比如叫做 UserSearchSolrAdapter。这个实现是 SOLR 的包装，SOLR 会被注入其中并用来实现接口指定的方法。</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>不久之后，我们想用 Elasticsearch 换掉 SOLR。甚至，对于同样的搜索行为，我们希望有些时候使用 SOLR，有些时候使用 Elasticsearch，在运行时决定就好。<br>如果我们采用传统架构，我们需要查找所有使用 SOLR 的代码并替换成 Elasticsearch。然而，这可不是简单的查找替换：两个引擎的用法不同，方法、输入、输出也不尽相同，替换并不是一件轻松的任务。而在运行时在决定使用那个引擎甚至是不可能的。<br>然而，假设我们使用了端口和适配器架构，我们只需要创建一个新的适配器，比如就叫 UserSearchElasticsearchAdapter，在注入时使用它换掉 SOLR 的适配器，也许改一下 DCI 中的配置就可以做到。我们完全可以使用工厂来决定注入那个适配器，实现在运行时注入不同的实现。</p>\n<h3 id=\"传达机制的隔离\"><a href=\"#传达机制的隔离\" class=\"headerlink\" title=\"传达机制的隔离\"></a>传达机制的隔离</h3><p>和上面这个例子类似，假设我们的应用需要 Web GUI，CLI 和 Web API。我们想在全部三种 UI 中提供某个功能，比如叫做<em>UserProfileUpdate</em>的功能。<br>使用端口和适配器架构的话，我们会在一个应用服务的方法中实现这个功能并将其作为一个用例。服务会实现一个接口，该接口说明了方法、输入以及输出。<br>每个版本的 UI 都有各自的控制器(或控制台命令)来通过这个接口触发期望的逻辑，应用服务接口的具体实现会被注入到 UI 中。这种情况下，适配器实际上就是控制器(或 CLI 命令)。<br>之后我们可以修改 UI，因为我们知道这些修改不会影响业务逻辑。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>上面两个例子中，使用端口和适配器架构会让测试更加容易。第一个例子中，我们用接口(端口)的 Mock 就可以测试应用，而不需要使用 SOLR 或 Elasticsearch 。<br>第二个例子中，所有的 UI 都可以独立于应用进行测试。我们的用例也可以独立于 UI 进行测试，传给服务一些输入再断言结果就好。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在我看来，端口和适配器架构只有一个<strong>目标：将业务逻辑和系统使用的传达机制以及工具隔离</strong>。为此，它使用了常见的编程语言结构：<strong>接口</strong>。<br>在<strong>UI</strong>侧(主动适配器)，我们创建<strong>使用应用接口的适配器</strong>，比如控制器。<br>在<strong>基础设施</strong>侧(被动适配器)，我们创建<strong>实现应用接口的适配器</strong>，比如资源库。<br>这就是全部！<br>然而，我惊讶的发现<a href=\"https://herbertograca.com/2017/08/24/ebi-architecture/\">早在十三年前同样的思想就已经公开发表了</a>(<a href=\"https://www.jianshu.com/p/395814410cf5\">译</a>)，尽管它没有刻意地强调要将工具和传达机制从应用核心中隔离出来。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649607958490-46f69631-5bbf-4d68-985c-1f56ca2fee20.png#clientId=udbfe8f8e-02a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf8b320f4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=764&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=310444&status=done&style=none&taskId=u4816a965-975f-4b8c-b205-51bbd8bb8d8&title=\" alt=\"image.png\"><br>系统和角色的任何交互都要通过边界对象。按照 Jacobson 的描述，角色可以是客户或者管理员(操作员)这样的人类用户，也可以是定时器或者打印机这样的非人类“用户”，它们分别对应着端口和适配器架构中的主动适配器和被动适配器。</p>\n<h2 id=\"引用来源\"><a href=\"#引用来源\" class=\"headerlink\" title=\"引用来源\"></a>引用来源</h2><blockquote>\n<p>1992 – Ivar Jacobson – <a href=\"https://www.amazon.com/Object-Oriented-Software-Engineering-Driven-Approach/dp/0201403471\">Object-Oriented Software Engineering: A use case driven approach</a><br>200? – Alistair Cockburn – <a href=\"http://wiki.c2.com/?HexagonalArchitecture\">Hexagonal Architecture</a><br>2005 – Alistair Cockburn – <a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">Ports and Adapters</a><br>2012 – Benjamin Eberlei – <a href=\"https://beberlei.de/2012/08/13/oop_business_applications_entity_boundary_interactor.html\">OOP Business Applications: Entity, Boundary, Interactor</a><br>2014 – Fideloper – <a href=\"http://fideloper.com/hexagonal-architecture\">Hexagonal Architecture</a><br>2014 – Philip Brown – <a href=\"https://www.culttt.com/2014/12/31/hexagonal-architecture/\">What is Hexagonal Architecture?</a><br>2014 – Jan Stenberg – <a href=\"https://www.infoq.com/news/2014/10/exploring-hexagonal-architecture\">Exploring the Hexagonal Architecture</a><br>2017 – Grzegorz Ziemoński – <a href=\"https://dzone.com/articles/hexagonal-architecture-is-powerful\">Hexagonal Architecture Is Powerful</a><br>2017 – Shamik Mitra – <a href=\"https://dzone.com/articles/hello-hexagonal-architecture-1\">Hello, Hexagonal Architecture</a></p>\n</blockquote>\n","more":"<blockquote>\n<p>原文链接：<a href=\"https://herbertograca.com/2017/09/14/ports-adapters-architecture/\">https://herbertograca.com/2017/09/14/ports-adapters-architecture/</a><br>转载：<a href=\"https://www.jianshu.com/p/f39f4537857e\">https://www.jianshu.com/p/f39f4537857e</a></p>\n</blockquote>\n<p>这篇文章是<a href=\"https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/\">软件架构编年史</a>(<a href=\"https://www.jianshu.com/p/b477b2cc6cfa\">译</a>)的一部分，这部编年史由<a href=\"https://herbertograca.com/category/development/series/software-architecture/\">一系列关于软件架构的文章</a>组成。在这一系列文章中，我将写下我对软件架构的学习和思考，以及我是如何运用这些知识的。如果你阅读了这个系列中之前的文章，本篇文章的的内容将更有意义。<br>2005 年，Alistair Cockburn 构思了<a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">端口和适配器架构</a> (又称<a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">六边形架构</a>)并记录在他的博客中。下面这句话就是他对该架构的目标的定义：</p>\n<blockquote>\n<p>让用户、程序、自动化测试和批处理脚本可以平等地驱动应用，让应用的开发和测试可以独立于其最终运行的设备和数据库。——Alistair Cockburn 2005，<a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">端口和适配器</a></p>\n</blockquote>\n<p>但是，Alistair Cockburn 意识到 <strong>顶部和底部的层次从另一方面来说，就是应用的入口&#x2F;出口</strong>。尽管实际中它们不一样，却有着十分相似的目标，在设计上也是对称的。而且，如果我们想要隔离出应用中间的层次，这些入口和出口能以另一种相似的方式使用。<br>有许多文章在谈及端口和适配器架构时会花很多篇幅在分层上。然而， 我并没有在 Alistair Cockburn 的原文中找到关于分层的只言片语。<br>其思想是将我们的应用看作是一个系统的中心交付物，输入和输出都是通过端口出入应用，这些端口将应用和外部工具、技术以及传达机制隔离开来。应用不应该关心是谁在发送输入或接收输出。这就是为了保护产品免受技术和业务需求演进的影响。由于技术&#x2F;供应商锁定，这些演进可能导致产品刚开发没多久就被废弃。我将在本文中剖析以下主题：</p>\n<ul>\n<li>传统架构方式的问题</li>\n<li>分层架构的演化<ul>\n<li>什么是端口</li>\n<li>什么是适配器</li>\n<li>适配器的两种不同类型</li>\n</ul>\n</li>\n<li>端口和适配器架构优势<ul>\n<li>实现隔离和技术隔离</li>\n<li>传达机制的隔离</li>\n<li>测试</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"传统架构方式的问题\"><a href=\"#传统架构方式的问题\" class=\"headerlink\" title=\"传统架构方式的问题\"></a>传统架构方式的问题</h2><p>传统的架构方式在前端和后端都可能给我们带来问题。<br>在前端，业务逻辑最终可能会渗透到 UI(例如，我们把用例的逻辑放到控制器或视图里，导致这些逻辑不能在其它 UI 界面中重用)， 甚至 UI 会反过来渗透到业务逻辑中(例如，我们会为了模板中需要的业务逻辑在实体中创建对应的方法)。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649603355048-a90a05bb-1922-455a-9f43-20ff9bcf1d85.png#clientId=u3394d0a2-5ada-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u01b2defd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=600&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=191413&status=done&style=none&taskId=uc1fa4e29-b3c3-4bc0-a7e3-3192bc0d39b&title=\" alt=\"image.png\"><br>而在后端，我们可能会在自己的业务逻辑里使用外部类的类型提示、继承或者实例化它们，这会导致对这些外部的库和技术直接引用，最后任由它们渗透到业务逻辑中。</p>\n<h2 id=\"分层架构的演化\"><a href=\"#分层架构的演化\" class=\"headerlink\" title=\"分层架构的演化\"></a>分层架构的演化</h2><p>托<a href=\"https://herbertograca.com/2017/08/24/ebi-architecture/\">EBI</a> (<a href=\"https://www.jianshu.com/p/395814410cf5\">译</a>)和<a href=\"https://herbertograca.com/2017/09/07/domain-driven-design/\">DDD</a>(<a href=\"https://www.jianshu.com/p/812636d55677\">译</a>)的福, 2005 年我们已经知道了“系统中真正重要的是位于中间的层次”。业务逻辑(应该)存在于这些层次之中，它们才是我们和竞品的真正区别。这才是真正的“应用”。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649603384744-dc10c804-2807-4dd4-a46a-07f3484efcb3.png#clientId=u3394d0a2-5ada-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9ba73af9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=262&originWidth=575&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=87576&status=done&style=none&taskId=ua76c3ff7-1602-43b5-9abb-2d8a7d3bd1c&title=\" alt=\"image.png\"><br>但是，Alistair Cockburn 意识到 <strong>顶部和底部的层次从另一方面来说，就是应用的入口&#x2F;出口</strong>。尽管实际中它们不一样，却有着十分相似的目标，在设计上也是对称的。而且，如果我们想要隔离出应用中间的层次，这些入口和出口能以另一种相似的方式使用。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649603507253-bd3ab953-4263-4c3d-b22e-cb3d56e922a7.png#clientId=u3394d0a2-5ada-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u01344caa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=400&originWidth=496&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=161482&status=done&style=none&taskId=ua77e3432-e278-4a2e-83eb-0017d0e144b&title=\" alt=\"image.png\"><br>区别于典型的分层架构图，我们将它们画在系统的左右两侧，而不是上下两边。<br>虽然我们识别出了系统中对称的两侧，但<strong>两侧都可能有若干入口&#x2F;出口</strong>。例如， API 和 UI 就是位于应用左侧的两个不同的入口&#x2F;出口。为了表示应用有若干个入口&#x2F;出口，我们把应用的形状改成了多边形。<strong>应用的形状可以是有多条边的任意多边形</strong>，但最终六边形获得了青睐。这也是“六边形架构”的由来。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649607918007-5c1b4d23-cfdd-4d31-a381-de0f579c715d.png#clientId=udbfe8f8e-02a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud33f6313&margin=%5Bobject%20Object%5D&name=image.png&originHeight=513&originWidth=562&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=203122&status=done&style=none&taskId=u6dc2bbd3-85d0-427e-b368-73878baad76&title=\" alt=\"image.png\"></p>\n<p><a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">端口和适配器架构</a>使用了实现为端口和适配器的抽象层次，解决了传统架构方式带来的问题。</p>\n<h3 id=\"什么端口\"><a href=\"#什么端口\" class=\"headerlink\" title=\"什么端口\"></a>什么端口</h3><p>端口是对其消费者无感知的进入&#x2F;离开应用的入口和出口。在许多编程语言里，端口就是接口。例如，在搜索引擎里它可能是执行搜索的接口。在应用中，我们把这个接口当成入口&#x2F;出口使用，而不用去关心它的具体实现，实际上在所有将接口定义为类型提示的地方，这些实现会被注入。</p>\n<h3 id=\"什么是适配器\"><a href=\"#什么是适配器\" class=\"headerlink\" title=\"什么是适配器\"></a>什么是适配器</h3><p>适配器是将一个接口转换(适配)成另一个接口的类。<br>例如，一个适配器实现了接口 A 并被注入了接口 B。当这个适配器被实例化时，一个实现了接口 B 的对象将从构造方法注入进来。实现了接口 A 的 对象会被注入到需要接口 A 的地方，然后接收方法请求，将其转换并代理给那个实现了接口 B 的内部对象。<br>如果我说的不够明白，别慌，后面我会给出一个更具体的例子。</p>\n<h3 id=\"适配器的两种不同类型\"><a href=\"#适配器的两种不同类型\" class=\"headerlink\" title=\"适配器的两种不同类型\"></a>适配器的两种不同类型</h3><p>左侧代表 UI 的适配器被称为<strong>主适配器</strong>或者<strong>主动适配器</strong>，因为是它们发起了对应用的一些操作。而右侧表示和后端工具链接的适配器，被称为<strong>从适配器</strong>或者<strong>被动适配器</strong>，因为它们只会对主适配器的操作作出响应。<br>端口&#x2F;适配器的用法也有一点区别：</p>\n<ul>\n<li>在<strong>左侧</strong>，适配器依赖端口，该端口的具体实现会被注入到适配器，这个实现包含了用例。换句话说，<strong>端口和它的具体实现(用例)都在应用内部</strong>。</li>\n<li>在<strong>右侧</strong>，适配器<strong>就是</strong>端口的具体实现，它自己将被注入到我们的业务逻辑中，尽管业务逻辑只知道接口。换句话说，<strong>端口在应用内部，而它的具体实现在应用之外</strong>并包装了某个外部工具。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649607675100-6acb67d1-cee5-4470-8a60-a265c6e8b256.png#clientId=udbfe8f8e-02a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u929c69dc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=513&originWidth=708&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=99467&status=done&style=none&taskId=uf6a0a72b-a5ba-4f52-b2ac-05b9ddb7ebd&title=\" alt=\"image.png\"></p>\n<h2 id=\"端口和适配器架构优势\"><a href=\"#端口和适配器架构优势\" class=\"headerlink\" title=\"端口和适配器架构优势\"></a>端口和适配器架构优势</h2><p>使用这种应用位于系统中心的端口&#x2F;适配器设计，让我们可以保持应用和实现细节之间的隔离，这些实现细节包括昙花一现的技术、工具和传达机制。它还让可重用的概念更容易更快速地得到验证并被创建出来。</p>\n<h3 id=\"实现隔离和技术隔离\"><a href=\"#实现隔离和技术隔离\" class=\"headerlink\" title=\"实现隔离和技术隔离\"></a>实现隔离和技术隔离</h3><h4 id=\"上下文\"><a href=\"#上下文\" class=\"headerlink\" title=\"上下文\"></a>上下文</h4><p>我们的应用使用 SOLR 作为搜索引擎，并使用一个开源库连接它并执行搜索。</p>\n<h4 id=\"传统架构方式\"><a href=\"#传统架构方式\" class=\"headerlink\" title=\"传统架构方式\"></a>传统架构方式</h4><p>传统架构方式下，我们会直接在我们的代码中使用库(SOLR)里的类，作为类型提示，或者实例化和&#x2F;或作为我们实现的基类。</p>\n<h4 id=\"端口和适配器架构方式\"><a href=\"#端口和适配器架构方式\" class=\"headerlink\" title=\"端口和适配器架构方式\"></a>端口和适配器架构方式</h4><p>如果采用端口和适配器架构的话，我们会创建一个接口，比如叫做 UserSearchInterface，在代码中用这个接口作为类型提示。我们还会为 SOLR 创建一个实现该接口的适配器，比如叫做 UserSearchSolrAdapter。这个实现是 SOLR 的包装，SOLR 会被注入其中并用来实现接口指定的方法。</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><p>不久之后，我们想用 Elasticsearch 换掉 SOLR。甚至，对于同样的搜索行为，我们希望有些时候使用 SOLR，有些时候使用 Elasticsearch，在运行时决定就好。<br>如果我们采用传统架构，我们需要查找所有使用 SOLR 的代码并替换成 Elasticsearch。然而，这可不是简单的查找替换：两个引擎的用法不同，方法、输入、输出也不尽相同，替换并不是一件轻松的任务。而在运行时在决定使用那个引擎甚至是不可能的。<br>然而，假设我们使用了端口和适配器架构，我们只需要创建一个新的适配器，比如就叫 UserSearchElasticsearchAdapter，在注入时使用它换掉 SOLR 的适配器，也许改一下 DCI 中的配置就可以做到。我们完全可以使用工厂来决定注入那个适配器，实现在运行时注入不同的实现。</p>\n<h3 id=\"传达机制的隔离\"><a href=\"#传达机制的隔离\" class=\"headerlink\" title=\"传达机制的隔离\"></a>传达机制的隔离</h3><p>和上面这个例子类似，假设我们的应用需要 Web GUI，CLI 和 Web API。我们想在全部三种 UI 中提供某个功能，比如叫做<em>UserProfileUpdate</em>的功能。<br>使用端口和适配器架构的话，我们会在一个应用服务的方法中实现这个功能并将其作为一个用例。服务会实现一个接口，该接口说明了方法、输入以及输出。<br>每个版本的 UI 都有各自的控制器(或控制台命令)来通过这个接口触发期望的逻辑，应用服务接口的具体实现会被注入到 UI 中。这种情况下，适配器实际上就是控制器(或 CLI 命令)。<br>之后我们可以修改 UI，因为我们知道这些修改不会影响业务逻辑。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>上面两个例子中，使用端口和适配器架构会让测试更加容易。第一个例子中，我们用接口(端口)的 Mock 就可以测试应用，而不需要使用 SOLR 或 Elasticsearch 。<br>第二个例子中，所有的 UI 都可以独立于应用进行测试。我们的用例也可以独立于 UI 进行测试，传给服务一些输入再断言结果就好。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在我看来，端口和适配器架构只有一个<strong>目标：将业务逻辑和系统使用的传达机制以及工具隔离</strong>。为此，它使用了常见的编程语言结构：<strong>接口</strong>。<br>在<strong>UI</strong>侧(主动适配器)，我们创建<strong>使用应用接口的适配器</strong>，比如控制器。<br>在<strong>基础设施</strong>侧(被动适配器)，我们创建<strong>实现应用接口的适配器</strong>，比如资源库。<br>这就是全部！<br>然而，我惊讶的发现<a href=\"https://herbertograca.com/2017/08/24/ebi-architecture/\">早在十三年前同样的思想就已经公开发表了</a>(<a href=\"https://www.jianshu.com/p/395814410cf5\">译</a>)，尽管它没有刻意地强调要将工具和传达机制从应用核心中隔离出来。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1649607958490-46f69631-5bbf-4d68-985c-1f56ca2fee20.png#clientId=udbfe8f8e-02a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf8b320f4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=764&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=310444&status=done&style=none&taskId=u4816a965-975f-4b8c-b205-51bbd8bb8d8&title=\" alt=\"image.png\"><br>系统和角色的任何交互都要通过边界对象。按照 Jacobson 的描述，角色可以是客户或者管理员(操作员)这样的人类用户，也可以是定时器或者打印机这样的非人类“用户”，它们分别对应着端口和适配器架构中的主动适配器和被动适配器。</p>\n<h2 id=\"引用来源\"><a href=\"#引用来源\" class=\"headerlink\" title=\"引用来源\"></a>引用来源</h2><blockquote>\n<p>1992 – Ivar Jacobson – <a href=\"https://www.amazon.com/Object-Oriented-Software-Engineering-Driven-Approach/dp/0201403471\">Object-Oriented Software Engineering: A use case driven approach</a><br>200? – Alistair Cockburn – <a href=\"http://wiki.c2.com/?HexagonalArchitecture\">Hexagonal Architecture</a><br>2005 – Alistair Cockburn – <a href=\"http://alistair.cockburn.us/Hexagonal+architecture\">Ports and Adapters</a><br>2012 – Benjamin Eberlei – <a href=\"https://beberlei.de/2012/08/13/oop_business_applications_entity_boundary_interactor.html\">OOP Business Applications: Entity, Boundary, Interactor</a><br>2014 – Fideloper – <a href=\"http://fideloper.com/hexagonal-architecture\">Hexagonal Architecture</a><br>2014 – Philip Brown – <a href=\"https://www.culttt.com/2014/12/31/hexagonal-architecture/\">What is Hexagonal Architecture?</a><br>2014 – Jan Stenberg – <a href=\"https://www.infoq.com/news/2014/10/exploring-hexagonal-architecture\">Exploring the Hexagonal Architecture</a><br>2017 – Grzegorz Ziemoński – <a href=\"https://dzone.com/articles/hexagonal-architecture-is-powerful\">Hexagonal Architecture Is Powerful</a><br>2017 – Shamik Mitra – <a href=\"https://dzone.com/articles/hello-hexagonal-architecture-1\">Hello, Hexagonal Architecture</a></p>\n</blockquote>\n","categories":[{"name":"ddd","path":"api/categories/ddd.json"}],"tags":[{"name":"DDD","path":"api/tags/DDD.json"}]}