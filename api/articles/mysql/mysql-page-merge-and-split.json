{"title":"InnoDB中的页合并与分裂","slug":"yuque/InnoDB中的页合并与分裂","date":"2019-03-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-page-merge-and-split.json","excerpt":"原文链接：https://www.percona.com/blog/2017/04/10/innodb-page-merging-and-page-splitting/https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/如果您遇到了全球（为数不多的）MySQL顾问之一并要求他/她审查您的查询和/或模式，我相信他/她会告诉您有关良好主键设计的重要性的一些信息.特别是在 InnoDB的情况下，我相信他们已经开始向","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1646668915534-ed853d29-e5d1-483a-96f5-c493531c15a0.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=727&id=uc6d38939&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1453&originWidth=1024&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=215070&status=done&style=none&taskId=u307ec0b7-5103-4ca1-ac09-04cec335d3e&title=&width=512","https://cdn.nlark.com/yuque/0/2022/png/104130/1646669878783-8795eebb-61d5-4169-ba9c-09589a032e23.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=uc383ca06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=1024&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=88704&status=done&style=none&taskId=uffc6a5d3-ae8e-4734-bdd9-7963bbcbf20&title=&width=512","https://cdn.nlark.com/yuque/0/2022/png/104130/1646670330112-d3a07653-9aed-40c1-aa43-e390bcdb252f.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9b61c215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=203&originWidth=502&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9573&status=done&style=none&taskId=u20366bda-86f8-4ea6-a3a7-4f458028d7e&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1646670744381-096c5efd-35a7-4db2-aec0-f0fcb64d2f3a.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uab3ccebe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=262&originWidth=538&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16177&status=done&style=none&taskId=u61879170-9951-4647-8550-140ace92b8a&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1646670893131-2f4e7133-29a8-4030-a8a7-ba6bab61fd4c.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7b78a3b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=21313&status=done&style=none&taskId=u249cd554-5170-4ecb-8c75-c8b71745f22&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1646671011269-44341865-977e-4047-9e20-5f699efa1c9b.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud9c1aeb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16401&status=done&style=none&taskId=uc5f805ab-046e-4249-97b7-2a3d4606c79&title=","https://cdn.nlark.com/yuque/0/2022/png/104130/1646671241539-f683066e-2371-4731-a610-4bb5c0229b0d.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=ucb06f6a3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=467&originWidth=767&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=219981&status=done&style=none&taskId=u240fdc6a-e1ee-480d-8100-8db03084e59&title=&width=383.5"],"content":"<p>原文链接：<br><a href=\"https://www.percona.com/blog/2017/04/10/innodb-page-merging-and-page-splitting/\">https://www.percona.com/blog/2017/04/10/innodb-page-merging-and-page-splitting/</a><br><a href=\"https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/\">https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/</a></p>\n<p>如果您遇到了全球（为数不多的）MySQL 顾问之一并要求他&#x2F;她审查您的查询和&#x2F;或模式，我相信他&#x2F;她会告诉您有关良好主键设计的重要性的一些信息. 特别是在 InnoDB 的情况下，我相信他们已经开始向您解释索引合并和页面拆分。这两个概念与性能密切相关，您在设计任何索引（不仅仅是 PK）时都应该考虑这种关系。</p>\n<p>这对你来说可能听起来像笨蛋，你可能是对的。这不是一件容易的事情，尤其是在谈论内部结构时。这不是您经常处理的事情，而且通常您根本不想处理它。<br>但有时它是必需的。如果是这样，这篇文章适合你。</p>\n<p>在本文中，我想解释一些最不清楚的 InnoDB 幕后操作：页面索引创建、页面合并和页面拆分。<br>在 Innodb 中，所有数据都是一个索引。你可能也听说过吧？但这究竟是什么意思？</p>\n<h2 id=\"文件表组件\"><a href=\"#文件表组件\" class=\"headerlink\" title=\"文件表组件\"></a>文件表组件</h2><p>假设您安装了 MySQL，最新的 5.7 版本（<a href=\"https://www.percona.com/software/mysql-database/percona-server\">Percona Server for MySQL</a>，对吗？），并且在架构 windmills 中有一个名为 wmills 的表。在数据目录（通常为 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;）中，您将看到它包含：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">data&#x2F;\n  windmills&#x2F;\n      wmills.ibd\n      wmills.frm</code></pre>\n\n<p>这是因为参数 innodb_file_per_table 从 MySQL5.6 开始已经设置为 1。这样设置，schema 中每个表都是一个文件（如果是分区表，则有多个文件）。<br>这里重要的是名为 wmills.ibd 的文件。这个文件被分为 N 个段(Segment) 。每个段 都与一个索引相关联。<br>尽管文件不会因删除数据而收缩，段本身会增长或收缩，下一级为区。一个区仅存在一个段中，并且固定尺寸为 1MB（在默认页大小的情况下）。页(page)是区(extent)的下一级，默认大小为 16KB。<br>因此，一个区(extent)最多可包含 64 页(page)。一个页可以包含 2 到 N 行。一个页可以容纳的行数与行大小有关，这是表结构设计时定义的。InnoDB 中有一条规则说，至少两行必须适合一个页面。因此，我们有 8000 字节的行大小限制。如果您认为这听起来就像俄罗斯娃娃（Matryoshka dolls），没错下面这张图能帮助你理解：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646668915534-ed853d29-e5d1-483a-96f5-c493531c15a0.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=727&id=uc6d38939&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1453&originWidth=1024&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=215070&status=done&style=none&taskId=u307ec0b7-5103-4ca1-ac09-04cec335d3e&title=&width=512\" alt=\"image.png\" width=\"512\"></p>\n<h2 id=\"根，分支与叶子\"><a href=\"#根，分支与叶子\" class=\"headerlink\" title=\"根，分支与叶子\"></a>根，分支与叶子</h2><p>每个页（逻辑上讲即叶子节点）是包含了 2-N 行数据，根据主键排列。树有着特殊的页区管理不同的分支，即内部节点（INodes）。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646669878783-8795eebb-61d5-4169-ba9c-09589a032e23.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=uc383ca06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=1024&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=88704&status=done&style=none&taskId=uffc6a5d3-ae8e-4734-bdd9-7963bbcbf20&title=&width=512\" alt=\"image.png\" width=\"512\"><br>这个图片仅是示例，并不能说明下面的实际输出。<br>具体来看一下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ROOT NODE #3: 4 records, 68 bytes\nNODE POINTER RECORD ≥ (id&#x3D;2) → #197\nINTERNAL NODE #197: 464 records, 7888 bytes\nNODE POINTER RECORD ≥ (id&#x3D;2) → #5\nLEAF NODE #5: 57 records, 7524 bytes\n RECORD: (id&#x3D;2) → (uuid&#x3D;&quot;884e471c-0e82-11e7-8bf6-08002734ed50&quot;, millid&#x3D;139, kwatts_s&#x3D;1956, date&#x3D;&quot;2017-05-01&quot;, location&#x3D;&quot;For beauty&#39;s pattern to succeeding men.Yet do thy&quot;, active&#x3D;1, time&#x3D;&quot;2017-03-21 22:05:45&quot;, strrecordtype&#x3D;&quot;Wit&quot;)</code></pre>\n\n<p>下面是表结构：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;wmills&#96; (\n  &#96;id&#96; bigint(11) NOT NULL AUTO_INCREMENT,\n  &#96;uuid&#96; char(36) COLLATE utf8_bin NOT NULL,\n  &#96;millid&#96; smallint(6) NOT NULL,\n  &#96;kwatts_s&#96; int(11) NOT NULL,\n  &#96;date&#96; date NOT NULL,\n  &#96;location&#96; varchar(50) COLLATE utf8_bin DEFAULT NULL,\n  &#96;active&#96; tinyint(2) NOT NULL DEFAULT &#39;1&#39;,\n  &#96;time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  &#96;strrecordtype&#96; char(3) COLLATE utf8_bin NOT NULL,\n  PRIMARY KEY (&#96;id&#96;),\n  KEY &#96;IDX_millid&#96; (&#96;millid&#96;)\n) ENGINE&#x3D;InnoDB;</code></pre>\n\n<p>所有的 B 树都有着一个入口，也就是根节点，在上图中#3 就是根节点。根节点（页）包含了如索引 ID、INodes 数量等信息。INode 页包含了关于页本身的信息、值的范围等。最后还有叶子节点，也就是我们数据实际所在的位置。在示例中，我们可以看到叶子节点#5 有 57 行记录，共 7524 bytes。在这行信息后是具体的记录，可以看到数据行内容。<br>这里想引出的概念是当你使用 InnoDB 管理表和行，InnoDB 会将他们会以分支、页和记录的形式组织起来。InnoDB 不是按行的来操作的，它可操作的最小粒度是页，页加载进内存后才会通过扫描页来获取行&#x2F;记录。<br>现在页的结构清楚了吗？好，我们继续。</p>\n<h2 id=\"页的内部原理\"><a href=\"#页的内部原理\" class=\"headerlink\" title=\"页的内部原理\"></a>页的内部原理</h2><p>页可以空或者填充满（100%），行记录会按照主键顺序来排列。例如在使用 AUTO_INCREMENT 时，你会有顺序的 ID 1、2、3、4 等。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670330112-d3a07653-9aed-40c1-aa43-e390bcdb252f.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9b61c215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=203&originWidth=502&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9573&status=done&style=none&taskId=u20366bda-86f8-4ea6-a3a7-4f458028d7e&title=\" alt=\"image.png\"><br>页还有另一个重要的属性：<strong>MERGE_THRESHOLD</strong>。该参数的默认值是 50%页的大小，它在 InnoDB 的合并操作中扮演了很重要的角色。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670575250-0189aa82-3b1f-449f-b5d7-7fff7b68f559.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucbf5a575&margin=%5Bobject%20Object%5D&name=image.png&originHeight=205&originWidth=538&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=11879&status=done&style=none&taskId=ufdb2bd63-8d94-4fa0-a4e6-f135015a4ac&title=\" alt=\"image.png\"><br>当你插入数据时，如果数据（大小）能够放的进页中的话，那他们是按顺序将页填满的。<br>若当前页满，则下一行记录会被插入下一页（NEXT）中。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670627767-5435a231-c2ac-44fb-b12f-f9ebedfec97c.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u85e37165&margin=%5Bobject%20Object%5D&name=image.png&originHeight=213&originWidth=502&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9464&status=done&style=none&taskId=u38f7fbf9-f3cd-40ad-9046-033c82813c1&title=\" alt=\"image.png\"><br>根据 B 树的特性，它可以自顶向下遍历，但也可以在各叶子节点水平遍历。因为每个叶子节点都有着一个指向包含下一条（顺序）记录的页的指针。例如，页#5 有指向页#6 的指针，页#6 有指向前一页（#5）的指针和后一页（#7）的指针。<br>这种机制下可以做到快速的顺序扫描（如范围扫描）。之前提到过，这就是当你基于自增主键进行插入的情况。但如果你不仅插入还进行删除呢？</p>\n<h2 id=\"页合并\"><a href=\"#页合并\" class=\"headerlink\" title=\"页合并\"></a>页合并</h2><p>当你删了一行记录时，实际上记录并没有被物理删除，记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670744381-096c5efd-35a7-4db2-aec0-f0fcb64d2f3a.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uab3ccebe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=262&originWidth=538&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16177&status=done&style=none&taskId=u61879170-9951-4647-8550-140ace92b8a&title=\" alt=\"image.png\"><br>当页中删除的记录达到 MERGE_THRESHOLD（默认页体积的 50%），InnoDB 会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670788088-7e174566-bd14-4f60-8f89-44560bb5c82c.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udfa9e513&margin=%5Bobject%20Object%5D&name=image.png&originHeight=213&originWidth=502&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9464&status=done&style=none&taskId=u7ae45bf4-87e4-470e-8aeb-85b5f926073&title=\" alt=\"image.png\"><br>在示例中，页#6 使用了不到一半的空间，页#5 又有足够的删除数量，现在同样处于 50%使用以下。从 InnoDB 的角度来看，它们能够进行合并。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670821447-c45708d3-6252-4d1d-aa20-6f76b33a703c.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0d51d5a4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16067&status=done&style=none&taskId=u50d0dee4-a871-4afa-8b2f-f2faae78c20&title=\" alt=\"image.png\"><br>合并操作使得页#5 保留它之前的数据，并且容纳来自页#6 的数据。页#6 变成一个空页，可以接纳新数据。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670865660-41e697c1-0a3f-4e0d-950a-3163e180b401.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7c3c5848&margin=%5Bobject%20Object%5D&name=image.png&originHeight=218&originWidth=557&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=8559&status=done&style=none&taskId=uaf08e29c-dc2b-431a-9050-ccc0465860e&title=\" alt=\"image.png\"><br>如果我们在 UPDATE 操作中让页中数据体积达到类似的阈值点，InnoDB 也会进行一样的操作。<br>规则就是：页合并发生在删除或更新操作中，关联到当前页的相邻页。如果页合并成功，在 INFOMATION_SCHEMA.INNODB_METRICS 中的 index_page_merge_successful 将会增加。</p>\n<h2 id=\"页分裂\"><a href=\"#页分裂\" class=\"headerlink\" title=\"页分裂\"></a>页分裂</h2><p>前面提到，页可能填充至 100%，在页填满了之后，下一页会继续接管新的记录。但如果有下面这种情况呢？<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670893131-2f4e7133-29a8-4030-a8a7-ba6bab61fd4c.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7b78a3b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=21313&status=done&style=none&taskId=u249cd554-5170-4ecb-8c75-c8b71745f22&title=\" alt=\"image.png\"><br>页#10 没有足够空间去容纳新（或更新）的记录。根据“下一页”的逻辑，记录应该由页#11 负责。然而：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670967482-e1325a24-4460-4248-9e38-211e884901a6.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u768444b0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12917&status=done&style=none&taskId=u8743fa09-b41c-4ff7-8ae7-13ebc032feb&title=\" alt=\"image.png\"><br>页#11 也同样满了，数据也不可能不按顺序地插入。怎么办？<br>还记得之前说的链表吗（译注：指 B+树的每一层都是双向链表）？页#10 有指向页#9 和页#11 的指针。<br>InnoDB 的做法是（简化版）：</p>\n<ol>\n<li>创建新页</li>\n<li>判断当前页（页#10）可以从哪里进行分裂（记录行层面）</li>\n<li>移动记录行</li>\n<li>重新定义页之间的关系</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646671011269-44341865-977e-4047-9e20-5f699efa1c9b.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud9c1aeb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16401&status=done&style=none&taskId=uc5f805ab-046e-4249-97b7-2a3d4606c79&title=\" alt=\"image.png\"><br>新的页#12 被创建：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646671080650-1c3b1d9b-f12c-4358-a95d-38ae092933dc.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3f1c9d31&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=11563&status=done&style=none&taskId=u1d844c88-c5b3-4393-9c33-a97f5251b4b&title=\" alt=\"image.png\"><br>页#11 保持原样，只有页之间的关系发生了改变：</p>\n<ul>\n<li>页#10 相邻的前一页为页#9，后一页为页#12</li>\n<li>页#12 相邻的前一页为页#10，后一页为页#11</li>\n<li>页#11 相邻的前一页为页#10，后一页为页#13</li>\n</ul>\n<p>（译注：页#13 可能本来就有，这里意思为页#10 与页#11 之间插入了页#12）<br>这样 B 树水平方向的一致性仍然满足，因为满足原定的顺序排列逻辑。然而从物理存储上讲页是乱序的，而且大概率会落到不同的区。<br>规律总结：页分裂会发生在插入或更新，并且造成页的错位（dislocation，落入不同的区）<br>InnoDB 用 INFORMATION_SCHEMA.INNODB_METRICS 表来跟踪页的分裂数。可以查看其中的 index_page_splits 和 index_page_reorg_attempts&#x2F;successful 统计。<br>一旦创建分裂的页，唯一（译注：实则仍有其他方法，见下文）将原先顺序恢复的办法就是新分裂出来的页因为低于合并阈值（merge threshold）被删掉。这时候 InnoDB 用页合并将数据合并回来。<br>另一种方式就是用 OPTIMIZE 重新整理表。这可能是个很重量级和耗时的过程，但可能是唯一将大量分布在不同区的页理顺的方法。<br>另一方面，要记住在合并和分裂的过程，InnoDB 会在索引树上加写锁（x-latch）。在操作频繁的系统中这可能会是个隐患。它可能会导致索引的锁争用（index latch contention）。如果表中没有合并和分裂（也就是写操作）的操作，称为“乐观”更新，只需要使用读锁（S）。带有合并也分裂操作则称为“悲观”更新，使用写锁（X)。</p>\n<h2 id=\"我的主键\"><a href=\"#我的主键\" class=\"headerlink\" title=\"我的主键\"></a>我的主键</h2><p>好的主键不仅对于数据查找很重要，而且也影响写操作时数据在区上的分布（也就是与页分裂和页合并操作相关）。<br>在第一个测试中我使用的是是自增主键，第二个测试主键是基于一个 1-200 的 ID 与自增值的，第三个测试也是 1-200 的 ID 不过与 UUID 联合。<br>插入操作时，InnoDB 需要增加页，视为“分裂”操作：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646671241539-f683066e-2371-4731-a610-4bb5c0229b0d.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=ucb06f6a3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=467&originWidth=767&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=219981&status=done&style=none&taskId=u240fdc6a-e1ee-480d-8100-8db03084e59&title=&width=383.5\" alt=\"image.png\" width=\"383.5\"><br>表现因不同主键而异。<br>在头两种情况中数据的分布更为紧凑，也就是说他们拥有更好的空间利用率。对比半随机（semi-random）特性的 UUID 会导致明显的页稀疏分布（页数量更多，相关分裂操作更多）。<br>在页合并的情况中，尝试合并的次数因主键类型的不同而表现得更加不一致。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646671257790-eb064217-dffb-4a4b-9db6-fb09a09bd1d1.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u8f89039a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=1024&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=325826&status=done&style=none&taskId=u95d1fdea-dad3-481e-ab3b-0f338d66428&title=&width=512\" alt=\"image.png\" width=\"512\"><br>在插入-更新-删除操作中，自增主键有更少的合并尝试次数，成功比例比其他两种类型低 9.45%。UUID 型主键（图表的右一侧）有更多的合并尝试，但是合并成功率明显更高，达 22.34%，因为数据稀疏分布让很多页都有部分空闲空间。<br>在辅助索引与上面主键索引相似的情况下，测试的表现也是类似的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>MySQL&#x2F;InnoDB 不断地进行这些操作，你可能只能了解到很少的信息。但他们可能给你造成伤害，特别是比起用 SSD，你还在用传统的机械存储（spindle storage）的时候（顺便提一下 SSD 会有另外的问题）。<br>坏消息就是我们用什么参数或者魔法去改变服务端。但好消息是我们可以在设计的时候做很多（有帮助）的事。<br>恰当地使用主键和设计辅助索引，并且记住不要滥用（索引）。如果你已经预计到会有很多插入&#x2F;删除&#x2F;更新操作，规划一个合适的时间窗来管理（整理）表。<br>有个很重要的点，InnoDB 中你不会有断断续续的行记录，但是你会在页-区的维度上遇到这些问题。忽略表的管理工作会导致需要在 IO 层面、内存层面和 InnoDB 缓冲池层面做更多工作。<br>你必须不时（at regular intervals）重建一些表。可以采用一些技巧，比如分区和外部的工具（pt-osc）。不要让表变得过大和过于碎片化（fragmented）。<br>磁盘空间浪费？需要读多个表去获取需要的数据而不是一次搞定？每次搜索导致明显更多的读操作？那是你的锅，不要找借口！</p>\n","more":"<p>原文链接：<br><a href=\"https://www.percona.com/blog/2017/04/10/innodb-page-merging-and-page-splitting/\">https://www.percona.com/blog/2017/04/10/innodb-page-merging-and-page-splitting/</a><br><a href=\"https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/\">https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/</a></p>\n<p>如果您遇到了全球（为数不多的）MySQL 顾问之一并要求他&#x2F;她审查您的查询和&#x2F;或模式，我相信他&#x2F;她会告诉您有关良好主键设计的重要性的一些信息. 特别是在 InnoDB 的情况下，我相信他们已经开始向您解释索引合并和页面拆分。这两个概念与性能密切相关，您在设计任何索引（不仅仅是 PK）时都应该考虑这种关系。</p>\n<p>这对你来说可能听起来像笨蛋，你可能是对的。这不是一件容易的事情，尤其是在谈论内部结构时。这不是您经常处理的事情，而且通常您根本不想处理它。<br>但有时它是必需的。如果是这样，这篇文章适合你。</p>\n<p>在本文中，我想解释一些最不清楚的 InnoDB 幕后操作：页面索引创建、页面合并和页面拆分。<br>在 Innodb 中，所有数据都是一个索引。你可能也听说过吧？但这究竟是什么意思？</p>\n<h2 id=\"文件表组件\"><a href=\"#文件表组件\" class=\"headerlink\" title=\"文件表组件\"></a>文件表组件</h2><p>假设您安装了 MySQL，最新的 5.7 版本（<a href=\"https://www.percona.com/software/mysql-database/percona-server\">Percona Server for MySQL</a>，对吗？），并且在架构 windmills 中有一个名为 wmills 的表。在数据目录（通常为 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;）中，您将看到它包含：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">data&#x2F;\n  windmills&#x2F;\n      wmills.ibd\n      wmills.frm</code></pre>\n\n<p>这是因为参数 innodb_file_per_table 从 MySQL5.6 开始已经设置为 1。这样设置，schema 中每个表都是一个文件（如果是分区表，则有多个文件）。<br>这里重要的是名为 wmills.ibd 的文件。这个文件被分为 N 个段(Segment) 。每个段 都与一个索引相关联。<br>尽管文件不会因删除数据而收缩，段本身会增长或收缩，下一级为区。一个区仅存在一个段中，并且固定尺寸为 1MB（在默认页大小的情况下）。页(page)是区(extent)的下一级，默认大小为 16KB。<br>因此，一个区(extent)最多可包含 64 页(page)。一个页可以包含 2 到 N 行。一个页可以容纳的行数与行大小有关，这是表结构设计时定义的。InnoDB 中有一条规则说，至少两行必须适合一个页面。因此，我们有 8000 字节的行大小限制。如果您认为这听起来就像俄罗斯娃娃（Matryoshka dolls），没错下面这张图能帮助你理解：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646668915534-ed853d29-e5d1-483a-96f5-c493531c15a0.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=727&id=uc6d38939&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1453&originWidth=1024&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=215070&status=done&style=none&taskId=u307ec0b7-5103-4ca1-ac09-04cec335d3e&title=&width=512\" alt=\"image.png\" width=\"512\"></p>\n<h2 id=\"根，分支与叶子\"><a href=\"#根，分支与叶子\" class=\"headerlink\" title=\"根，分支与叶子\"></a>根，分支与叶子</h2><p>每个页（逻辑上讲即叶子节点）是包含了 2-N 行数据，根据主键排列。树有着特殊的页区管理不同的分支，即内部节点（INodes）。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646669878783-8795eebb-61d5-4169-ba9c-09589a032e23.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=uc383ca06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=1024&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=88704&status=done&style=none&taskId=uffc6a5d3-ae8e-4734-bdd9-7963bbcbf20&title=&width=512\" alt=\"image.png\" width=\"512\"><br>这个图片仅是示例，并不能说明下面的实际输出。<br>具体来看一下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ROOT NODE #3: 4 records, 68 bytes\nNODE POINTER RECORD ≥ (id&#x3D;2) → #197\nINTERNAL NODE #197: 464 records, 7888 bytes\nNODE POINTER RECORD ≥ (id&#x3D;2) → #5\nLEAF NODE #5: 57 records, 7524 bytes\n RECORD: (id&#x3D;2) → (uuid&#x3D;&quot;884e471c-0e82-11e7-8bf6-08002734ed50&quot;, millid&#x3D;139, kwatts_s&#x3D;1956, date&#x3D;&quot;2017-05-01&quot;, location&#x3D;&quot;For beauty&#39;s pattern to succeeding men.Yet do thy&quot;, active&#x3D;1, time&#x3D;&quot;2017-03-21 22:05:45&quot;, strrecordtype&#x3D;&quot;Wit&quot;)</code></pre>\n\n<p>下面是表结构：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;wmills&#96; (\n  &#96;id&#96; bigint(11) NOT NULL AUTO_INCREMENT,\n  &#96;uuid&#96; char(36) COLLATE utf8_bin NOT NULL,\n  &#96;millid&#96; smallint(6) NOT NULL,\n  &#96;kwatts_s&#96; int(11) NOT NULL,\n  &#96;date&#96; date NOT NULL,\n  &#96;location&#96; varchar(50) COLLATE utf8_bin DEFAULT NULL,\n  &#96;active&#96; tinyint(2) NOT NULL DEFAULT &#39;1&#39;,\n  &#96;time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  &#96;strrecordtype&#96; char(3) COLLATE utf8_bin NOT NULL,\n  PRIMARY KEY (&#96;id&#96;),\n  KEY &#96;IDX_millid&#96; (&#96;millid&#96;)\n) ENGINE&#x3D;InnoDB;</code></pre>\n\n<p>所有的 B 树都有着一个入口，也就是根节点，在上图中#3 就是根节点。根节点（页）包含了如索引 ID、INodes 数量等信息。INode 页包含了关于页本身的信息、值的范围等。最后还有叶子节点，也就是我们数据实际所在的位置。在示例中，我们可以看到叶子节点#5 有 57 行记录，共 7524 bytes。在这行信息后是具体的记录，可以看到数据行内容。<br>这里想引出的概念是当你使用 InnoDB 管理表和行，InnoDB 会将他们会以分支、页和记录的形式组织起来。InnoDB 不是按行的来操作的，它可操作的最小粒度是页，页加载进内存后才会通过扫描页来获取行&#x2F;记录。<br>现在页的结构清楚了吗？好，我们继续。</p>\n<h2 id=\"页的内部原理\"><a href=\"#页的内部原理\" class=\"headerlink\" title=\"页的内部原理\"></a>页的内部原理</h2><p>页可以空或者填充满（100%），行记录会按照主键顺序来排列。例如在使用 AUTO_INCREMENT 时，你会有顺序的 ID 1、2、3、4 等。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670330112-d3a07653-9aed-40c1-aa43-e390bcdb252f.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9b61c215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=203&originWidth=502&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9573&status=done&style=none&taskId=u20366bda-86f8-4ea6-a3a7-4f458028d7e&title=\" alt=\"image.png\"><br>页还有另一个重要的属性：<strong>MERGE_THRESHOLD</strong>。该参数的默认值是 50%页的大小，它在 InnoDB 的合并操作中扮演了很重要的角色。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670575250-0189aa82-3b1f-449f-b5d7-7fff7b68f559.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucbf5a575&margin=%5Bobject%20Object%5D&name=image.png&originHeight=205&originWidth=538&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=11879&status=done&style=none&taskId=ufdb2bd63-8d94-4fa0-a4e6-f135015a4ac&title=\" alt=\"image.png\"><br>当你插入数据时，如果数据（大小）能够放的进页中的话，那他们是按顺序将页填满的。<br>若当前页满，则下一行记录会被插入下一页（NEXT）中。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670627767-5435a231-c2ac-44fb-b12f-f9ebedfec97c.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u85e37165&margin=%5Bobject%20Object%5D&name=image.png&originHeight=213&originWidth=502&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9464&status=done&style=none&taskId=u38f7fbf9-f3cd-40ad-9046-033c82813c1&title=\" alt=\"image.png\"><br>根据 B 树的特性，它可以自顶向下遍历，但也可以在各叶子节点水平遍历。因为每个叶子节点都有着一个指向包含下一条（顺序）记录的页的指针。例如，页#5 有指向页#6 的指针，页#6 有指向前一页（#5）的指针和后一页（#7）的指针。<br>这种机制下可以做到快速的顺序扫描（如范围扫描）。之前提到过，这就是当你基于自增主键进行插入的情况。但如果你不仅插入还进行删除呢？</p>\n<h2 id=\"页合并\"><a href=\"#页合并\" class=\"headerlink\" title=\"页合并\"></a>页合并</h2><p>当你删了一行记录时，实际上记录并没有被物理删除，记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670744381-096c5efd-35a7-4db2-aec0-f0fcb64d2f3a.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uab3ccebe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=262&originWidth=538&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16177&status=done&style=none&taskId=u61879170-9951-4647-8550-140ace92b8a&title=\" alt=\"image.png\"><br>当页中删除的记录达到 MERGE_THRESHOLD（默认页体积的 50%），InnoDB 会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670788088-7e174566-bd14-4f60-8f89-44560bb5c82c.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udfa9e513&margin=%5Bobject%20Object%5D&name=image.png&originHeight=213&originWidth=502&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9464&status=done&style=none&taskId=u7ae45bf4-87e4-470e-8aeb-85b5f926073&title=\" alt=\"image.png\"><br>在示例中，页#6 使用了不到一半的空间，页#5 又有足够的删除数量，现在同样处于 50%使用以下。从 InnoDB 的角度来看，它们能够进行合并。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670821447-c45708d3-6252-4d1d-aa20-6f76b33a703c.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u0d51d5a4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16067&status=done&style=none&taskId=u50d0dee4-a871-4afa-8b2f-f2faae78c20&title=\" alt=\"image.png\"><br>合并操作使得页#5 保留它之前的数据，并且容纳来自页#6 的数据。页#6 变成一个空页，可以接纳新数据。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670865660-41e697c1-0a3f-4e0d-950a-3163e180b401.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7c3c5848&margin=%5Bobject%20Object%5D&name=image.png&originHeight=218&originWidth=557&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=8559&status=done&style=none&taskId=uaf08e29c-dc2b-431a-9050-ccc0465860e&title=\" alt=\"image.png\"><br>如果我们在 UPDATE 操作中让页中数据体积达到类似的阈值点，InnoDB 也会进行一样的操作。<br>规则就是：页合并发生在删除或更新操作中，关联到当前页的相邻页。如果页合并成功，在 INFOMATION_SCHEMA.INNODB_METRICS 中的 index_page_merge_successful 将会增加。</p>\n<h2 id=\"页分裂\"><a href=\"#页分裂\" class=\"headerlink\" title=\"页分裂\"></a>页分裂</h2><p>前面提到，页可能填充至 100%，在页填满了之后，下一页会继续接管新的记录。但如果有下面这种情况呢？<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670893131-2f4e7133-29a8-4030-a8a7-ba6bab61fd4c.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7b78a3b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=21313&status=done&style=none&taskId=u249cd554-5170-4ecb-8c75-c8b71745f22&title=\" alt=\"image.png\"><br>页#10 没有足够空间去容纳新（或更新）的记录。根据“下一页”的逻辑，记录应该由页#11 负责。然而：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646670967482-e1325a24-4460-4248-9e38-211e884901a6.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u768444b0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12917&status=done&style=none&taskId=u8743fa09-b41c-4ff7-8ae7-13ebc032feb&title=\" alt=\"image.png\"><br>页#11 也同样满了，数据也不可能不按顺序地插入。怎么办？<br>还记得之前说的链表吗（译注：指 B+树的每一层都是双向链表）？页#10 有指向页#9 和页#11 的指针。<br>InnoDB 的做法是（简化版）：</p>\n<ol>\n<li>创建新页</li>\n<li>判断当前页（页#10）可以从哪里进行分裂（记录行层面）</li>\n<li>移动记录行</li>\n<li>重新定义页之间的关系</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646671011269-44341865-977e-4047-9e20-5f699efa1c9b.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud9c1aeb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16401&status=done&style=none&taskId=uc5f805ab-046e-4249-97b7-2a3d4606c79&title=\" alt=\"image.png\"><br>新的页#12 被创建：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646671080650-1c3b1d9b-f12c-4358-a95d-38ae092933dc.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3f1c9d31&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=537&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=11563&status=done&style=none&taskId=u1d844c88-c5b3-4393-9c33-a97f5251b4b&title=\" alt=\"image.png\"><br>页#11 保持原样，只有页之间的关系发生了改变：</p>\n<ul>\n<li>页#10 相邻的前一页为页#9，后一页为页#12</li>\n<li>页#12 相邻的前一页为页#10，后一页为页#11</li>\n<li>页#11 相邻的前一页为页#10，后一页为页#13</li>\n</ul>\n<p>（译注：页#13 可能本来就有，这里意思为页#10 与页#11 之间插入了页#12）<br>这样 B 树水平方向的一致性仍然满足，因为满足原定的顺序排列逻辑。然而从物理存储上讲页是乱序的，而且大概率会落到不同的区。<br>规律总结：页分裂会发生在插入或更新，并且造成页的错位（dislocation，落入不同的区）<br>InnoDB 用 INFORMATION_SCHEMA.INNODB_METRICS 表来跟踪页的分裂数。可以查看其中的 index_page_splits 和 index_page_reorg_attempts&#x2F;successful 统计。<br>一旦创建分裂的页，唯一（译注：实则仍有其他方法，见下文）将原先顺序恢复的办法就是新分裂出来的页因为低于合并阈值（merge threshold）被删掉。这时候 InnoDB 用页合并将数据合并回来。<br>另一种方式就是用 OPTIMIZE 重新整理表。这可能是个很重量级和耗时的过程，但可能是唯一将大量分布在不同区的页理顺的方法。<br>另一方面，要记住在合并和分裂的过程，InnoDB 会在索引树上加写锁（x-latch）。在操作频繁的系统中这可能会是个隐患。它可能会导致索引的锁争用（index latch contention）。如果表中没有合并和分裂（也就是写操作）的操作，称为“乐观”更新，只需要使用读锁（S）。带有合并也分裂操作则称为“悲观”更新，使用写锁（X)。</p>\n<h2 id=\"我的主键\"><a href=\"#我的主键\" class=\"headerlink\" title=\"我的主键\"></a>我的主键</h2><p>好的主键不仅对于数据查找很重要，而且也影响写操作时数据在区上的分布（也就是与页分裂和页合并操作相关）。<br>在第一个测试中我使用的是是自增主键，第二个测试主键是基于一个 1-200 的 ID 与自增值的，第三个测试也是 1-200 的 ID 不过与 UUID 联合。<br>插入操作时，InnoDB 需要增加页，视为“分裂”操作：<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646671241539-f683066e-2371-4731-a610-4bb5c0229b0d.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=ucb06f6a3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=467&originWidth=767&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=219981&status=done&style=none&taskId=u240fdc6a-e1ee-480d-8100-8db03084e59&title=&width=383.5\" alt=\"image.png\" width=\"383.5\"><br>表现因不同主键而异。<br>在头两种情况中数据的分布更为紧凑，也就是说他们拥有更好的空间利用率。对比半随机（semi-random）特性的 UUID 会导致明显的页稀疏分布（页数量更多，相关分裂操作更多）。<br>在页合并的情况中，尝试合并的次数因主键类型的不同而表现得更加不一致。<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1646671257790-eb064217-dffb-4a4b-9db6-fb09a09bd1d1.png#clientId=u8b15385f-1173-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u8f89039a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=1024&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=325826&status=done&style=none&taskId=u95d1fdea-dad3-481e-ab3b-0f338d66428&title=&width=512\" alt=\"image.png\" width=\"512\"><br>在插入-更新-删除操作中，自增主键有更少的合并尝试次数，成功比例比其他两种类型低 9.45%。UUID 型主键（图表的右一侧）有更多的合并尝试，但是合并成功率明显更高，达 22.34%，因为数据稀疏分布让很多页都有部分空闲空间。<br>在辅助索引与上面主键索引相似的情况下，测试的表现也是类似的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>MySQL&#x2F;InnoDB 不断地进行这些操作，你可能只能了解到很少的信息。但他们可能给你造成伤害，特别是比起用 SSD，你还在用传统的机械存储（spindle storage）的时候（顺便提一下 SSD 会有另外的问题）。<br>坏消息就是我们用什么参数或者魔法去改变服务端。但好消息是我们可以在设计的时候做很多（有帮助）的事。<br>恰当地使用主键和设计辅助索引，并且记住不要滥用（索引）。如果你已经预计到会有很多插入&#x2F;删除&#x2F;更新操作，规划一个合适的时间窗来管理（整理）表。<br>有个很重要的点，InnoDB 中你不会有断断续续的行记录，但是你会在页-区的维度上遇到这些问题。忽略表的管理工作会导致需要在 IO 层面、内存层面和 InnoDB 缓冲池层面做更多工作。<br>你必须不时（at regular intervals）重建一些表。可以采用一些技巧，比如分区和外部的工具（pt-osc）。不要让表变得过大和过于碎片化（fragmented）。<br>磁盘空间浪费？需要读多个表去获取需要的数据而不是一次搞定？每次搜索导致明显更多的读操作？那是你的锅，不要找借口！</p>\n","categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]}