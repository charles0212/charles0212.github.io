{"title":"MySQL表碎片","slug":"yuque/MySQL表碎片","date":"2019-05-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.496Z","comments":true,"path":"api/articles/mysql/mysql-table-fragmentation.json","excerpt":"> 原文链接：> https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/当心批量插入失败或者回滚时带来的MySQL 表碎片，通常，DBA都了解使用 DELETE语句会产生表碎片。在大多数情况下，当执行大量的删除时，DBA总会重新构建表以回收磁盘空间。但是，您是否认为只有删除才会导致表碎片？（答案：并不是）。在这篇博文中，我将解释插入如何会带来碎片。在讨论这个主题之前，我们需要了解MySQL，有两种碎片：","covers":["/images/c3.jpg"],"content":"<blockquote>\n<p>原文链接：<br><a href=\"https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/\">https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/</a></p>\n</blockquote>\n<p><strong>当心批量插入失败或者回滚时带来的 MySQL 表碎片</strong>，通常，DBA 都了解使用 DELETE 语句会产生表碎片。在大多数情况下，当执行大量的删除时，DBA 总会重新构建表以回收磁盘空间。但是，您是否认为只有删除才会导致表碎片？（答案：并不是）。<br>在这篇博文中，我将解释插入如何会带来碎片。</p>\n<p>在讨论这个主题之前，我们需要了解 MySQL，有两种碎片：</p>\n<ul>\n<li>在表中的 InnoDB 页完全空闲引起的碎片。</li>\n<li>InnoDB 页未填充满（页中还有一些空闲空间）引起的碎片。</li>\n</ul>\n<p>主要有三种由插入引起的碎片场景：</p>\n<ul>\n<li>插入，然后回滚</li>\n<li>插入语句失败</li>\n<li>页分裂引起的碎片</li>\n</ul>\n<h2 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h2><p>我创建了自己的测试环境来测试这些案例。</p>\n<ul>\n<li>DB：Percona 版分支</li>\n<li>Table：frag，ins_frag，frag_page_spl</li>\n<li>表大小：2G</li>\n</ul>\n<h2 id=\"场景-1：插入后回滚\"><a href=\"#场景-1：插入后回滚\" class=\"headerlink\" title=\"场景 1：插入后回滚\"></a>场景 1：插入后回滚</h2><p>首先，我创建了一个新表”ins_flag”。然后我开启一个事务（使用 BEGIN）,如下所示开始拷贝”frag”表中数据到”ins_flag”中。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; create table ins_frag like frag;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into ins_frag select * from frag;\nQuery OK, 47521280 rows affected (3 min 7.45 sec)\nRecords: 47521280  Duplicates: 0  Warnings: 0\n\n#Linux shell\nsakthi-3.2# ls -lrth\ntotal 8261632\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 03:00 ins_frag.ibd</code></pre>\n\n<p>如上所示，您可以看到已经执行了插入，但是我还没有提交或者回滚插入操作。您注意到 2 张表都已经占用 2G 磁盘空间。</p>\n<p>现在我将回滚插入操作。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; select count(*) from ins_frag;\n+----------+\n| count(*) |\n+----------+\n| 47521280 |\n+----------+\n1 row in set (1.87 sec)\n\nmysql&gt; rollback;\nQuery OK, 0 rows affected (5 min 45.21 sec)\n\nmysql&gt; select count(*) from ins_frag;\n+----------+\n| count(*) |\n+----------+\n|        0 |\n+----------+\n1 row in set (0.00 sec)\n\n\n#Linux shell\nsakthi-3.2# ls -lrth\ntotal 8261632\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 03:09 ins_frag.ibd</code></pre>\n\n<p>当插入回滚后，”ins_frag”表仍然占有相同的 2GB 的磁盘空间。让我们在 MySQL 客户端看看碎片空间。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; SELECT\n-&gt; table_schema as &#39;DATABASE&#39;,\n-&gt; table_name as &#39;TABLE&#39;,\n-&gt; CONCAT(ROUND(( data_length + index_length ) &#x2F; ( 1024 * 1024 * 1024 ), 2), &#39;G&#39;) &#39;TOTAL&#39;,\n-&gt; CONCAT(ROUND(data_free &#x2F; ( 1024 * 1024 * 1024 ), 2), &#39;G&#39;) &#39;DATAFREE&#39;\n-&gt; FROM information_schema.TABLES\n-&gt; where table_schema&#x3D;&#39;percona&#39; and table_name&#x3D;&#39;ins_frag&#39;;\n+----------+----------+-------+----------+\n| DATABASE | TABLE.   | TOTAL | DATAFREE |\n+----------+----------+-------+----------+\n| percona  | ins_frag | 0.00G | 1.96G    |\n+----------+----------+-------+----------+\n1 row in set (0.01 sec)</code></pre>\n\n<p>这清楚的显示了插入之后回滚会产生碎片。我们需要重建表来回收磁盘空间。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; alter table ins_frag engine&#x3D;innodb;\nQuery OK, 0 rows affected (2.63 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#Linux shell\n\nsakthi-3.2# ls -lrth\ntotal 4131040\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   112K Jun 17 03:11 ins_frag.ibd</code></pre>\n\n<h2 id=\"场景-2-插入语句失败\"><a href=\"#场景-2-插入语句失败\" class=\"headerlink\" title=\"场景 2: 插入语句失败\"></a>场景 2: 插入语句失败</h2><p>在会话 1 中，我将在事务中执行相同的插入语句。但是这次我会在会话 2 中中断并杀掉这个插入语句。<br><strong>会话 1</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">#Linux shell\n\nsakthi-3.2# ls -lrth\ntotal 4131040\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   112K Jun 17 04:02 ins_frag.ibd\n\n#MySQL shell\n\nmysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into ins_frag select * from frag;   #is running</code></pre>\n\n<p><strong>会话 2</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; pager grep -i insert ; show processlist;\nPAGER set to &#39;grep -i insert&#39;\n| 33 | root            | localhost | percona | Query   |    14 | executing              | insert into ins_frag select * from frag |\n4 rows in set (0.00 sec)\n\nmysql&gt; kill 33;\nQuery OK, 0 rows affected (0.00 sec)</code></pre>\n\n<p>插入中断并失败了。<strong>在会话 1 查看：</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; insert into ins_frag select * from frag;\nERROR 2013 (HY000): Lost connection to MySQL server during query\n\n#Linux shell\n\nsakthi-3.2# ls -lrth\ntotal 4591616\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   212M Jun 17 04:21 ins_frag.ibd\n\n#MySQL shell\n\nmysql&gt; select count(*) from ins_frag;\n+----------+\n| count(*) |\n+----------+\n|        0 |\n+----------+\n1 row in set (0.10 sec)</code></pre>\n\n<p>插入并未完成，表中无数据。但是仍然，这个表的 ibd 文件已经涨到 212M。通过 MySQL 客户端查看表空间碎片。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; SELECT\n-&gt; table_schema as &#39;DATABASE&#39;,\n-&gt; table_name as &#39;TABLE&#39;,\n-&gt; CONCAT(ROUND(( data_length + index_length ) &#x2F; ( 1024 * 1024 ), 2), &#39;M&#39;) &#39;TOTAL&#39;,\n-&gt; CONCAT(ROUND(data_free &#x2F; ( 1024 * 1024 ), 2), &#39;M&#39;) &#39;DATAFREE&#39;\n-&gt; FROM information_schema.TABLES\n-&gt; where table_schema&#x3D;&#39;percona&#39; and table_name&#x3D;&#39;ins_frag&#39;;\n+----------+----------+---------+----------+\n| DATABASE | TABLE    | TOTAL   | DATAFREE |\n+----------+----------+---------+----------+\n| percona  | ins_frag | 0.03M   | 210.56M  |\n+----------+----------+---------+----------+\n1 row in set (0.01 sec)</code></pre>\n\n<p>表中有碎片，需要重建表回收这些空间。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; alter table ins_frag engine&#x3D;&#39;innodb&#39;;\nQuery OK, 0 rows affected (0.03 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#Linux shell\n\nsakthi-3.2# ls -lrth\ntotal 4131040\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   112K Jun 17 04:32 ins_frag.ibd</code></pre>\n\n<h2 id=\"场景-3-页分裂引起的碎片\"><a href=\"#场景-3-页分裂引起的碎片\" class=\"headerlink\" title=\"场景 3: 页分裂引起的碎片\"></a>场景 3: 页分裂引起的碎片</h2><p>我们知道，InnoDB 记录存储在 InnoDB 页中。默认情况下，每个页大小是 16K，但是您可以选择更改页大小。</p>\n<p>如果 InnoDB 页没有足够的空间容纳新的记录或索引条目，它将被分成 2 页，每页约占 50%。这意味着，即使对表只有插入，没有回滚和删除，最终也可能只有平均 75%的页利用率——因此这种页内部损失为 25%。</p>\n<p>当按排序建立索引，它们会有更多的拥塞，如果表很多插入到索引中随机位置，就会导致页分裂。</p>\n<p>参阅 Marco Tusa 写的博客 InnoDB Page Merging and Page Splitting，详细介绍了页分裂和 InnoDB 页结构&#x2F;操作。</p>\n<p>为了实验，我创建了一个具有排序索引的表（降序）</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; show create table frag_page_splG\n*************************** 1. row ***************************\nTable: frag_page_spl\nCreate Table: CREATE TABLE &#96;frag_page_spl&#96; (\n&#96;id&#96; int NOT NULL AUTO_INCREMENT,\n&#96;name&#96; varchar(16) DEFAULT NULL,\n&#96;messages&#96; varchar(600) DEFAULT NULL,\nPRIMARY KEY (&#96;id&#96;),\nKEY &#96;idx_spl&#96; (&#96;messages&#96; DESC)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci\n1 row in set (0.07 sec)</code></pre>\n\n<p>我们可以通过表 INFORMATION_SCHEMA.INNODB_METRICS 监控页分裂情况。对此，您需要启用 InnoDB monitor。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; SET GLOBAL innodb_monitor_enable&#x3D;all;\nQuery OK, 0 rows affected (0.09 sec)</code></pre>\n\n<p>我写了一个 6 个并发随机插入的脚本。脚本执行结束后：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; select name,count,type,status,comment from information_schema.innodb_metrics where name like &#39;%index_page_spl%&#39;G\n*************************** 1. row ***************************\nname: index_page_splits\ncount: 52186\ntype: counter\nstatus: enabled\ncomment: Number of index page splits\n1 row in set (0.05 sec)\n\nmysql&gt; SELECT\n-&gt; table_schema as &#39;DATABASE&#39;,\n-&gt; table_name as &#39;TABLE&#39;,\n-&gt; CONCAT(ROUND(( data_length + index_length ) &#x2F; ( 1024 * 1024 ), 2), &#39;M&#39;) &#39;TOTAL&#39;,\n-&gt; CONCAT(ROUND(data_free &#x2F; ( 1024 * 1024 ), 2), &#39;M&#39;) &#39;DATAFREE&#39;\n-&gt; FROM information_schema.TABLES\n-&gt; where table_schema&#x3D;&#39;percona&#39; and table_name&#x3D;&#39;frag_page_spl&#39;;\n+----------+---------------+----------+----------+\n| DATABASE | TABLE.        | TOTAL    | DATAFREE |\n+----------+---------------+----------+----------+\n| percona  | frag_page_spl | 2667.55M | 127.92M  |\n+----------+---------------+----------+----------+\n1 row in set (0.00 sec)</code></pre>\n\n<p>从指标上看，我们看到页分裂次数在增加。输出显示有 52186 次页分裂，产生了 127.92MB 的碎片。<br>一旦发生页分裂，唯一的方法是将创建的页降至合并阈值之下。当这种情况发生时，InnoDB 通过合并操作将数据从分裂的页中移出。对表和特定的索引合并阈值是可配置的。<br>另一种重新组织数据的方法是 OPTIMIZE TABLE。这是一个非常重和漫长的过程，但通常这是解决过多页比较稀疏的唯一方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>前面两种情况很少见。因为大多数应用程序都不会设计在表中写入大量数据。</li>\n<li>在执行批量插入时（INSERT INTO SELECT * FROM, 加载 mysqldump 的数据, INSERT with huge data 等）需要注意这些问题。</li>\n<li>碎片占用的磁盘空间始终是可重用的。</li>\n</ul>\n","more":"<blockquote>\n<p>原文链接：<br><a href=\"https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/\">https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/</a></p>\n</blockquote>\n<p><strong>当心批量插入失败或者回滚时带来的 MySQL 表碎片</strong>，通常，DBA 都了解使用 DELETE 语句会产生表碎片。在大多数情况下，当执行大量的删除时，DBA 总会重新构建表以回收磁盘空间。但是，您是否认为只有删除才会导致表碎片？（答案：并不是）。<br>在这篇博文中，我将解释插入如何会带来碎片。</p>\n<p>在讨论这个主题之前，我们需要了解 MySQL，有两种碎片：</p>\n<ul>\n<li>在表中的 InnoDB 页完全空闲引起的碎片。</li>\n<li>InnoDB 页未填充满（页中还有一些空闲空间）引起的碎片。</li>\n</ul>\n<p>主要有三种由插入引起的碎片场景：</p>\n<ul>\n<li>插入，然后回滚</li>\n<li>插入语句失败</li>\n<li>页分裂引起的碎片</li>\n</ul>\n<h2 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h2><p>我创建了自己的测试环境来测试这些案例。</p>\n<ul>\n<li>DB：Percona 版分支</li>\n<li>Table：frag，ins_frag，frag_page_spl</li>\n<li>表大小：2G</li>\n</ul>\n<h2 id=\"场景-1：插入后回滚\"><a href=\"#场景-1：插入后回滚\" class=\"headerlink\" title=\"场景 1：插入后回滚\"></a>场景 1：插入后回滚</h2><p>首先，我创建了一个新表”ins_flag”。然后我开启一个事务（使用 BEGIN）,如下所示开始拷贝”frag”表中数据到”ins_flag”中。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; create table ins_frag like frag;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into ins_frag select * from frag;\nQuery OK, 47521280 rows affected (3 min 7.45 sec)\nRecords: 47521280  Duplicates: 0  Warnings: 0\n\n#Linux shell\nsakthi-3.2# ls -lrth\ntotal 8261632\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 03:00 ins_frag.ibd</code></pre>\n\n<p>如上所示，您可以看到已经执行了插入，但是我还没有提交或者回滚插入操作。您注意到 2 张表都已经占用 2G 磁盘空间。</p>\n<p>现在我将回滚插入操作。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; select count(*) from ins_frag;\n+----------+\n| count(*) |\n+----------+\n| 47521280 |\n+----------+\n1 row in set (1.87 sec)\n\nmysql&gt; rollback;\nQuery OK, 0 rows affected (5 min 45.21 sec)\n\nmysql&gt; select count(*) from ins_frag;\n+----------+\n| count(*) |\n+----------+\n|        0 |\n+----------+\n1 row in set (0.00 sec)\n\n\n#Linux shell\nsakthi-3.2# ls -lrth\ntotal 8261632\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 03:09 ins_frag.ibd</code></pre>\n\n<p>当插入回滚后，”ins_frag”表仍然占有相同的 2GB 的磁盘空间。让我们在 MySQL 客户端看看碎片空间。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; SELECT\n-&gt; table_schema as &#39;DATABASE&#39;,\n-&gt; table_name as &#39;TABLE&#39;,\n-&gt; CONCAT(ROUND(( data_length + index_length ) &#x2F; ( 1024 * 1024 * 1024 ), 2), &#39;G&#39;) &#39;TOTAL&#39;,\n-&gt; CONCAT(ROUND(data_free &#x2F; ( 1024 * 1024 * 1024 ), 2), &#39;G&#39;) &#39;DATAFREE&#39;\n-&gt; FROM information_schema.TABLES\n-&gt; where table_schema&#x3D;&#39;percona&#39; and table_name&#x3D;&#39;ins_frag&#39;;\n+----------+----------+-------+----------+\n| DATABASE | TABLE.   | TOTAL | DATAFREE |\n+----------+----------+-------+----------+\n| percona  | ins_frag | 0.00G | 1.96G    |\n+----------+----------+-------+----------+\n1 row in set (0.01 sec)</code></pre>\n\n<p>这清楚的显示了插入之后回滚会产生碎片。我们需要重建表来回收磁盘空间。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; alter table ins_frag engine&#x3D;innodb;\nQuery OK, 0 rows affected (2.63 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#Linux shell\n\nsakthi-3.2# ls -lrth\ntotal 4131040\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   112K Jun 17 03:11 ins_frag.ibd</code></pre>\n\n<h2 id=\"场景-2-插入语句失败\"><a href=\"#场景-2-插入语句失败\" class=\"headerlink\" title=\"场景 2: 插入语句失败\"></a>场景 2: 插入语句失败</h2><p>在会话 1 中，我将在事务中执行相同的插入语句。但是这次我会在会话 2 中中断并杀掉这个插入语句。<br><strong>会话 1</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">#Linux shell\n\nsakthi-3.2# ls -lrth\ntotal 4131040\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   112K Jun 17 04:02 ins_frag.ibd\n\n#MySQL shell\n\nmysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into ins_frag select * from frag;   #is running</code></pre>\n\n<p><strong>会话 2</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; pager grep -i insert ; show processlist;\nPAGER set to &#39;grep -i insert&#39;\n| 33 | root            | localhost | percona | Query   |    14 | executing              | insert into ins_frag select * from frag |\n4 rows in set (0.00 sec)\n\nmysql&gt; kill 33;\nQuery OK, 0 rows affected (0.00 sec)</code></pre>\n\n<p>插入中断并失败了。<strong>在会话 1 查看：</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; insert into ins_frag select * from frag;\nERROR 2013 (HY000): Lost connection to MySQL server during query\n\n#Linux shell\n\nsakthi-3.2# ls -lrth\ntotal 4591616\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   212M Jun 17 04:21 ins_frag.ibd\n\n#MySQL shell\n\nmysql&gt; select count(*) from ins_frag;\n+----------+\n| count(*) |\n+----------+\n|        0 |\n+----------+\n1 row in set (0.10 sec)</code></pre>\n\n<p>插入并未完成，表中无数据。但是仍然，这个表的 ibd 文件已经涨到 212M。通过 MySQL 客户端查看表空间碎片。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; SELECT\n-&gt; table_schema as &#39;DATABASE&#39;,\n-&gt; table_name as &#39;TABLE&#39;,\n-&gt; CONCAT(ROUND(( data_length + index_length ) &#x2F; ( 1024 * 1024 ), 2), &#39;M&#39;) &#39;TOTAL&#39;,\n-&gt; CONCAT(ROUND(data_free &#x2F; ( 1024 * 1024 ), 2), &#39;M&#39;) &#39;DATAFREE&#39;\n-&gt; FROM information_schema.TABLES\n-&gt; where table_schema&#x3D;&#39;percona&#39; and table_name&#x3D;&#39;ins_frag&#39;;\n+----------+----------+---------+----------+\n| DATABASE | TABLE    | TOTAL   | DATAFREE |\n+----------+----------+---------+----------+\n| percona  | ins_frag | 0.03M   | 210.56M  |\n+----------+----------+---------+----------+\n1 row in set (0.01 sec)</code></pre>\n\n<p>表中有碎片，需要重建表回收这些空间。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; alter table ins_frag engine&#x3D;&#39;innodb&#39;;\nQuery OK, 0 rows affected (0.03 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\n#Linux shell\n\nsakthi-3.2# ls -lrth\ntotal 4131040\n-rw-r-----  1 _mysql  _mysql   2.0G Jun 17 02:43 frag.ibd\n-rw-r-----  1 _mysql  _mysql   112K Jun 17 04:32 ins_frag.ibd</code></pre>\n\n<h2 id=\"场景-3-页分裂引起的碎片\"><a href=\"#场景-3-页分裂引起的碎片\" class=\"headerlink\" title=\"场景 3: 页分裂引起的碎片\"></a>场景 3: 页分裂引起的碎片</h2><p>我们知道，InnoDB 记录存储在 InnoDB 页中。默认情况下，每个页大小是 16K，但是您可以选择更改页大小。</p>\n<p>如果 InnoDB 页没有足够的空间容纳新的记录或索引条目，它将被分成 2 页，每页约占 50%。这意味着，即使对表只有插入，没有回滚和删除，最终也可能只有平均 75%的页利用率——因此这种页内部损失为 25%。</p>\n<p>当按排序建立索引，它们会有更多的拥塞，如果表很多插入到索引中随机位置，就会导致页分裂。</p>\n<p>参阅 Marco Tusa 写的博客 InnoDB Page Merging and Page Splitting，详细介绍了页分裂和 InnoDB 页结构&#x2F;操作。</p>\n<p>为了实验，我创建了一个具有排序索引的表（降序）</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; show create table frag_page_splG\n*************************** 1. row ***************************\nTable: frag_page_spl\nCreate Table: CREATE TABLE &#96;frag_page_spl&#96; (\n&#96;id&#96; int NOT NULL AUTO_INCREMENT,\n&#96;name&#96; varchar(16) DEFAULT NULL,\n&#96;messages&#96; varchar(600) DEFAULT NULL,\nPRIMARY KEY (&#96;id&#96;),\nKEY &#96;idx_spl&#96; (&#96;messages&#96; DESC)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COLLATE&#x3D;utf8mb4_0900_ai_ci\n1 row in set (0.07 sec)</code></pre>\n\n<p>我们可以通过表 INFORMATION_SCHEMA.INNODB_METRICS 监控页分裂情况。对此，您需要启用 InnoDB monitor。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; SET GLOBAL innodb_monitor_enable&#x3D;all;\nQuery OK, 0 rows affected (0.09 sec)</code></pre>\n\n<p>我写了一个 6 个并发随机插入的脚本。脚本执行结束后：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; select name,count,type,status,comment from information_schema.innodb_metrics where name like &#39;%index_page_spl%&#39;G\n*************************** 1. row ***************************\nname: index_page_splits\ncount: 52186\ntype: counter\nstatus: enabled\ncomment: Number of index page splits\n1 row in set (0.05 sec)\n\nmysql&gt; SELECT\n-&gt; table_schema as &#39;DATABASE&#39;,\n-&gt; table_name as &#39;TABLE&#39;,\n-&gt; CONCAT(ROUND(( data_length + index_length ) &#x2F; ( 1024 * 1024 ), 2), &#39;M&#39;) &#39;TOTAL&#39;,\n-&gt; CONCAT(ROUND(data_free &#x2F; ( 1024 * 1024 ), 2), &#39;M&#39;) &#39;DATAFREE&#39;\n-&gt; FROM information_schema.TABLES\n-&gt; where table_schema&#x3D;&#39;percona&#39; and table_name&#x3D;&#39;frag_page_spl&#39;;\n+----------+---------------+----------+----------+\n| DATABASE | TABLE.        | TOTAL    | DATAFREE |\n+----------+---------------+----------+----------+\n| percona  | frag_page_spl | 2667.55M | 127.92M  |\n+----------+---------------+----------+----------+\n1 row in set (0.00 sec)</code></pre>\n\n<p>从指标上看，我们看到页分裂次数在增加。输出显示有 52186 次页分裂，产生了 127.92MB 的碎片。<br>一旦发生页分裂，唯一的方法是将创建的页降至合并阈值之下。当这种情况发生时，InnoDB 通过合并操作将数据从分裂的页中移出。对表和特定的索引合并阈值是可配置的。<br>另一种重新组织数据的方法是 OPTIMIZE TABLE。这是一个非常重和漫长的过程，但通常这是解决过多页比较稀疏的唯一方法。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>前面两种情况很少见。因为大多数应用程序都不会设计在表中写入大量数据。</li>\n<li>在执行批量插入时（INSERT INTO SELECT * FROM, 加载 mysqldump 的数据, INSERT with huge data 等）需要注意这些问题。</li>\n<li>碎片占用的磁盘空间始终是可重用的。</li>\n</ul>\n","categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]}