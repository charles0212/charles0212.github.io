{"title":"MySQL事务和隔离级别","slug":"yuque/MySQL事务和隔离级别","date":"2018-01-28T16:00:00.000Z","updated":"2022-05-15T04:19:28.493Z","comments":true,"path":"api/articles/mysql/mysql-transaction.json","excerpt":"1、数据库事务 ACID 特性数据库事务的 4 个特性： * 原子性(Atomicity)事务中的多个操作，不可分割，要么都成功，要么都失败，事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。 * 一致性(Consistency)事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。 * 隔离性(Isola","covers":["https://cdn.nlark.com/yuque/0/2022/png/104130/1648310234100-5c0a65d1-3b81-47ce-a200-2e7006f6f49b.png#clientId=u7c1ec514-fc0d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=497&id=u2cb52a02&margin=%5Bobject%20Object%5D&name=image.png&originHeight=994&originWidth=1544&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=98969&status=done&style=none&taskId=u2963e192-f7fb-4450-983b-b1d9b98a6b8&title=&width=772","https://cdn.nlark.com/yuque/0/2022/png/104130/1648310714617-0253ccac-7317-4a0c-bd13-877ff146983a.png#clientId=u7c1ec514-fc0d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=957&id=uafea7c26&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1914&originWidth=1544&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=171359&status=done&style=none&taskId=u74adf793-a0d9-4ed3-a8a3-83903a081a2&title=&width=772","https://cdn.nlark.com/yuque/0/2022/png/104130/1648311001789-6023982f-c8fb-459e-8aa2-09095e18c719.png#clientId=u7c1ec514-fc0d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1132&id=ue0a170e1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2264&originWidth=1544&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=223126&status=done&style=none&taskId=u5365eae2-34c4-4f1f-a33b-e8956a94bf3&title=&width=772"],"content":"<h2 id=\"1、数据库事务-ACID-特性\"><a href=\"#1、数据库事务-ACID-特性\" class=\"headerlink\" title=\"1、数据库事务 ACID 特性\"></a>1、数据库事务 ACID 特性</h2><p>数据库事务的 4 个特性：</p>\n<ul>\n<li><strong>原子性(Atomicity)</strong></li>\n</ul>\n<p>事务中的多个操作，不可分割，要么都成功，要么都失败，事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。</p>\n<ul>\n<li><strong>一致性(Consistency)</strong></li>\n</ul>\n<p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p>\n<ul>\n<li><strong>隔离性(Isolation)</strong></li>\n</ul>\n<p>多个事务之间就像是串行执行一样，不相互影响，一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>\n<ul>\n<li><strong>持续性(Durability)</strong></li>\n</ul>\n<p>事务提交后被持久化到永久存储，也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p>\n<h2 id=\"2、隔离性\"><a href=\"#2、隔离性\" class=\"headerlink\" title=\"2、隔离性\"></a>2、隔离性</h2><p>其中 隔离性 分为了四种：</p>\n<ul>\n<li><strong>READ UNCOMMITTED</strong></li>\n</ul>\n<p>可以读取未提交的数据，未提交的数据称为脏数据，所以又称脏读。此时：幻读，不可重复读和脏读均允许；</p>\n<ul>\n<li><strong>READ COMMITTED</strong></li>\n</ul>\n<p>只能读取已经提交的数据；此时：允许幻读和不可重复读，但不允许脏读，所以 RC 隔离级别要求解决脏读；</p>\n<ul>\n<li><strong>REPEATABLE READ</strong></li>\n</ul>\n<p>同一个事务中多次执行同一个 select,读取到的数据没有发生改变；此时允许幻读，但不允许不可重复读和脏读，所以 RR 隔离级别要求解决不可重复读；事务 A 读取与搜索条件相匹配的若干行。事务 B 以插入或删除行等方式来修改事务 A 的结果集，然后再提交。事务 A 再读取时，却发现数据发生了变化，造成了幻读（MySQL 默认的隔离级别）。</p>\n<ul>\n<li><strong>SERIALIZABLE</strong></li>\n</ul>\n<p>Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。</p>\n<h2 id=\"3、几个概念\"><a href=\"#3、几个概念\" class=\"headerlink\" title=\"3、几个概念\"></a>3、几个概念</h2><p><strong>脏读</strong>：可以读取未提交的数据。RC 要求解决脏读；<br><strong>不可重复读</strong>：同一个事务中多次执行同一个 select, 读取到的数据发生了改变(被其它事务 update 并且提交)；<br><strong>可重复读</strong>：同一个事务中多次执行同一个 select, 读取到的数据没有发生改变(一般使用 MVCC 实现)；RR 各级级别要求达到可重复读的标准；<br><strong>幻读</strong>：同一个事务中多次执行同一个 select, 读取到的数据行发生改变。也就是行数减少或者增加了(被其它事务 delete&#x2F;insert 并且提交)。SERIALIZABLE 要求解决幻读问题；</p>\n<p><strong>读提交，在读取一条记录时会出现不可重复读；</strong><br><strong>可重复读，通过对事务里面的读写操作加锁解决了读提交的问题，但是对统计某个范围内的记录数量，还是会产生幻读。</strong><br><strong>避免不可重复读需要锁行</strong>，<strong>避免幻影读则需要锁表。</strong></p>\n<p>这里一定要区分 <strong>不可重复读 和 幻读：</strong></p>\n<ul>\n<li><strong>不可重复读重点在于 update 和 delete</strong>： 同样的条件的 select, 你读取过的数据, 再次读取出来发现值不一样了</li>\n<li>幻读的重点在于<strong>新增或者删除</strong>： 同样的条件的 select, 第 1 次和第 2 次读出来的记录数不一样</li>\n</ul>\n<p>从结果上来看, 两者都是为多次读取的结果不一致。但如果你从实现的角度来看, 它们的区别就比较大： 对于前者, 在 RC 下只需要锁住满足条件的记录，就可以避免被其它事务修改，也就是 select for update, select in share mode; RR 隔离下使用 MVCC 实现可重复读； 对于后者, 要锁住满足条件的记录及所有这些记录之间的 gap，也就是需要 gap lock。</p>\n<h3 id=\"数据库锁\"><a href=\"#数据库锁\" class=\"headerlink\" title=\"数据库锁\"></a>数据库锁</h3><p>对于解决<strong>可重复读</strong>需要锁行；对于解决<strong>幻影读</strong>则需要锁表。目前主要使用<strong>悲观锁和乐观锁</strong>来实现这两种隔离级别。<strong>可重复读</strong>，第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据；<strong>幻影读，</strong>读用读锁，写用写锁，读锁和写锁互斥，可有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。<br><strong>1）悲观锁</strong><br>对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。<br><strong>悲观锁</strong>的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。<br>在<strong>悲观锁</strong>的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据，来保证操作最大程度的独占性。但随之而来的就是<strong>数据库性能的大量开销</strong>，特别是对长事务而言，这样的开销往往无法承受。<br><strong>2）乐观锁</strong><br><strong>乐观锁</strong>机制采取了更加宽松的加锁机制，在一定程度上解决了这个问题。<br>乐观锁大多是基于数据版本（Version）记录机制实现，为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。要说明的是，MVCC 的实现没有固定的规范，每个数据库都会有不同的实现方式（这里讨论的是 InnoDB 的 MVCC）。</p>\n<p>目前 MySQL、ORACLE、PostgreSQL 等成熟的数据库，出于性能考虑，都是使用了以<strong>乐观锁</strong>为理论基础的 MVCC（多版本并发控制）来避免这两种问题。</p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><table><thead><tr>\n<th>隔离级别</th>\n<th>脏读（Dirty Read）</th>\n<th>不可重复（NonRepeatable Read）</th>\n<th>幻读 （Phantom Read）</th>\n</tr>\n</thead><tbody><tr>\n<td>未提交读（Read uncommitted）</td>\n<td>可能</td>\n<td>可能</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>已提交读（Read committed）</td>\n<td>不可能</td>\n<td>可能</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>可重复读（Repeatable read）</td>\n<td>不可能</td>\n<td>不可能</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>可串行化（Serializable ）</td>\n<td>不可能</td>\n<td>不可能</td>\n<td>不可能</td>\n</tr>\n</tbody></table><h2 id=\"4、实例\"><a href=\"#4、实例\" class=\"headerlink\" title=\"4、实例\"></a>4、实例</h2><p>除了 MySQL 默认采用 RR 隔离级别之外，其它几大数据库都是采用 RC 隔离级别。</p>\n<p>但是他们的实现也是极其不一样的。Oracle 仅仅实现了 RC 和 SERIALIZABLE 隔离级别。默认采用 RC 隔离级别，解决了脏读。但是允许不可重复读和幻读。其 SERIALIZABLE 则解决了脏读、不可重复读、幻读。</p>\n<p>MySQL 的实现：MySQL 默认采用 RR 隔离级别，SQL 标准是要求 RR 解决不可重复读的问题，但是因为 MySQL 采用了<strong>gap lock</strong>，所以<strong>实际上 MySQL 的 RR 隔离级别也解决了幻读的问题</strong>。<br>那么 MySQL 的 SERIALIZABLE 是怎么回事呢？其实 MySQL 的 SERIALIZABLE 采用了经典的实现方式，对读和写都加锁。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">create table &#96;test_trx&#96; (\n&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,\n&#96;value&#96; int(11) NOT NULL DEFAULT 0,\nPRIMARY KEY(&#96;id&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT  CHARSET&#x3D;utf8;\n\ninsert into test_trx(value) value(1),(2),(3),(4),(5);</code></pre>\n\n<p>下面以例子来说明上面上面的情况</p>\n<h3 id=\"1-脏读\"><a href=\"#1-脏读\" class=\"headerlink\" title=\"1) 脏读\"></a>1) 脏读</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648310234100-5c0a65d1-3b81-47ce-a200-2e7006f6f49b.png#clientId=u7c1ec514-fc0d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=497&id=u2cb52a02&margin=%5Bobject%20Object%5D&name=image.png&originHeight=994&originWidth=1544&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=98969&status=done&style=none&taskId=u2963e192-f7fb-4450-983b-b1d9b98a6b8&title=&width=772\" alt=\"image.png\"></p>\n<blockquote>\n<p>未提交隔离级别, 事务 1 中更新的 value,未提交,事务 2 中可以看到、造成脏读</p>\n</blockquote>\n<h3 id=\"2-虚读-不可重复读\"><a href=\"#2-虚读-不可重复读\" class=\"headerlink\" title=\"2) 虚读(不可重复读)\"></a>2) 虚读(不可重复读)</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648310714617-0253ccac-7317-4a0c-bd13-877ff146983a.png#clientId=u7c1ec514-fc0d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=957&id=uafea7c26&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1914&originWidth=1544&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=171359&status=done&style=none&taskId=u74adf793-a0d9-4ed3-a8a3-83903a081a2&title=&width=772\" alt=\"image.png\"></p>\n<blockquote>\n<p>读提交隔离级别,事务 2 在同一个事务中,读取事务 1 提交后的 update 更改</p>\n</blockquote>\n<h3 id=\"3-幻读\"><a href=\"#3-幻读\" class=\"headerlink\" title=\"3) 幻读\"></a>3) 幻读</h3><p>看下大部分 mysql 所说的幻读现象<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648311001789-6023982f-c8fb-459e-8aa2-09095e18c719.png#clientId=u7c1ec514-fc0d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1132&id=ue0a170e1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2264&originWidth=1544&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=223126&status=done&style=none&taskId=u5365eae2-34c4-4f1f-a33b-e8956a94bf3&title=&width=772\" alt=\"image.png\"></p>\n<blockquote>\n<p>事务 2,查询记录里面没有记录 7,插入 7 的时候提示主键重复,幻读.</p>\n</blockquote>\n<p>RR 事务隔离级别号称可以解决幻读的问题（通过当前读加锁来实现）</p>\n<h2 id=\"5、gap-锁（当前读）解决幻读问题\"><a href=\"#5、gap-锁（当前读）解决幻读问题\" class=\"headerlink\" title=\"5、gap 锁（当前读）解决幻读问题\"></a>5、gap 锁（当前读）解决幻读问题</h2><p>mysql 说对数据加锁不管共享锁还是互斥锁就能解决幻读的问题</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select * from test_trx where id between 1 and 7 lock in share mode;\n\nselect * from test_trx where id between 1 and 7 for update;</code></pre>\n\n<p>通过 gap 锁+当前读解决幻读问题,但是 lock in share mode 和 for update 不是标准的 sql 语法.</p>\n<h2 id=\"6、RR-没有解决的幻读\"><a href=\"#6、RR-没有解决的幻读\" class=\"headerlink\" title=\"6、RR 没有解决的幻读\"></a>6、RR 没有解决的幻读</h2><p>场景：我们知道 grap 锁能够将右边的记录进行加锁，因此我要统计表记录的数量，我只需要对最大记录加锁就行了</p>\n","more":"<h2 id=\"1、数据库事务-ACID-特性\"><a href=\"#1、数据库事务-ACID-特性\" class=\"headerlink\" title=\"1、数据库事务 ACID 特性\"></a>1、数据库事务 ACID 特性</h2><p>数据库事务的 4 个特性：</p>\n<ul>\n<li><strong>原子性(Atomicity)</strong></li>\n</ul>\n<p>事务中的多个操作，不可分割，要么都成功，要么都失败，事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。</p>\n<ul>\n<li><strong>一致性(Consistency)</strong></li>\n</ul>\n<p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p>\n<ul>\n<li><strong>隔离性(Isolation)</strong></li>\n</ul>\n<p>多个事务之间就像是串行执行一样，不相互影响，一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>\n<ul>\n<li><strong>持续性(Durability)</strong></li>\n</ul>\n<p>事务提交后被持久化到永久存储，也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p>\n<h2 id=\"2、隔离性\"><a href=\"#2、隔离性\" class=\"headerlink\" title=\"2、隔离性\"></a>2、隔离性</h2><p>其中 隔离性 分为了四种：</p>\n<ul>\n<li><strong>READ UNCOMMITTED</strong></li>\n</ul>\n<p>可以读取未提交的数据，未提交的数据称为脏数据，所以又称脏读。此时：幻读，不可重复读和脏读均允许；</p>\n<ul>\n<li><strong>READ COMMITTED</strong></li>\n</ul>\n<p>只能读取已经提交的数据；此时：允许幻读和不可重复读，但不允许脏读，所以 RC 隔离级别要求解决脏读；</p>\n<ul>\n<li><strong>REPEATABLE READ</strong></li>\n</ul>\n<p>同一个事务中多次执行同一个 select,读取到的数据没有发生改变；此时允许幻读，但不允许不可重复读和脏读，所以 RR 隔离级别要求解决不可重复读；事务 A 读取与搜索条件相匹配的若干行。事务 B 以插入或删除行等方式来修改事务 A 的结果集，然后再提交。事务 A 再读取时，却发现数据发生了变化，造成了幻读（MySQL 默认的隔离级别）。</p>\n<ul>\n<li><strong>SERIALIZABLE</strong></li>\n</ul>\n<p>Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。</p>\n<h2 id=\"3、几个概念\"><a href=\"#3、几个概念\" class=\"headerlink\" title=\"3、几个概念\"></a>3、几个概念</h2><p><strong>脏读</strong>：可以读取未提交的数据。RC 要求解决脏读；<br><strong>不可重复读</strong>：同一个事务中多次执行同一个 select, 读取到的数据发生了改变(被其它事务 update 并且提交)；<br><strong>可重复读</strong>：同一个事务中多次执行同一个 select, 读取到的数据没有发生改变(一般使用 MVCC 实现)；RR 各级级别要求达到可重复读的标准；<br><strong>幻读</strong>：同一个事务中多次执行同一个 select, 读取到的数据行发生改变。也就是行数减少或者增加了(被其它事务 delete&#x2F;insert 并且提交)。SERIALIZABLE 要求解决幻读问题；</p>\n<p><strong>读提交，在读取一条记录时会出现不可重复读；</strong><br><strong>可重复读，通过对事务里面的读写操作加锁解决了读提交的问题，但是对统计某个范围内的记录数量，还是会产生幻读。</strong><br><strong>避免不可重复读需要锁行</strong>，<strong>避免幻影读则需要锁表。</strong></p>\n<p>这里一定要区分 <strong>不可重复读 和 幻读：</strong></p>\n<ul>\n<li><strong>不可重复读重点在于 update 和 delete</strong>： 同样的条件的 select, 你读取过的数据, 再次读取出来发现值不一样了</li>\n<li>幻读的重点在于<strong>新增或者删除</strong>： 同样的条件的 select, 第 1 次和第 2 次读出来的记录数不一样</li>\n</ul>\n<p>从结果上来看, 两者都是为多次读取的结果不一致。但如果你从实现的角度来看, 它们的区别就比较大： 对于前者, 在 RC 下只需要锁住满足条件的记录，就可以避免被其它事务修改，也就是 select for update, select in share mode; RR 隔离下使用 MVCC 实现可重复读； 对于后者, 要锁住满足条件的记录及所有这些记录之间的 gap，也就是需要 gap lock。</p>\n<h3 id=\"数据库锁\"><a href=\"#数据库锁\" class=\"headerlink\" title=\"数据库锁\"></a>数据库锁</h3><p>对于解决<strong>可重复读</strong>需要锁行；对于解决<strong>幻影读</strong>则需要锁表。目前主要使用<strong>悲观锁和乐观锁</strong>来实现这两种隔离级别。<strong>可重复读</strong>，第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据；<strong>幻影读，</strong>读用读锁，写用写锁，读锁和写锁互斥，可有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。<br><strong>1）悲观锁</strong><br>对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。<br><strong>悲观锁</strong>的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。<br>在<strong>悲观锁</strong>的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据，来保证操作最大程度的独占性。但随之而来的就是<strong>数据库性能的大量开销</strong>，特别是对长事务而言，这样的开销往往无法承受。<br><strong>2）乐观锁</strong><br><strong>乐观锁</strong>机制采取了更加宽松的加锁机制，在一定程度上解决了这个问题。<br>乐观锁大多是基于数据版本（Version）记录机制实现，为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。要说明的是，MVCC 的实现没有固定的规范，每个数据库都会有不同的实现方式（这里讨论的是 InnoDB 的 MVCC）。</p>\n<p>目前 MySQL、ORACLE、PostgreSQL 等成熟的数据库，出于性能考虑，都是使用了以<strong>乐观锁</strong>为理论基础的 MVCC（多版本并发控制）来避免这两种问题。</p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><table><thead><tr>\n<th>隔离级别</th>\n<th>脏读（Dirty Read）</th>\n<th>不可重复（NonRepeatable Read）</th>\n<th>幻读 （Phantom Read）</th>\n</tr>\n</thead><tbody><tr>\n<td>未提交读（Read uncommitted）</td>\n<td>可能</td>\n<td>可能</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>已提交读（Read committed）</td>\n<td>不可能</td>\n<td>可能</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>可重复读（Repeatable read）</td>\n<td>不可能</td>\n<td>不可能</td>\n<td>可能</td>\n</tr>\n<tr>\n<td>可串行化（Serializable ）</td>\n<td>不可能</td>\n<td>不可能</td>\n<td>不可能</td>\n</tr>\n</tbody></table><h2 id=\"4、实例\"><a href=\"#4、实例\" class=\"headerlink\" title=\"4、实例\"></a>4、实例</h2><p>除了 MySQL 默认采用 RR 隔离级别之外，其它几大数据库都是采用 RC 隔离级别。</p>\n<p>但是他们的实现也是极其不一样的。Oracle 仅仅实现了 RC 和 SERIALIZABLE 隔离级别。默认采用 RC 隔离级别，解决了脏读。但是允许不可重复读和幻读。其 SERIALIZABLE 则解决了脏读、不可重复读、幻读。</p>\n<p>MySQL 的实现：MySQL 默认采用 RR 隔离级别，SQL 标准是要求 RR 解决不可重复读的问题，但是因为 MySQL 采用了<strong>gap lock</strong>，所以<strong>实际上 MySQL 的 RR 隔离级别也解决了幻读的问题</strong>。<br>那么 MySQL 的 SERIALIZABLE 是怎么回事呢？其实 MySQL 的 SERIALIZABLE 采用了经典的实现方式，对读和写都加锁。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">create table &#96;test_trx&#96; (\n&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,\n&#96;value&#96; int(11) NOT NULL DEFAULT 0,\nPRIMARY KEY(&#96;id&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT  CHARSET&#x3D;utf8;\n\ninsert into test_trx(value) value(1),(2),(3),(4),(5);</code></pre>\n\n<p>下面以例子来说明上面上面的情况</p>\n<h3 id=\"1-脏读\"><a href=\"#1-脏读\" class=\"headerlink\" title=\"1) 脏读\"></a>1) 脏读</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648310234100-5c0a65d1-3b81-47ce-a200-2e7006f6f49b.png#clientId=u7c1ec514-fc0d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=497&id=u2cb52a02&margin=%5Bobject%20Object%5D&name=image.png&originHeight=994&originWidth=1544&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=98969&status=done&style=none&taskId=u2963e192-f7fb-4450-983b-b1d9b98a6b8&title=&width=772\" alt=\"image.png\"></p>\n<blockquote>\n<p>未提交隔离级别, 事务 1 中更新的 value,未提交,事务 2 中可以看到、造成脏读</p>\n</blockquote>\n<h3 id=\"2-虚读-不可重复读\"><a href=\"#2-虚读-不可重复读\" class=\"headerlink\" title=\"2) 虚读(不可重复读)\"></a>2) 虚读(不可重复读)</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648310714617-0253ccac-7317-4a0c-bd13-877ff146983a.png#clientId=u7c1ec514-fc0d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=957&id=uafea7c26&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1914&originWidth=1544&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=171359&status=done&style=none&taskId=u74adf793-a0d9-4ed3-a8a3-83903a081a2&title=&width=772\" alt=\"image.png\"></p>\n<blockquote>\n<p>读提交隔离级别,事务 2 在同一个事务中,读取事务 1 提交后的 update 更改</p>\n</blockquote>\n<h3 id=\"3-幻读\"><a href=\"#3-幻读\" class=\"headerlink\" title=\"3) 幻读\"></a>3) 幻读</h3><p>看下大部分 mysql 所说的幻读现象<br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/104130/1648311001789-6023982f-c8fb-459e-8aa2-09095e18c719.png#clientId=u7c1ec514-fc0d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1132&id=ue0a170e1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2264&originWidth=1544&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=223126&status=done&style=none&taskId=u5365eae2-34c4-4f1f-a33b-e8956a94bf3&title=&width=772\" alt=\"image.png\"></p>\n<blockquote>\n<p>事务 2,查询记录里面没有记录 7,插入 7 的时候提示主键重复,幻读.</p>\n</blockquote>\n<p>RR 事务隔离级别号称可以解决幻读的问题（通过当前读加锁来实现）</p>\n<h2 id=\"5、gap-锁（当前读）解决幻读问题\"><a href=\"#5、gap-锁（当前读）解决幻读问题\" class=\"headerlink\" title=\"5、gap 锁（当前读）解决幻读问题\"></a>5、gap 锁（当前读）解决幻读问题</h2><p>mysql 说对数据加锁不管共享锁还是互斥锁就能解决幻读的问题</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select * from test_trx where id between 1 and 7 lock in share mode;\n\nselect * from test_trx where id between 1 and 7 for update;</code></pre>\n\n<p>通过 gap 锁+当前读解决幻读问题,但是 lock in share mode 和 for update 不是标准的 sql 语法.</p>\n<h2 id=\"6、RR-没有解决的幻读\"><a href=\"#6、RR-没有解决的幻读\" class=\"headerlink\" title=\"6、RR 没有解决的幻读\"></a>6、RR 没有解决的幻读</h2><p>场景：我们知道 grap 锁能够将右边的记录进行加锁，因此我要统计表记录的数量，我只需要对最大记录加锁就行了</p>\n","categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"}]}