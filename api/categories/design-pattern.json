{"name":"design-pattern","postlist":[{"title":"JDK中的设计模式","slug":"yuque/JDK中的设计模式","date":"2015-01-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-design-pattern.json","excerpt":"本文主要是归纳了 JDK中所包含的设计模式，包括作用和其设计类图。一、设计模式的作用 1. 反复出现问题的解决方案 2. 增强软件的灵活性 3. 适应软件不断变化二、设计模式的七大原则 1. 开闭原则 OCP（Open Close    Principle），一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 2. 里氏代换原则 LSP（Liskov    Substitution    Principle），子类可以扩展父类的功能，但不能改变父类原有的功能 3. 依赖倒转原则    DIP（Dependence    Inversion    ","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（一）单例模式","slug":"yuque/JDK设计模式（一）单例模式","date":"2015-01-17T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-singleton-pattern.json","excerpt":"单例模式确保一个类只有一个实例，并提供一个全局访问点。其类图如下所示。本文主要从饿汉式，懒汉式，懒汉式改进，来讲解单例模式。1、饿汉式单例饿汉式单例类是在 Java语言里实现得最为简便的单例类。在类被加载时，就会将自己实例化。public class Singleton {    private static Singleton uniqueInstance = new Singleton();    private Singleton() {        // Exists only to defeat instantiation.    }    publ","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（七）组合模式","slug":"yuque/JDK设计模式（七）组合模式","date":"2015-04-12T01:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-composite-pattern.json","excerpt":"1、定义将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。2、解决的问题组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以像处理简单元素一样来处理复杂元素。3、模式中的角色1、抽象构件（component）:是组合中对象的接口，适当情况下，实现所有类共有方法的默认行为，声明一个接口，用于管理和访问component 子部件2、树枝构件（composite）：定义具有叶节点的组件的行为3、叶子构件（leaf）：定义叶节点的行为4、 客户角色（client）：使用component 接口操作组件行","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（三）建造者模式","slug":"yuque/JDK设计模式（三）建造者模式","date":"2015-01-19T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-builder-pattern.json","excerpt":"将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心，其类图如下。建造者角色Product :产品类，由多个部件构成。class Product {    List parts = new ArrayList();    public void AddPart(String part) {        parts.add(part);    }    public void sho","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（九）外观模式","slug":"yuque/JDK设计模式（九）外观模式","date":"2015-04-12T03:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-facade-pattern.json","excerpt":"1、定义提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易访问。2、解决的问题通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，降低应用程序的复杂度，并且提高了程序的可维护性。封装一组交互类，一致地对外提供接口，简化子系统调用。3、模式中的角色1、外观角色（Facade）：是模式的核心，他被客户client角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订几种功能组合。2、子系统角色（Subsystemclasses）：实现子系统的功能，并处理由Facade对象指派的任务。对子系统而言，fa","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（二）工厂模式","slug":"yuque/JDK设计模式（二）工厂模式","date":"2015-01-18T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-factory-pattern.json","excerpt":"工厂模式是我们最常用的实例化对象模式，使用工厂方法代替new操作的一种模式，使用工厂模式，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。1、简单工厂模式简单工厂模式是属于创建型模式，又叫做静态工厂方法（StaticFactoryMethod）模式，但不属于 23 种GOF 设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。使","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（八）装饰模式","slug":"yuque/JDK设计模式（八）装饰模式","date":"2015-04-12T02:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-decorator-pattern.json","excerpt":"1、定义动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。2、解决的问题在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象，防止类继承带来的爆炸式增长。3、模式中的角色1、抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。2、具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。3、装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。4、具体装饰(C","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（五）适配器模式","slug":"yuque/JDK设计模式（五）适配器模式","date":"2015-04-12T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-adapter-pattern.json","excerpt":"1、定义将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。2、解决的问题即 Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。3、模式中的角色目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。需要适配的类（Adaptee）：需要适配的类或适配者类。适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。4、模式解读在 GoF的设计模式中，对适配器模式讲了两种类型，类适配器模式和对象适配器模式。由于","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（六）桥接模式","slug":"yuque/JDK设计模式（六）桥接模式","date":"2015-04-12T01:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-bridge-pattern.json","excerpt":"1、定义将抽象部分与实现部分分离，使它们都可以独立的变化2、解决的问题某个类具有两个或两个以上的维度变化，如果只是用继承将无法实现这种需要，或者使得设计变得相当臃肿，把变化部分抽象出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要，从达到抽象化、实现化和脱耦。3、模式中的角色1、抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。2、修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。3、实现化(Imple","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十一）代理模式","slug":"yuque/JDK设计模式（十一）代理模式","date":"2015-04-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-proxy-pattern.json","excerpt":"1、定义为另一个对象提供一个替身或占位符以控制对这个对象的访问。2、解决的问题在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，提供额外的处理或者不同的操作。3、模式中的角色1、抽象主题角色(Subject)：声明真实对象和代理对象的共同接口；2、代理角色(Proxy)：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。3、真实主题角色(RealSub","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十七）命令模式","slug":"yuque/JDK设计模式（十七）命令模式","date":"2015-11-15T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-command-pattern.json","excerpt":"1、概述命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。2、解决的问题用于“行为请求者”与“行为实现者”解耦，可实现二者之间的松耦合，以便适应变化。3、模式中的角色1、命令（Command）角色：定义命令的接口，声明执行的方法。2、具体命令（ConcreteCommand）角色：命令接口实现对象，通常它会持有命令的接收者，通过调用接收者相应的功能方法来执行当前命令所要完成的操作。3、接收者（Receiver）角色：真正执行命令的对象。任何类都可以成为一个接收者，只要它能够实现命令要求实现的相应功能即可。4","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十三）模板方法模式","slug":"yuque/JDK设计模式（十三）模板方法模式","date":"2015-10-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-template-method-pattern.json","excerpt":"1、概述定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。2、模式中的角色抽象模板类（AbstractTemplate）：实现了模板方法，定义了算法的骨架。具体模板类（ConcreteTemplate)：实现抽象类中的抽象方法，已完成完整的算法。3、模式解读模板方式模式的类图如下所示模板方法中的方法可以分为两大类：模板方法和基本方法。模板方法，一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十二）策略模式","slug":"yuque/JDK设计模式（十二）策略模式","date":"2015-04-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-strategy-pattern.json","excerpt":"1、定义策略模式，又叫算法簇模式，就是定义了不同的算法族，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。2、解决的问题可以动态的改变对象的行为。3、模式中的角色1、环境对象(context)：该类中实现了对抽象策略中定义的接口或者抽象类的引用。2、抽象策略对象(Strategy)：它可由接口或抽象类来实现。3、具体策略对象(ConcreteStrategy)：它封装了实现同不功能的不同算法。利用策略模式构建应用程序，可以根据用户配置等内容，选择不同有算法来实现应用程序的功能。具体的选择有环境对象来完成。采用这种方式可以避免由于使用条件语句而带来的代","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十五）迭代器模式","slug":"yuque/JDK设计模式（十五）迭代器模式","date":"2015-11-12T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-iterator-pattern.json","excerpt":"1. 概述迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。2. 解决的问题把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所。3. 模式中的角色1、抽象迭代器(Iterator)：定义出遍历元素所需的接口。2、具体迭代器(ConcreteIterator)：实现Iterator接口，并保持迭代过程中的游标位置。3、聚集(Aggregate)：给出创建迭代器(Iterator)对象的接口。4、具体聚集(ConcreteAggregate)：实现创建迭代器(Iterator)对象的接口，返回一个合适","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十六）责任链模式","slug":"yuque/JDK设计模式（十六）责任链模式","date":"2015-11-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-responsibility-pattern.json","excerpt":"1、概述责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。2、解决的问题如果有多个对象都有可能接受请求，可以避免请求发送者与接收者耦合在一起。3、模式中的角色1、抽象处理者角色(Handler):定义一个处理请求的接口，和一个后继连接(可选)2、具体处理者角色(ConcreteHandler):处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。3、客户类(Client):向一个链上的具体处理者ConcreteHandler对象提","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十四）观察者模式","slug":"yuque/JDK设计模式（十四）观察者模式","date":"2015-11-06T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-observer-pattern.json","excerpt":"1. 概述有时被称作发布/订阅模式，观察者模式定义了对象之间的一对多的依赖关系，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。2. 解决的问题将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。3. 模式中的角色1、抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。2、具体主题（ConcreteS","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十）享元模式","slug":"yuque/JDK设计模式（十）享元模式","date":"2015-04-12T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-flyweight-pattern.json","excerpt":"1、定义采用一个共享来避免大量拥有相同内容对象的开销。2、解决的问题使用共享物件，用来尽可能减少内存使用量，以及分享资讯给尽可能多的相似物件；适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。3、模式中的角色内蕴状态存储在享元内部，不会随环境的改变而有所不同，是可以共享的；外蕴状态是不可以共享的，它随环境的改变而改变的，因此外蕴状态是由客户端来保持（因为环境的变化是由客户端引起的）。在每个具体的环境下，客户端将外蕴状态传递给享元，从而创建不同的对象出来。享元模式可分为：单纯享元模式和复合享元模式。1、抽象享元角色(Flyweight)：为具体享元角色规定","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（四）原型模式","slug":"yuque/JDK设计模式（四）原型模式","date":"2015-03-08T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-prototype-pattern.json","excerpt":"用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。在原型模式中，所发动创建的对象通过请求原型对象来拷贝原型对象自己来实现创建过程，当然所发动创建的对象需要知道原型对象的类型。这里也就是说所发动创建的对象只需要知道原型对象的类型就可以获得更多的原型实例对象，至于这些原型对象时如何创建的根本不需要关心，其类图如下所示。原型模式主要包含如下三个角色： * Prototype：抽象原型类。声明克隆自身的接口。 * ConcretePrototype：具体原型类。实现克隆的具体操作。 * Client：客户类。让一个原型克隆自身，从而获得一个新的对象。讲到原型模式，我们就","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"设计模式与GO","slug":"yuque/设计模式与GO","date":"2021-05-31T16:00:00.000Z","updated":"2022-05-15T04:55:51.000Z","comments":true,"path":"api/articles/design-pattern/go-design-pattern.json","excerpt":"> 原文链接：https://refactoringguru.cn/design-patterns/go> 代码可见：https://github.com/charles0212/design-patterns创建型模式创建型模式 模式描述 抽象工厂AbstractFactory，让你能创建一系列相关的对象，而无需指定其具体类。 生成器Builder，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。工厂方法 FactoryMethod，在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。原型Prototype，让你","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"设计模式","path":"api/tags/设计模式.json"},{"name":"Go","path":"api/tags/Go.json"}]}]}