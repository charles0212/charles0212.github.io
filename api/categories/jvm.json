{"name":"jvm","postlist":[{"title":"JVM（一）Java内存区域与内存溢出","slug":"yuque/JVM（一）Java内存区域与内存溢出","date":"2016-01-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/java-oom.json","excerpt":"Java 内存区域Java虚拟机所管理的内存将包括以下几个运行时数据区域，如下图所示：程序计数器ProgramCounterRegister是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变程序计数器的值来选取下一条要执行的字节码指令，分支、循环、跳转、异常跳转、线程恢复等基础功能都需要依赖这个计数器来完成。由于 Java虚拟机的多线程时通过线程切换并分配处理器执行时间来实现的，对于单核处理器在某一个时间都只会有一个线程在运行，为了线程切换后能恢复到正确的执行位置，每个线程都需要维护一个独立的程序计数器，各个线程之","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（七）深入理解java内存模型","slug":"yuque/JVM（七）深入理解java内存模型","date":"2016-08-06T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/java-memory-model.json","excerpt":"> java> 线程之间的通信对程序员完全透明，内存可见性问题很容易困扰> java 程序员，本文试图揭开 java> 内存模型神秘的面纱。本文大致分三部分：重排序与顺序一致性；三个同步原语（lock，volatile，final）的内存语义，重排序规则及在处理器中的实现；java内存模型的设计目标，及其与处理器内存模型和顺序一致性内存模型的关系。 * 深入理解 java   内存模型（一）——基础 * 深入理解 java   内存模型（二）——重排序 * 深入理解 java   内存模型（三）——顺序一致性 * 深入理解 java   内存模型（四）——v","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（三）内存分配与回收策略","slug":"yuque/JVM（三）内存分配与回收策略","date":"2016-07-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-gc-allocation.json","excerpt":"对象的分配的细节取决于当前使用哪一种垃圾收集器组合，以及和内存相关参数有关，本文主要讨论Serial/SerialOld收集器的内存分配和回收的策略，其他几种垃圾收集器可以自己去探讨。先介绍下 MinorGC 和FullGC 的概念。新生代 GC（MinorGC）:发生在新生代，Java对象大多都有朝生夕死的特性，MinorGC非常频繁，回收速度也比较快。老年代GC（MajorGC/FullGC）:发生在老年代，出现 MajorGC经常至少伴随一次的MinorGC，但非绝对。MajorGC的速度一般比 MinorGC 慢 10倍以上。下面是最普遍的内存分配规则","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（二）垃圾收集算法与收集器","slug":"yuque/JVM（二）垃圾收集算法与收集器","date":"2016-01-08T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-gc.json","excerpt":"Java 堆中几乎存放着 java中所有的对象实例，垃圾收集器在对堆进行回收前，需要确定哪些对象还”存活”着，哪些已经“死去”。垃圾回收必须能够完成两件事情：正确检测出垃圾对象；释放垃圾对象占用的空间。1、垃圾检测算法当前常见的检测垃圾的方法包括两种：1.引用计数法；2. 可达性分析算法。1.1 引用计数算法（ReferenceCounting）给对象添加一个引用计数器，每当该对象被引用，它的计数器值就＋1；当引用失效时，计数器就－1；在任何情况下，当计数器值为0 时，就表示该对象不再被使用。缺点：它很难解决对象之间相互引用，引起的循环引用问题，会产生无法被释放","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（五）虚拟机类加载机制","slug":"yuque/JVM（五）虚拟机类加载机制","date":"2016-08-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-classloader.json","excerpt":"Java提供了动态的装载特性；它会在运行时的第一次引用到一个class的时候对它进行装载和链接，而不是在编译期进行。JVM的类装载器负责动态装载，基本上所有的类加载器都是java.lang.ClassLoader类的一个实例。Java 类装载器有如下几个特点： * 层级结构：Java   里的类装载器被组织成了有父子关系的层级结构。Bootstrap   类装载器是所有装载器的父亲。 * 代理模式：基于层级结构，类的装载可以在装载器之间进行代理。当装载器装载一个类时，首先会检查它是否在父装载器中进行装载了。如果上层的装载器已经装载了这个类，这个类会被直接使用。反","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（六）虚拟机类加载委派模型","slug":"yuque/JVM（六）虚拟机类加载委派模型","date":"2016-08-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-classloader-delegate.json","excerpt":"双亲委派模型当一个类装载器（classloader）被请求装载类时，它首先按照顺序在上层装载器、父装载器以及自身的装载器的缓存里检查这个类是否已经存在。简单来说，就是在缓存里查看这个类是否已经被自己装载过了，如果没有的话，继续查找父类的缓存，直到在bootstrap类装载器里也没有找到的话，它就会自己在文件系统里去查找并且加载这个类。ClassLoader 的loadClass 方法protected Class loadClass(String name, boolean resolve)            throws ClassNotFoundExcepti","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（四）类文件结构解析","slug":"yuque/JVM（四）类文件结构解析","date":"2016-07-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-class.json","excerpt":"Java Class 文件结构如下图所示对于以下 java 源文件代码public class Charles implements ICharles{  private String name;  public void say() {    System.out.println(\"charles\");  }  public String getName() {    return name;  }  public void setName(String name) {    this.name = name;  }}生成的类文件字节码为根据 cla","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"深入理解jvm虚拟机","slug":"yuque/深入理解jvm虚拟机","date":"2015-05-03T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/understanding-jvm.json","excerpt":"> 每个 Java 开发者都知道 Java> 字节码是执行在 JRE(（Java> Runtime Environment> Java 运行时环境）上的。JRE> 中最重要的部分是 Java> 虚拟机（JVM），JVM 负责分析和执行> Java 字节码。Java> 开发人员并不需要去关心 JVM> 是如何运行的。在没有深入理解 JVM> 的情况下，许多开发者已经开发出了非常多的优秀的应用以及> Java 类库。不过，如果你了解 JVM> 的话，你会更加了解 Java> 的，并且你会轻松解决那些看似简单但是无从下手的问题。本系列主要从以下几个方面进行分析1、Jav","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]}]}