{"name":"disruptor","postlist":[{"title":"Disruptor（一）RingBuffer数据结构","slug":"yuque/Disruptor（一）RingBuffer数据结构","date":"2016-09-19T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer.json","excerpt":"> Disruptor 是 LMAX> 公司开源的一个高效的内存无锁队列。并发程序设计几个概念1、锁：锁是用来做并发最简单的方式，当然其代价也是最高的。内核态的锁的时候需要操作系统进行一次上下文切换，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。用户态的锁虽然避免了这些问题，但是其实它们只是在没有真实的竞争时才有效。2、CAS： CAS的涵义不多介绍了。使用 CAS时不像上锁那样需要一次上下文切换，但是也需要处理器锁住它的指令流水线来保证原子性，并且还要加上Memory Barrier来保证其结果可见。3","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（三）RingBuffer单生产者写入","slug":"yuque/Disruptor（三）RingBuffer单生产者写入","date":"2017-02-15T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-single-write.json","excerpt":"上一章主要介绍了消费者从RingBuffer读取数据，本章主要介绍单个生产者如何向RingBuffer 数据写入数据。在RingBuffer数据写入过程中如何不要让 Ring重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作。在 RingBuffer写入数据的过程涉及到两阶段提交(two-phasecommit)1）生产者需要申请 buffer里的下一个节点。2）当生产者向节点写完数据，需要调用调用publish 发布数据。1、单个生产者SingleProducerSequencer数据写入在后台由ProducerSequencer","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（二）RingBuffer读取","slug":"yuque/Disruptor（二）RingBuffer读取","date":"2016-12-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-read.json","excerpt":"上一章主要介绍 Ring Buffer的数据结构，本章主要讲解如何使用Disruptor 从 RingBuffer 中读取数据。1、消费者通过ProcessingSequenceBarrier读取数据能够读取数据的前提是数据已经写入到Ring Buffer中，关于数据的写入，后面一章节会详细讲解。RingBuffer 的元素的大小是 2的 n 次方（上面ringBufferSize 为8，从序号 0开始）。消费者(Consumer)是一个想从RingBuffer里读取数据的线程，它可以通过访问ProcessingSequenceBarrier对象和 ","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（四）RingBuffer多生产者写入","slug":"yuque/Disruptor（四）RingBuffer多生产者写入","date":"2017-03-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-muti-write.json","excerpt":"上一章主要介绍了单个生产者如何向RingBuffer数据写入数据，如何不要让 Ring重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作，本章主要介绍多生产者向RingBuffer 数据写入数据。1、多生产者MultiProducerSequencer申请下一个节点和单生产者不同的是在 next方法中会直接通过cursor.compareAndSet(current,next)设置生产者的游标 cursor的sequence。大家很可能会问设置了生产者的游标后，没有提交数据之前，多生产者场景中消费者是否就能够获取到数据，答案是否定的，在M","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（五）DSL相关实战","slug":"yuque/Disruptor（五）DSL相关实战","date":"2017-03-09T16:00:00.000Z","updated":"2022-05-15T04:19:28.490Z","comments":true,"path":"api/articles/disruptor/disruptor-practise.json","excerpt":"本文主要讲解使用 Disruptor 的DSL演示生产者和消费者的数据交换，和以往的线程间通信不同，disruptor使用消息传递的方式，通过RingBuffer进行线程间的数据传递和通信，下面分别从一对一和多对一的模型进行讲解。下面主要通过计算区间[0 ,100000000)中的所有数值相加为例子讲解Disruptor 中的 dsl 使用。1、一对一一个生产者和一个消费者之间进行数据传递，使用disruptor 主要涉及到RingBuffer 中的ValueEvent定义，ValueAdditionEventHandler消费者处理，以及生产者发布。","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"深入理解Disruptor","slug":"yuque/深入理解Disruptor","date":"2016-09-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/understanding-disruptor.json","excerpt":"> Disruptor 是 LMAX> 公司开源的一个高效的内存无锁队列，一个高性能的异步处理框架，或者可以认为是最快的消息框架(轻量的> JMS)，也可以认为是一个观察者模式实现，或者事件-监听模式的实现，直接称> disruptor> 模式。disruptor> 最大特点是高性能，其 LMAX> 架构可以获得每秒 6 百万订单，用 1> 微秒的延迟获得吞吐量为 100K+。理解> Disruptor> 的原理，可以帮助我们更好的理解内存无锁，CAS，volatile，缓冲行等并发原理。本文主要从以下方面介绍disruptor：1、Disruptor 概念和Rin","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]}]}