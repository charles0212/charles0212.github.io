{"name":"cache","postlist":[{"title":"Redis分布式锁","slug":"yuque/Redis分布式锁","date":"2021-06-20T16:00:00.000Z","updated":"2022-04-03T04:07:21.000Z","comments":true,"path":"api/articles/cache/redis-lock.json","excerpt":"> 分布式锁为解决分布式系统中多个应用同时访问同一个资源的问题。分布式锁的使用场景一般是在两个场景下会防止对同一个资源的重复访问 * 提升效率比如多个节点计算同一批任务，如果某个任务已经有节点在计算了，那其他节点就不用重复计算了，以免浪费计算资源。不过重复计算也没事，不会造成其他更大的损失，允许偶尔的失败。 * 保证正确性这种情况对锁的要求就很高了，如果重复计算，会对正确性造成影响，不允许失败。分布式锁支持的特性在这个技术不断更新迭代的情况下，分布式这个概念，在企业中的权重越来越高。谈及分布式时，不可避免一定会提到分布式锁，现阶段分布式锁的实现方式主流的有几","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis大Value","slug":"yuque/Redis大Value","date":"2021-06-20T16:00:00.000Z","updated":"2022-04-02T16:49:05.000Z","comments":true,"path":"api/articles/cache/redis-large-value.json","excerpt":"大 key 和大 value的危害，如何处理Redis 的大 key 有什么危害？一个 key 的 value较大时的情况，比如： * 内存不均：单 value   较大时，可能会导致节点之间的内存使用不均匀，间接地影响   key 的部分和负载不均匀； * 阻塞请求：redis 为单线程，单   value   较大读写需要较长的处理时间，会阻塞后续的请求处理； * 阻塞网络：单 value   较大时会占用服务器网卡较多带宽，可能会影响该服务器上的其他   Redis 实例或者应用。虽说答的是挺好的，但是我又随之产生了另一个疑惑，如果redis 的 ke","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis存储结构","slug":"yuque/Redis存储结构","date":"2021-06-22T16:00:00.000Z","updated":"2022-04-02T16:49:05.000Z","comments":true,"path":"api/articles/cache/redis-storage-structure.json","excerpt":"前言Redis作为一款高性能数据库，表现在：它接收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。其高性能得奥秘来缘于以下两点： * Redis 是内存数据库，   所有操作都在内存上完成，内存的访问速度本身就很快 * Reids   通过高效的数据结构来组织数据。本章节可以让你在最短的时间了解如下内容： * Redis 支持五大数据类型 * Redis 组织 Key-Value   数据结构 * Redis5 大值类型数据存储结构一、五大数据类型 * String(字符串) * List(列表) * Set(集合) * Hash","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis线程模型","slug":"yuque/Redis线程模型","date":"2021-06-23T16:00:00.000Z","updated":"2022-04-02T16:49:05.000Z","comments":true,"path":"api/articles/cache/redis-thread-model.json","excerpt":"一、Redis 有多快？Redis 是基于内存运行的高性能K-V数据库，官方提供的测试报告是单机可以支持约10w/s 的 QPS二、Redis 为什么这么快？（1）完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO 读取到内存这部分的开销。（2）数据结构简单，对数据操作也简单。Redis中的数据结构是专门进行设计的，每种数据结构都有一种或多种数据结构来支持。Redis正是依赖这些灵活的数据结构，来提升读取和写入的性能。（3）采用单线程，省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（一）基础数据类型","slug":"yuque/Redis（一）基础数据类型","date":"2020-06-22T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/redis/redis-introduce.json","excerpt":"REmote DIctionaryServer(Redis) 是一个由Salvatore Sanfilippo写的 key-value存储系统。Redis 是一个开源的使用ANSI C 语言编写、遵守 BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是字符串(String),哈希(Map), 列表(list),集合(sets) 和有序集合(sortedsets)等类型。Redis 简介Redis 是完全开源免费的，遵守BSD 协议，是一个高性能的k","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（七）大key和大value","slug":"yuque/Redis（七）大key和大value","date":"2020-06-26T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/redis/redis-large-value.json","excerpt":"大 key 和大 value的危害，如何处理Redis 的大 key 有什么危害？一个 key 的 value较大时的情况，比如： * 内存不均：单 value   较大时，可能会导致节点之间的内存使用不均匀，间接地影响   key 的部分和负载不均匀； * 阻塞请求：redis 为单线程，单   value   较大读写需要较长的处理时间，会阻塞后续的请求处理； * 阻塞网络：单 value   较大时会占用服务器网卡较多带宽，可能会影响该服务器上的其他   Redis 实例或者应用。虽说答的是挺好的，但是我又随之产生了另一个疑惑，如果redis 的 ke","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（三）部署Sentinel高可用集群","slug":"yuque/Redis（三）部署Sentinel高可用集群","date":"2020-06-23T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/redis/redis-sentinel.json","excerpt":"> 大家一定非常熟悉如何利用 Docker> 启动单个 Redis> 容器用于开发环境，本文将介绍如何利用> Docker Compose> 模板在本机和云端部署基于> Sentinel 的高可用 Redis> 3 集群。Redis 集群可以在一组 redis节点之间实现高可用性和sharding。今天我们重点围绕master-slave的高可用模式来进行讨论，在集群中会有 1个 master 和多个 slave节点。当 master节点失效时，应选举出一个 slave节点作为新的 master。然而Redis本身(包括它的很多客户端)没有实现自动故障发现并","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Docker","path":"api/tags/Docker.json"},{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（二）ShardedJedis一致性哈希","slug":"yuque/Redis（二）ShardedJedis一致性哈希","date":"2020-06-23T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/redis/redis-consistent-hashing.json","excerpt":"本文主要介绍一致性哈希的概念，以及在Redis 中的ShardedJedis一致性哈希实现原理1、非一致性哈希在讨论一致性哈希之前，先认识下”非一致性哈希”，例如HashMap。当使用 HashMap 时，key被均匀地映射到数组之上，映射方法就是利用key 的 hash与数组长度取模(通过&运算)。当 put 的数据超过负载因子loadFactor×2Len时，HashMap 会按照 2被的容量扩容。新 put进来的数据会通过与新数组的长度取模的方式进行映射。那之前已经映射的数据该怎么办？通过查看 HashMap 代码的resize方法会发现，每次","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（五）线程模型","slug":"yuque/Redis（五）线程模型","date":"2020-06-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/redis/redis-thread-model.json","excerpt":"一、Redis 有多快？Redis 是基于内存运行的高性能K-V数据库，官方提供的测试报告是单机可以支持约10w/s 的 QPS二、Redis 为什么这么快？（1）完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO 读取到内存这部分的开销。（2）数据结构简单，对数据操作也简单。Redis中的数据结构是专门进行设计的，每种数据结构都有一种或多种数据结构来支持。Redis正是依赖这些灵活的数据结构，来提升读取和写入的性能。（3）采用单线程，省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（八）Zset结构和跳表SkipList","slug":"yuque/Redis（八）Zset结构和跳表SkipList","date":"2020-07-27T16:00:00.000Z","updated":"2022-09-09T13:07:16.843Z","comments":true,"path":"api/articles/redis/redis-zset.json","excerpt":"zset 是 redis中一种有序、不重复的数据类型，每个元素都有一个分值，它可用于实现排行榜单，其底层采用压缩表ziplist 或跳表 skiplist的数据结构实现Zset 的两种数据结构压缩表 ziplist当 redis插入第一个元素时，同时满足以下条件，就会以ziplist 创建跳表 1. 节点数量<128 （可通过    server.zset_max_ziplist_entries    设置） 2. 节点的长度<64（可通过    server.zset_max_ziplist_value    设置）当选择用 ziplist 实现 ","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（六）分布式锁","slug":"yuque/Redis（六）分布式锁","date":"2020-06-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/redis/redis-lock.json","excerpt":"> 分布式锁为解决分布式系统中多个应用同时访问同一个资源的问题。分布式锁的使用场景一般是在两个场景下会防止对同一个资源的重复访问 * 提升效率比如多个节点计算同一批任务，如果某个任务已经有节点在计算了，那其他节点就不用重复计算了，以免浪费计算资源。不过重复计算也没事，不会造成其他更大的损失，允许偶尔的失败。 * 保证正确性这种情况对锁的要求就很高了，如果重复计算，会对正确性造成影响，不允许失败。分布式锁支持的特性在这个技术不断更新迭代的情况下，分布式这个概念，在企业中的权重越来越高。谈及分布式时，不可避免一定会提到分布式锁，现阶段分布式锁的实现方式主流的有几","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（四）存储结构","slug":"yuque/Redis（四）存储结构","date":"2020-06-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/redis/redis-storage-structure.json","excerpt":"前言Redis作为一款高性能数据库，表现在：它接收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。其高性能得奥秘来缘于以下两点： * Redis 是内存数据库，   所有操作都在内存上完成，内存的访问速度本身就很快 * Reids   通过高效的数据结构来组织数据。本章节可以让你在最短的时间了解如下内容： * Redis 支持五大数据类型 * Redis 组织 Key-Value   数据结构 * Redis5 大值类型数据存储结构一、五大数据类型 * String(字符串) * List(列表) * Set(集合) * Hash","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"TMC多级缓存","slug":"yuque/TMC多级缓存","date":"2021-07-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/cache/tmc.json","excerpt":"> TMC (Transparent> Multilevel Cache)> 在通用“分布式缓存解决方案（如> CodisProxy + Redis> ）”基础上，增加了以下功能：> >  * 应用层热点探测>  * 应用层本地缓存>  * 应用层缓存命中统计> > 以帮助应用层解决缓存使用过程中出现的热点访问问题使用有赞服务的电商商家数量和类型很多，商家会不定期做一些“商品秒杀”、“商品推广”活动，导致“营销活动”、“商品详情”、“交易下单”等链路应用出现缓存热点访问 的情况： * 活动时间、活动类型、活动商品之类的信息不可预期，导致   缓存热点访问","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"TMC","path":"api/tags/TMC.json"}]}]}