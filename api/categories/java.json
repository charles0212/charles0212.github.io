{"name":"java","postlist":[{"title":"Java并发编程之锁","slug":"yuque/Java并发编程之锁","date":"2015-01-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-lock.json","excerpt":"> 作为一个 java> 开发者，并发编程是不可或缺的，在并发的过程，Lock> 是并发的关键，> 本文主要从排它锁和共享锁的实例来讲解锁的机制。本文主要从以下方面来讲解锁的原理及使用： 1. AbstractQueuedSynchronizer    分析 2. ReentrantLock 独占锁分析 3. CountDownLatch 共享锁分析 4. ConditionObject 分析 5. CyclicBarrier 分析","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java引用类型","slug":"yuque/Java引用类型","date":"2015-02-28T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-reference.json","excerpt":"内存回收每一个 Java程序中的对象都会占用一定的计算机资源，最常见的，如：每个对象都会在堆空间上申请一定的内存空间。但是除了内存之外，对象还会占用其它资源，如文件句柄，端口，socket等等。当你创建一个对象的时候，必须保证它在销毁的时候会释放它占用的资源。否则程序将会在OOM 中结束它的使命。在 Java中数据内存分配发生在栈和堆中，对于栈中的变量（引用类型，基本类型）会在方法的退出时自动释放，对于new出来对象分配到堆中，不需要程序员来管理内存的分配和释放，Java有自动进行内存管理的神器——垃圾回收器，垃圾回收器会自动回收那些不再使用的对象。那如何判断对象不再使用呢","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Java锁（一）AQS分析","slug":"yuque/Java锁（一）AQS分析","date":"2015-02-01T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-aqs.json","excerpt":"> 作为一个 java> 开发者，并发编程是不可或缺的，在并发的过程，Lock> 是并发的关键。本系列文章主要来讲解锁的原理和机制。在理解 J.U.C原理以及锁机制之前，我们来介绍J.U.C框架最核心也是最复杂的一个基础类：java.util.concurrent.locks.AbstractQueuedSynchronizer。上面的继承体系中，AbstractQueuedSynchronizer是CountDownLatch/Semaphore/RenntrantReadWriteLock/Worker/ReentrantLock的基础，因此AbstractQ","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（二）ReentrantLock独占锁分析","slug":"yuque/Java锁（二）ReentrantLock独占锁分析","date":"2015-02-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-reentrantlock.json","excerpt":"ReentrantLock的功能是实现代码段的并发访问控制，是一种排它锁，也就是通常意义上所说的锁，内部有两种实现NonfairSync 和FairSync，公平锁和非公平锁，默认采用非公平锁策略。ReentrantLock的实现不仅可以替代隐式的synchronized关键字，而且能够提供超过关键字本身的多种功能。1、ReentrantLock 的使用class X {  private final ReentrantLock lock = new ReentrantLock();  // ...  public void m() {    lock.lock","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（三）CountDownLatch共享锁分析","slug":"yuque/Java锁（三）CountDownLatch共享锁分析","date":"2015-02-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-countdownlatch.json","excerpt":"> 在开始解读 AQS> 的共享功能前，我们再重温一下> CountDownLatch，CountDownLatch> 为> java.util.concurrent> 包下的计数器工具类，常被用在多线程环境下，它在初始时需要指定一个计数器的大小，然后可被多个线程并发的实现减> 1 操作，并在计数器为 0 后调用> await> 方法的线程被唤醒，从而实现多线程间的协作。1、闭锁使用class Driver2 {    void main() throws InterruptedException {        CountDownLatch doneSigna","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（五）CyclicBarrier分析","slug":"yuque/Java锁（五）CyclicBarrier分析","date":"2015-02-07T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-cyclicbarrier.json","excerpt":"CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(intparties)，其参数表示屏障拦截的线程数量，每个线程调用await 方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。1、CyclicBarrier 使用实例public class CyclicBarrierTest {    stati","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（四）ConditionObject分析","slug":"yuque/Java锁（四）ConditionObject分析","date":"2015-02-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-conditionobject.json","excerpt":"在讲 ConditionObject之前，先讲解下条件队列。条件队列能够使得一组线程能够通过某种方式来等待特定的条件变成真，条件队列中的成员是一个个正在等待状态的线程。条件队列提供了一种挂起方式，当现场等待的条件非真时，挂起自己并释放锁，一旦等待条件为真，则立即醒来。条件队列主要功能1、隐式锁对应的条件队列对象的内置锁（synchronized语义对应的同步机制），关联着一个内置的条件队列。Object的wait/notify/notifyAll等方法构成了内部条件队列的API（即将内部锁与内部条件队列关联的机制）。内部条件队列是需要内置锁保护的，需要调用对象X","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]}]}