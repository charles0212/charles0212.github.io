{"total":99,"pageSize":10,"pageCount":10,"data":[{"title":"Java锁（四）ConditionObject分析","slug":"yuque/Java锁（四）ConditionObject分析","date":"2015-02-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-conditionobject.json","excerpt":"在讲 ConditionObject之前，先讲解下条件队列。条件队列能够使得一组线程能够通过某种方式来等待特定的条件变成真，条件队列中的成员是一个个正在等待状态的线程。条件队列提供了一种挂起方式，当现场等待的条件非真时，挂起自己并释放锁，一旦等待条件为真，则立即醒来。条件队列主要功能1、隐式锁对应的条件队列对象的内置锁（synchronized语义对应的同步机制），关联着一个内置的条件队列。Object的wait/notify/notifyAll等方法构成了内部条件队列的API（即将内部锁与内部条件队列关联的机制）。内部条件队列是需要内置锁保护的，需要调用对象X","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（三）CountDownLatch共享锁分析","slug":"yuque/Java锁（三）CountDownLatch共享锁分析","date":"2015-02-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-countdownlatch.json","excerpt":"> 在开始解读 AQS> 的共享功能前，我们再重温一下> CountDownLatch，CountDownLatch> 为> java.util.concurrent> 包下的计数器工具类，常被用在多线程环境下，它在初始时需要指定一个计数器的大小，然后可被多个线程并发的实现减> 1 操作，并在计数器为 0 后调用> await> 方法的线程被唤醒，从而实现多线程间的协作。1、闭锁使用class Driver2 {    void main() throws InterruptedException {        CountDownLatch doneSigna","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（二）ReentrantLock独占锁分析","slug":"yuque/Java锁（二）ReentrantLock独占锁分析","date":"2015-02-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-reentrantlock.json","excerpt":"ReentrantLock的功能是实现代码段的并发访问控制，是一种排它锁，也就是通常意义上所说的锁，内部有两种实现NonfairSync 和FairSync，公平锁和非公平锁，默认采用非公平锁策略。ReentrantLock的实现不仅可以替代隐式的synchronized关键字，而且能够提供超过关键字本身的多种功能。1、ReentrantLock 的使用class X {  private final ReentrantLock lock = new ReentrantLock();  // ...  public void m() {    lock.lock","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（一）AQS分析","slug":"yuque/Java锁（一）AQS分析","date":"2015-02-01T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-aqs.json","excerpt":"> 作为一个 java> 开发者，并发编程是不可或缺的，在并发的过程，Lock> 是并发的关键。本系列文章主要来讲解锁的原理和机制。在理解 J.U.C原理以及锁机制之前，我们来介绍J.U.C框架最核心也是最复杂的一个基础类：java.util.concurrent.locks.AbstractQueuedSynchronizer。上面的继承体系中，AbstractQueuedSynchronizer是CountDownLatch/Semaphore/RenntrantReadWriteLock/Worker/ReentrantLock的基础，因此AbstractQ","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java并发编程之锁","slug":"yuque/Java并发编程之锁","date":"2015-01-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-lock.json","excerpt":"> 作为一个 java> 开发者，并发编程是不可或缺的，在并发的过程，Lock> 是并发的关键，> 本文主要从排它锁和共享锁的实例来讲解锁的机制。本文主要从以下方面来讲解锁的原理及使用： 1. AbstractQueuedSynchronizer    分析 2. ReentrantLock 独占锁分析 3. CountDownLatch 共享锁分析 4. ConditionObject 分析 5. CyclicBarrier 分析","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"JDK设计模式（三）建造者模式","slug":"yuque/JDK设计模式（三）建造者模式","date":"2015-01-19T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-builder-pattern.json","excerpt":"将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心，其类图如下。建造者角色Product :产品类，由多个部件构成。class Product {    List parts = new ArrayList();    public void AddPart(String part) {        parts.add(part);    }    public void sho","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（二）工厂模式","slug":"yuque/JDK设计模式（二）工厂模式","date":"2015-01-18T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-factory-pattern.json","excerpt":"工厂模式是我们最常用的实例化对象模式，使用工厂方法代替new操作的一种模式，使用工厂模式，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。1、简单工厂模式简单工厂模式是属于创建型模式，又叫做静态工厂方法（StaticFactoryMethod）模式，但不属于 23 种GOF 设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。使","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（一）单例模式","slug":"yuque/JDK设计模式（一）单例模式","date":"2015-01-17T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-singleton-pattern.json","excerpt":"单例模式确保一个类只有一个实例，并提供一个全局访问点。其类图如下所示。本文主要从饿汉式，懒汉式，懒汉式改进，来讲解单例模式。1、饿汉式单例饿汉式单例类是在 Java语言里实现得最为简便的单例类。在类被加载时，就会将自己实例化。public class Singleton {    private static Singleton uniqueInstance = new Singleton();    private Singleton() {        // Exists only to defeat instantiation.    }    publ","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK中的设计模式","slug":"yuque/JDK中的设计模式","date":"2015-01-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-design-pattern.json","excerpt":"本文主要是归纳了 JDK中所包含的设计模式，包括作用和其设计类图。一、设计模式的作用 1. 反复出现问题的解决方案 2. 增强软件的灵活性 3. 适应软件不断变化二、设计模式的七大原则 1. 开闭原则 OCP（Open Close    Principle），一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 2. 里氏代换原则 LSP（Liskov    Substitution    Principle），子类可以扩展父类的功能，但不能改变父类原有的功能 3. 依赖倒转原则    DIP（Dependence    Inversion    ","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}]}