{"total":102,"pageSize":10,"pageCount":11,"data":[{"title":"MySQL B+树深度的了解","slug":"yuque/MySQL B+树深度的了解","date":"2019-05-26T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-btree-depth.json","excerpt":"> https://zhuanlan.zhihu.com/p/444448405以下从B+树深度简单模拟计算，有两个主要特征决定了B 树（或 B+ 树）的深度。 1. 数据库中的行数。我们将其称为 N。 2. 索引键的大小。让我们称 B 为适合 B    树节点的键数。（有时 B    用于指代节点大小本身，而不是它持有的键数，但我希望这样看起来更直观。）给定这些数量，B 树的深度是 log B为下标 N。那只是 (log N)/logB。现在我们可以注意到小键意味着更大的B，这会减少 (log N )/logB。如果我们将键的字节大小减半，那么 B树的深度将","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]},{"title":"MySQL表碎片","slug":"yuque/MySQL表碎片","date":"2019-05-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-table-fragmentation.json","excerpt":"> 原文链接：> https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/当心批量插入失败或者回滚时带来的MySQL 表碎片，通常，DBA都了解使用 DELETE语句会产生表碎片。在大多数情况下，当执行大量的删除时，DBA总会重新构建表以回收磁盘空间。但是，您是否认为只有删除才会导致表碎片？（答案：并不是）。在这篇博文中，我将解释插入如何会带来碎片。在讨论这个主题之前，我们需要了解MySQL，有两种碎片：","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]},{"title":"MVCC多版本并发控制","slug":"yuque/MVCC多版本并发控制","date":"2019-05-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-mvcc.json","excerpt":"https://cloud.tencent.com/developer/article/1488871https://zhuanlan.zhihu.com/p/40208895https://blog.csdn.net/u014532775/article/details/107018538https://www.jianshu.com/p/0ef46997c300https://blog.csdn.net/fuzhongmin05/article/details/91351933redolog 和 undologhttps://www.cnblogs.com/f-ck-need","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]},{"title":"InnoDB中的页合并与分裂","slug":"yuque/InnoDB中的页合并与分裂","date":"2019-03-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-page-merge-and-split.json","excerpt":"原文链接：https://www.percona.com/blog/2017/04/10/innodb-page-merging-and-page-splitting/https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/如果您遇到了全球（为数不多的）MySQL顾问之一并要求他/她审查您的查询和/或模式，我相信他/她会告诉您有关良好主键设计的重要性的一些信息.特别是在 InnoDB的情况下，我相信他们已经开始向","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]},{"title":"Spring Bean的生命周期","slug":"yuque/Spring Bean的生命周期","date":"2018-07-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/spring/spring-bean-lifecycle.json","excerpt":"要彻底搞清楚 Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应构造方法和setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段。 1. 实例化->Instantiation 2. 属性赋值->Populate 3. 初始化->Initialization 4. 销毁->Destruction实例化 -> 属性赋值 -> 初始化-> 销毁1、影响多个 Bean 的接口实现了这些接口的 Bean 会切入到多个Bean的生命周期中。正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"spring","path":"api/categories/spring.json"}],"tags":[{"name":"Spring","path":"api/tags/Spring.json"}]},{"title":"Spock 基于BDD测试","slug":"yuque/Spock 基于BDD测试","date":"2018-07-14T16:00:00.000Z","updated":"2022-09-09T13:07:16.842Z","comments":true,"path":"api/articles/spock.json","excerpt":"> Spock 测试框架基于 Groovy> 并吸收了> Junit、TestNG、Mockito> 等测试框架的优点。 Spock> 编写的单元测试层次清晰，代码量少，可读性好，Groovy> 最终会编译为 class> 文件，支持各种集成开发环境（eclipse，Intellij> Ieda）， 尤其是 Intellij> idea 已经集成支持 Groovy> 的插件，也支持> maven-surefire-plugin、jacoco> 等 maven 插件。Spock 官网，必读书籍《JavaTesting with Spock》,如要速成只需要阅读以下","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"spock","path":"api/categories/spock.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Spock","path":"api/tags/Spock.json"}]},{"title":"Docker（二）使用Swarm Mode创建集群","slug":"yuque/Docker（二）使用Swarm Mode创建集群","date":"2018-07-11T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/docker/docker-warm-mode.json","excerpt":"> 能使用 Docker Machine> 的前提是宿主机需要是物理机，云主机目前不支持> Docker Machine 的创建。Virtualbox 安装步骤可参考cd /etc/yum.repos.dwget http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repoyum install VirtualBox-5.2Docker Machine 安装命令行安装 docker-machinebase=https://github.com/docker/machine/releas","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"docker","path":"api/categories/docker.json"}],"tags":[{"name":"Docker","path":"api/tags/Docker.json"}]},{"title":"Docker（一）基本命令","slug":"yuque/Docker（一）基本命令","date":"2018-01-29T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/docker/docker-command.json","excerpt":"Docker 基本服务命令启动 docker$ service docker start重启 docker$ service docker restart停止 docker$ service docker stopdocker 自启动让它随服务器的启动而自动运行$ update-rc.d docker defaults$ systemctl enable dockerDocker 基础命令启动/停止/重启/杀掉容器docker start/stop/restart/kill实例操作如下：$ docker start myweb","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"docker","path":"api/categories/docker.json"}],"tags":[{"name":"Docker","path":"api/tags/Docker.json"}]},{"title":"MySQL死锁分析","slug":"yuque/MySQL死锁分析","date":"2018-01-29T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-deadlock.json","excerpt":"背景以前接触到的数据库死锁，都是批量更新时加锁顺序不一致而导致的死锁，但是上周却遇到了一个很难理解的死锁。借着这个机会又重新学习了一下mysql的死锁知识以及常见的死锁场景。在多方调研以及和同事们的讨论下终于发现了这个死锁问题的成因，收获颇多。虽然是后端程序员，我们不需要像DBA一样深入地去分析与锁相关的源码，但是如果我们能够掌握基本的死锁排查方法，对我们的日常开发还是大有裨益的。PS：本文不会介绍死锁的基本知识，mysql的加锁原理可以参考本文的参考资料提供的链接。死锁起因先介绍一下数据库和表情况，因为涉及到公司内部真是的数据，所以以下都做了模拟，不会影响具体的分析","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"Deadlock","path":"api/tags/Deadlock.json"}]},{"title":"MySQL事务和隔离级别","slug":"yuque/MySQL事务和隔离级别","date":"2018-01-28T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-transaction.json","excerpt":"1、数据库事务 ACID 特性数据库事务的 4 个特性： * 原子性(Atomicity)事务中的多个操作，不可分割，要么都成功，要么都失败，事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。 * 一致性(Consistency)事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。 * 隔离性(Isola","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"}]}]}