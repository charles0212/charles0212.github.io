{"total":98,"pageSize":10,"pageCount":10,"data":[{"title":"Spring Bean的生命周期","slug":"yuque/Spring Bean的生命周期","date":"2018-07-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.497Z","comments":true,"path":"api/articles/spring/spring-bean-lifecycle.json","excerpt":"要彻底搞清楚 Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应构造方法和setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段。 1. 实例化->Instantiation 2. 属性赋值->Populate 3. 初始化->Initialization 4. 销毁->Destruction实例化 -> 属性赋值 -> 初始化-> 销毁1、影响多个 Bean 的接口实现了这些接口的 Bean 会切入到多个Bean的生命周期中。正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"spring","path":"api/categories/spring.json"}],"tags":[{"name":"Spring","path":"api/tags/Spring.json"}]},{"title":"Spock 基于BDD测试","slug":"yuque/Spock 基于BDD测试","date":"2018-07-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.500Z","comments":true,"path":"api/articles/spock.json","excerpt":"> Spock 测试框架基于 Groovy> 并吸收了> Junit、TestNG、Mockito> 等测试框架的优点。 Spock> 编写的单元测试层次清晰，代码量少，可读性好，Groovy> 最终会编译为 class> 文件，支持各种集成开发环境（eclipse，Intellij> Ieda）， 尤其是 Intellij> idea 已经集成支持 Groovy> 的插件，也支持> maven-surefire-plugin、jacoco> 等 maven 插件。Spock 官网，必读书籍《JavaTesting with Spock》,如要速成只需要阅读以下","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"spock","path":"api/categories/spock.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Spock","path":"api/tags/Spock.json"}]},{"title":"Docker（二）使用Swarm Mode创建集群","slug":"yuque/Docker（二）使用Swarm Mode创建集群","date":"2018-07-11T16:00:00.000Z","updated":"2022-05-15T04:19:28.498Z","comments":true,"path":"api/articles/docker/docker-warm-mode.json","excerpt":"> 能使用 Docker Machine> 的前提是宿主机需要是物理机，云主机目前不支持> Docker Machine 的创建。Virtualbox 安装步骤可参考cd /etc/yum.repos.dwget http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repoyum install VirtualBox-5.2Docker Machine 安装命令行安装 docker-machinebase=https://github.com/docker/machine/releas","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"docker","path":"api/categories/docker.json"}],"tags":[{"name":"Docker","path":"api/tags/Docker.json"}]},{"title":"Docker（一）基本命令","slug":"yuque/Docker（一）基本命令","date":"2018-01-29T16:00:00.000Z","updated":"2022-05-15T04:19:28.498Z","comments":true,"path":"api/articles/docker/docker-command.json","excerpt":"Docker 基本服务命令启动 docker$ service docker start重启 docker$ service docker restart停止 docker$ service docker stopdocker 自启动让它随服务器的启动而自动运行$ update-rc.d docker defaults$ systemctl enable dockerDocker 基础命令启动/停止/重启/杀掉容器docker start/stop/restart/kill实例操作如下：$ docker start myweb","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"docker","path":"api/categories/docker.json"}],"tags":[{"name":"Docker","path":"api/tags/Docker.json"}]},{"title":"MySQL死锁分析","slug":"yuque/MySQL死锁分析","date":"2018-01-29T16:00:00.000Z","updated":"2022-05-15T04:19:28.494Z","comments":true,"path":"api/articles/mysql/mysql-deadlock.json","excerpt":"背景以前接触到的数据库死锁，都是批量更新时加锁顺序不一致而导致的死锁，但是上周却遇到了一个很难理解的死锁。借着这个机会又重新学习了一下mysql的死锁知识以及常见的死锁场景。在多方调研以及和同事们的讨论下终于发现了这个死锁问题的成因，收获颇多。虽然是后端程序员，我们不需要像DBA一样深入地去分析与锁相关的源码，但是如果我们能够掌握基本的死锁排查方法，对我们的日常开发还是大有裨益的。PS：本文不会介绍死锁的基本知识，mysql的加锁原理可以参考本文的参考资料提供的链接。死锁起因先介绍一下数据库和表情况，因为涉及到公司内部真是的数据，所以以下都做了模拟，不会影响具体的分析","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"Deadlock","path":"api/tags/Deadlock.json"}]},{"title":"MySQL事务和隔离级别","slug":"yuque/MySQL事务和隔离级别","date":"2018-01-28T16:00:00.000Z","updated":"2022-05-15T04:19:28.493Z","comments":true,"path":"api/articles/mysql/mysql-transaction.json","excerpt":"1、数据库事务 ACID 特性数据库事务的 4 个特性： * 原子性(Atomicity)事务中的多个操作，不可分割，要么都成功，要么都失败，事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。 * 一致性(Consistency)事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。 * 隔离性(Isola","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"}]},{"title":"Disruptor（五）DSL相关实战","slug":"yuque/Disruptor（五）DSL相关实战","date":"2017-03-09T16:00:00.000Z","updated":"2022-05-15T04:19:28.490Z","comments":true,"path":"api/articles/disruptor/disruptor-practise.json","excerpt":"本文主要讲解使用 Disruptor 的DSL演示生产者和消费者的数据交换，和以往的线程间通信不同，disruptor使用消息传递的方式，通过RingBuffer进行线程间的数据传递和通信，下面分别从一对一和多对一的模型进行讲解。下面主要通过计算区间[0 ,100000000)中的所有数值相加为例子讲解Disruptor 中的 dsl 使用。1、一对一一个生产者和一个消费者之间进行数据传递，使用disruptor 主要涉及到RingBuffer 中的ValueEvent定义，ValueAdditionEventHandler消费者处理，以及生产者发布。","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（四）RingBuffer多生产者写入","slug":"yuque/Disruptor（四）RingBuffer多生产者写入","date":"2017-03-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-muti-write.json","excerpt":"上一章主要介绍了单个生产者如何向RingBuffer数据写入数据，如何不要让 Ring重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作，本章主要介绍多生产者向RingBuffer 数据写入数据。1、多生产者MultiProducerSequencer申请下一个节点和单生产者不同的是在 next方法中会直接通过cursor.compareAndSet(current,next)设置生产者的游标 cursor的sequence。大家很可能会问设置了生产者的游标后，没有提交数据之前，多生产者场景中消费者是否就能够获取到数据，答案是否定的，在M","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（三）RingBuffer单生产者写入","slug":"yuque/Disruptor（三）RingBuffer单生产者写入","date":"2017-02-15T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-single-write.json","excerpt":"上一章主要介绍了消费者从RingBuffer读取数据，本章主要介绍单个生产者如何向RingBuffer 数据写入数据。在RingBuffer数据写入过程中如何不要让 Ring重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作。在 RingBuffer写入数据的过程涉及到两阶段提交(two-phasecommit)1）生产者需要申请 buffer里的下一个节点。2）当生产者向节点写完数据，需要调用调用publish 发布数据。1、单个生产者SingleProducerSequencer数据写入在后台由ProducerSequencer","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（二）RingBuffer读取","slug":"yuque/Disruptor（二）RingBuffer读取","date":"2016-12-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.491Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-read.json","excerpt":"上一章主要介绍 Ring Buffer的数据结构，本章主要讲解如何使用Disruptor 从 RingBuffer 中读取数据。1、消费者通过ProcessingSequenceBarrier读取数据能够读取数据的前提是数据已经写入到Ring Buffer中，关于数据的写入，后面一章节会详细讲解。RingBuffer 的元素的大小是 2的 n 次方（上面ringBufferSize 为8，从序号 0开始）。消费者(Consumer)是一个想从RingBuffer里读取数据的线程，它可以通过访问ProcessingSequenceBarrier对象和 ","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]}]}