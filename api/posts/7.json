{"total":102,"pageSize":10,"pageCount":11,"data":[{"title":"Disruptor（五）DSL相关实战","slug":"yuque/Disruptor（五）DSL相关实战","date":"2017-03-09T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-practise.json","excerpt":"本文主要讲解使用 Disruptor 的DSL演示生产者和消费者的数据交换，和以往的线程间通信不同，disruptor使用消息传递的方式，通过RingBuffer进行线程间的数据传递和通信，下面分别从一对一和多对一的模型进行讲解。下面主要通过计算区间[0 ,100000000)中的所有数值相加为例子讲解Disruptor 中的 dsl 使用。1、一对一一个生产者和一个消费者之间进行数据传递，使用disruptor 主要涉及到RingBuffer 中的ValueEvent定义，ValueAdditionEventHandler消费者处理，以及生产者发布。","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（四）RingBuffer多生产者写入","slug":"yuque/Disruptor（四）RingBuffer多生产者写入","date":"2017-03-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-muti-write.json","excerpt":"上一章主要介绍了单个生产者如何向RingBuffer数据写入数据，如何不要让 Ring重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作，本章主要介绍多生产者向RingBuffer 数据写入数据。1、多生产者MultiProducerSequencer申请下一个节点和单生产者不同的是在 next方法中会直接通过cursor.compareAndSet(current,next)设置生产者的游标 cursor的sequence。大家很可能会问设置了生产者的游标后，没有提交数据之前，多生产者场景中消费者是否就能够获取到数据，答案是否定的，在M","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（三）RingBuffer单生产者写入","slug":"yuque/Disruptor（三）RingBuffer单生产者写入","date":"2017-02-15T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-single-write.json","excerpt":"上一章主要介绍了消费者从RingBuffer读取数据，本章主要介绍单个生产者如何向RingBuffer 数据写入数据。在RingBuffer数据写入过程中如何不要让 Ring重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作。在 RingBuffer写入数据的过程涉及到两阶段提交(two-phasecommit)1）生产者需要申请 buffer里的下一个节点。2）当生产者向节点写完数据，需要调用调用publish 发布数据。1、单个生产者SingleProducerSequencer数据写入在后台由ProducerSequencer","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（二）RingBuffer读取","slug":"yuque/Disruptor（二）RingBuffer读取","date":"2016-12-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-read.json","excerpt":"上一章主要介绍 Ring Buffer的数据结构，本章主要讲解如何使用Disruptor 从 RingBuffer 中读取数据。1、消费者通过ProcessingSequenceBarrier读取数据能够读取数据的前提是数据已经写入到Ring Buffer中，关于数据的写入，后面一章节会详细讲解。RingBuffer 的元素的大小是 2的 n 次方（上面ringBufferSize 为8，从序号 0开始）。消费者(Consumer)是一个想从RingBuffer里读取数据的线程，它可以通过访问ProcessingSequenceBarrier对象和 ","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（一）RingBuffer数据结构","slug":"yuque/Disruptor（一）RingBuffer数据结构","date":"2016-09-19T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer.json","excerpt":"> Disruptor 是 LMAX> 公司开源的一个高效的内存无锁队列。并发程序设计几个概念1、锁：锁是用来做并发最简单的方式，当然其代价也是最高的。内核态的锁的时候需要操作系统进行一次上下文切换，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。用户态的锁虽然避免了这些问题，但是其实它们只是在没有真实的竞争时才有效。2、CAS： CAS的涵义不多介绍了。使用 CAS时不像上锁那样需要一次上下文切换，但是也需要处理器锁住它的指令流水线来保证原子性，并且还要加上Memory Barrier来保证其结果可见。3","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"深入理解Disruptor","slug":"yuque/深入理解Disruptor","date":"2016-09-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/understanding-disruptor.json","excerpt":"> Disruptor 是 LMAX> 公司开源的一个高效的内存无锁队列，一个高性能的异步处理框架，或者可以认为是最快的消息框架(轻量的> JMS)，也可以认为是一个观察者模式实现，或者事件-监听模式的实现，直接称> disruptor> 模式。disruptor> 最大特点是高性能，其 LMAX> 架构可以获得每秒 6 百万订单，用 1> 微秒的延迟获得吞吐量为 100K+。理解> Disruptor> 的原理，可以帮助我们更好的理解内存无锁，CAS，volatile，缓冲行等并发原理。本文主要从以下方面介绍disruptor：1、Disruptor 概念和Rin","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Netty（一）网络IO基础","slug":"yuque/Netty（一）网络IO基础","date":"2016-08-27T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/netty/netty-io-basic.json","excerpt":"在讨论 IO的时候，参与者通常有两个角色：系统内核和用户进程。用户进程发送IO 请求过后，系统内核在准备好 IO数据后，会通过内存拷贝的方式，将准备好的缓存IO 数据共享给用户进程缓存。网络 I/O 模型简介根据 UNIX 网络编程对 I/O模型的分类，提供了阻塞 I/O模型、非阻塞 I/O 模型、I/O复用模型、信号驱动 I/O 模型、异步I/O 这 5 种 I/O 模型。1、阻塞 I/O 模型最常用的模型，所有文件操作都是阻塞的。套接字socket 在进程空间中调用recvfrom，其系统调用直到数据包到达，且被复制到应用进程的缓冲区或者发生错误的时","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"netty","path":"api/categories/netty.json"}],"tags":[{"name":"Netty","path":"api/tags/Netty.json"}]},{"title":"JVM（七）深入理解java内存模型","slug":"yuque/JVM（七）深入理解java内存模型","date":"2016-08-06T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/java-memory-model.json","excerpt":"> java> 线程之间的通信对程序员完全透明，内存可见性问题很容易困扰> java 程序员，本文试图揭开 java> 内存模型神秘的面纱。本文大致分三部分：重排序与顺序一致性；三个同步原语（lock，volatile，final）的内存语义，重排序规则及在处理器中的实现；java内存模型的设计目标，及其与处理器内存模型和顺序一致性内存模型的关系。 * 深入理解 java   内存模型（一）——基础 * 深入理解 java   内存模型（二）——重排序 * 深入理解 java   内存模型（三）——顺序一致性 * 深入理解 java   内存模型（四）——v","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（五）虚拟机类加载机制","slug":"yuque/JVM（五）虚拟机类加载机制","date":"2016-08-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-classloader.json","excerpt":"Java提供了动态的装载特性；它会在运行时的第一次引用到一个class的时候对它进行装载和链接，而不是在编译期进行。JVM的类装载器负责动态装载，基本上所有的类加载器都是java.lang.ClassLoader类的一个实例。Java 类装载器有如下几个特点： * 层级结构：Java   里的类装载器被组织成了有父子关系的层级结构。Bootstrap   类装载器是所有装载器的父亲。 * 代理模式：基于层级结构，类的装载可以在装载器之间进行代理。当装载器装载一个类时，首先会检查它是否在父装载器中进行装载了。如果上层的装载器已经装载了这个类，这个类会被直接使用。反","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（六）虚拟机类加载委派模型","slug":"yuque/JVM（六）虚拟机类加载委派模型","date":"2016-08-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-classloader-delegate.json","excerpt":"双亲委派模型当一个类装载器（classloader）被请求装载类时，它首先按照顺序在上层装载器、父装载器以及自身的装载器的缓存里检查这个类是否已经存在。简单来说，就是在缓存里查看这个类是否已经被自己装载过了，如果没有的话，继续查找父类的缓存，直到在bootstrap类装载器里也没有找到的话，它就会自己在文件系统里去查找并且加载这个类。ClassLoader 的loadClass 方法protected Class loadClass(String name, boolean resolve)            throws ClassNotFoundExcepti","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]}]}