{"total":99,"pageSize":10,"pageCount":10,"data":[{"title":"Disruptor（二）RingBuffer读取","slug":"yuque/Disruptor（二）RingBuffer读取","date":"2016-12-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-read.json","excerpt":"上一章主要介绍 Ring Buffer的数据结构，本章主要讲解如何使用Disruptor 从 RingBuffer 中读取数据。1、消费者通过ProcessingSequenceBarrier读取数据能够读取数据的前提是数据已经写入到Ring Buffer中，关于数据的写入，后面一章节会详细讲解。RingBuffer 的元素的大小是 2的 n 次方（上面ringBufferSize 为8，从序号 0开始）。消费者(Consumer)是一个想从RingBuffer里读取数据的线程，它可以通过访问ProcessingSequenceBarrier对象和 ","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（一）RingBuffer数据结构","slug":"yuque/Disruptor（一）RingBuffer数据结构","date":"2016-09-19T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer.json","excerpt":"> Disruptor 是 LMAX> 公司开源的一个高效的内存无锁队列。并发程序设计几个概念1、锁：锁是用来做并发最简单的方式，当然其代价也是最高的。内核态的锁的时候需要操作系统进行一次上下文切换，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。用户态的锁虽然避免了这些问题，但是其实它们只是在没有真实的竞争时才有效。2、CAS： CAS的涵义不多介绍了。使用 CAS时不像上锁那样需要一次上下文切换，但是也需要处理器锁住它的指令流水线来保证原子性，并且还要加上Memory Barrier来保证其结果可见。3","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"深入理解Disruptor","slug":"yuque/深入理解Disruptor","date":"2016-09-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/understanding-disruptor.json","excerpt":"> Disruptor 是 LMAX> 公司开源的一个高效的内存无锁队列，一个高性能的异步处理框架，或者可以认为是最快的消息框架(轻量的> JMS)，也可以认为是一个观察者模式实现，或者事件-监听模式的实现，直接称> disruptor> 模式。disruptor> 最大特点是高性能，其 LMAX> 架构可以获得每秒 6 百万订单，用 1> 微秒的延迟获得吞吐量为 100K+。理解> Disruptor> 的原理，可以帮助我们更好的理解内存无锁，CAS，volatile，缓冲行等并发原理。本文主要从以下方面介绍disruptor：1、Disruptor 概念和Rin","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Netty（一）网络IO基础","slug":"yuque/Netty（一）网络IO基础","date":"2016-08-27T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/netty/netty-io-basic.json","excerpt":"在讨论 IO的时候，参与者通常有两个角色：系统内核和用户进程。用户进程发送IO 请求过后，系统内核在准备好 IO数据后，会通过内存拷贝的方式，将准备好的缓存IO 数据共享给用户进程缓存。网络 I/O 模型简介根据 UNIX 网络编程对 I/O模型的分类，提供了阻塞 I/O模型、非阻塞 I/O 模型、I/O复用模型、信号驱动 I/O 模型、异步I/O 这 5 种 I/O 模型。1、阻塞 I/O 模型最常用的模型，所有文件操作都是阻塞的。套接字socket 在进程空间中调用recvfrom，其系统调用直到数据包到达，且被复制到应用进程的缓冲区或者发生错误的时","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"netty","path":"api/categories/netty.json"}],"tags":[{"name":"Netty","path":"api/tags/Netty.json"}]},{"title":"JVM（七）深入理解java内存模型","slug":"yuque/JVM（七）深入理解java内存模型","date":"2016-08-06T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/java-memory-model.json","excerpt":"> java> 线程之间的通信对程序员完全透明，内存可见性问题很容易困扰> java 程序员，本文试图揭开 java> 内存模型神秘的面纱。本文大致分三部分：重排序与顺序一致性；三个同步原语（lock，volatile，final）的内存语义，重排序规则及在处理器中的实现；java内存模型的设计目标，及其与处理器内存模型和顺序一致性内存模型的关系。 * 深入理解 java   内存模型（一）——基础 * 深入理解 java   内存模型（二）——重排序 * 深入理解 java   内存模型（三）——顺序一致性 * 深入理解 java   内存模型（四）——v","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（五）虚拟机类加载机制","slug":"yuque/JVM（五）虚拟机类加载机制","date":"2016-08-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-classloader.json","excerpt":"Java提供了动态的装载特性；它会在运行时的第一次引用到一个class的时候对它进行装载和链接，而不是在编译期进行。JVM的类装载器负责动态装载，基本上所有的类加载器都是java.lang.ClassLoader类的一个实例。Java 类装载器有如下几个特点： * 层级结构：Java   里的类装载器被组织成了有父子关系的层级结构。Bootstrap   类装载器是所有装载器的父亲。 * 代理模式：基于层级结构，类的装载可以在装载器之间进行代理。当装载器装载一个类时，首先会检查它是否在父装载器中进行装载了。如果上层的装载器已经装载了这个类，这个类会被直接使用。反","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（六）虚拟机类加载委派模型","slug":"yuque/JVM（六）虚拟机类加载委派模型","date":"2016-08-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-classloader-delegate.json","excerpt":"双亲委派模型当一个类装载器（classloader）被请求装载类时，它首先按照顺序在上层装载器、父装载器以及自身的装载器的缓存里检查这个类是否已经存在。简单来说，就是在缓存里查看这个类是否已经被自己装载过了，如果没有的话，继续查找父类的缓存，直到在bootstrap类装载器里也没有找到的话，它就会自己在文件系统里去查找并且加载这个类。ClassLoader 的loadClass 方法protected Class loadClass(String name, boolean resolve)            throws ClassNotFoundExcepti","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（四）类文件结构解析","slug":"yuque/JVM（四）类文件结构解析","date":"2016-07-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-class.json","excerpt":"Java Class 文件结构如下图所示对于以下 java 源文件代码public class Charles implements ICharles{  private String name;  public void say() {    System.out.println(\"charles\");  }  public String getName() {    return name;  }  public void setName(String name) {    this.name = name;  }}生成的类文件字节码为根据 cla","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（三）内存分配与回收策略","slug":"yuque/JVM（三）内存分配与回收策略","date":"2016-07-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-gc-allocation.json","excerpt":"对象的分配的细节取决于当前使用哪一种垃圾收集器组合，以及和内存相关参数有关，本文主要讨论Serial/SerialOld收集器的内存分配和回收的策略，其他几种垃圾收集器可以自己去探讨。先介绍下 MinorGC 和FullGC 的概念。新生代 GC（MinorGC）:发生在新生代，Java对象大多都有朝生夕死的特性，MinorGC非常频繁，回收速度也比较快。老年代GC（MajorGC/FullGC）:发生在老年代，出现 MajorGC经常至少伴随一次的MinorGC，但非绝对。MajorGC的速度一般比 MinorGC 慢 10倍以上。下面是最普遍的内存分配规则","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"Service Mesh概述","slug":"yuque/Service Mesh概述","date":"2016-06-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/cncf/service-mesh.json","excerpt":"> 关于 ServiceMesh> 相关知识和进展，推荐资深大牛敖小剑的相关文章> https://skyao.io/> ServiceMesh 的社区网站> http://www.servicemesher.com/> 最近蚂蚁金服开源了分布式框架> SOFA，项目地址> Alipay，具体文档可见 Sofa> 关于 Sofa Mesh,> 暂时未开源，相关选型介绍可见 Sofa> Mesh一、 Service Mesh概念与定义这个概念首先由 Linkerd的团队提出，其官方定义是:> A service mesh is a> dedicated>","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"cncf","path":"api/categories/cncf.json"}],"tags":[{"name":"CNCF","path":"api/tags/CNCF.json"},{"name":"ServiceMesh","path":"api/tags/ServiceMesh.json"}]}]}