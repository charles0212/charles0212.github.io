{"total":102,"pageSize":10,"pageCount":11,"data":[{"title":"Redis大Value","slug":"yuque/Redis大Value","date":"2021-06-20T16:00:00.000Z","updated":"2022-04-02T16:49:05.000Z","comments":true,"path":"api/articles/cache/redis-large-value.json","excerpt":"大 key 和大 value的危害，如何处理Redis 的大 key 有什么危害？一个 key 的 value较大时的情况，比如： * 内存不均：单 value   较大时，可能会导致节点之间的内存使用不均匀，间接地影响   key 的部分和负载不均匀； * 阻塞请求：redis 为单线程，单   value   较大读写需要较长的处理时间，会阻塞后续的请求处理； * 阻塞网络：单 value   较大时会占用服务器网卡较多带宽，可能会影响该服务器上的其他   Redis 实例或者应用。虽说答的是挺好的，但是我又随之产生了另一个疑惑，如果redis 的 ke","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"HBase LSM树","slug":"yuque/HBase LSM树","date":"2021-06-19T16:00:00.000Z","updated":"2022-04-02T16:49:05.000Z","comments":true,"path":"api/articles/hbase/hbase-lsm.json","excerpt":"> https://zhuanlan.zhihu.com/p/181498475LSM树(Log-Structured-Merge-Tree)的名字往往会给初识者一个错误的印象，事实上，LSM树并不像B+树、红黑树一样是一颗严格的树状数据结构，它其实是一种存储结构，目前HBase、LevelDB、RocksDB这些 NoSQL 存储都是采用的 LSM树。LSM树的核心特点是利用顺序写来提高写性能，但因为分层(此处分层是指的分为内存和文件两部分)的设计会稍微降低读性能，但是通过牺牲小部分读性能换来高性能写，使得LSM 树成为非常流行的存储结构。数据库存储有两种数据结构，一","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"hbase","path":"api/categories/hbase.json"}],"tags":[{"name":"HBase","path":"api/tags/HBase.json"}]},{"title":"Hive文件格式","slug":"yuque/Hive文件格式","date":"2021-06-19T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/hive/hive-file-format.json","excerpt":"一、文件定义ORC File，它的全名是Optimized RowColumnar (ORC)file，其实就是对 RCFile做了一些优化。据官方文档介绍，这种文件格式可以提供一种高效的方法来存储Hive 数据。它的设计目标是来克服Hive 其他格式的缺陷。运用 ORC File 可以提高Hive 的读、写以及处理数据的性能。和 RCFile 格式相比，ORCFile 格式有以下优点：1、每个 task只输出单个文件，这样可以减少NameNode 的负载；2、支持各种复杂的数据类型，比如：datetime, decimal,以及一些复杂类型 struct","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"hive","path":"api/categories/hive.json"}],"tags":[{"name":"Hive","path":"api/tags/Hive.json"}]},{"title":"设计模式与GO","slug":"yuque/设计模式与GO","date":"2021-05-31T16:00:00.000Z","updated":"2022-05-15T04:55:51.000Z","comments":true,"path":"api/articles/design-pattern/go-design-pattern.json","excerpt":"> 原文链接：https://refactoringguru.cn/design-patterns/go> 代码可见：https://github.com/charles0212/design-patterns创建型模式创建型模式 模式描述 抽象工厂AbstractFactory，让你能创建一系列相关的对象，而无需指定其具体类。 生成器Builder，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。工厂方法 FactoryMethod，在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。原型Prototype，让你","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"设计模式","path":"api/tags/设计模式.json"},{"name":"Go","path":"api/tags/Go.json"}]},{"title":"Nacos2架构设计","slug":"yuque/Nacos2架构设计","date":"2021-03-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/nacos/nacos-architecture.json","excerpt":"> https://blog.csdn.net/alisystemsoftware/article/details/111934889Nacos 在阿里巴巴起源于 2008年五彩石项目，该项目完成了微服务拆分和业务中台建设，随着云计算和开源环境的兴起，2018年我们深刻感受到开源软件行业的影响，因此决定将Nacos开源，输出阿里十年关于服务发现和配管管理的沉淀，推动微服务行业发展，加速企业数字化转型。目前 Nacos 支持主流微服务开发语言& 主流服务框架和配置管理框架，比如支持Duboo 和 SCA，还对接了一些云原生的组件比如coreDNS 和 sentinel等。","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"nacos","path":"api/categories/nacos.json"}],"tags":[{"name":"Nacos","path":"api/tags/Nacos.json"}]},{"title":"Nacos2动态配置","slug":"yuque/Nacos2动态配置","date":"2021-03-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/nacos/nacos-config.json","excerpt":"> https://zhuanlan.zhihu.com/p/375912272> >> https://www.pianshen.com/article/4989271413/> Nacos 配置实时更新原理分析> https://www.jianshu.com/p/acb9b1093a54动态配置场景了解了动态配置管理的效果之后，我们知道了大概的原理了，Nacos服务端保存了配置信息，客户端连接到服务端之后，根据dataID，group可以获取到具体的配置信息，当服务端的配置发生变更时，客户端会收到通知。当客户端拿到变更后的最新配置信息后，就可以做自己的处理了，这非","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"nacos","path":"api/categories/nacos.json"}],"tags":[{"name":"Nacos","path":"api/tags/Nacos.json"}]},{"title":"Nacos简介","slug":"yuque/Nacos简介","date":"2021-03-19T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/nacos/nacos.json","excerpt":"> https://zhuanlan.zhihu.com/p/375912272> >> https://www.cnblogs.com/crazymakercircle/p/14231815.html1、Nacos 优势问题，既然有了 Eureka，为啥还要用 Nacos？而 Nacos作为微服务核心的服务注册与发现中心，让大家在Eureka 和 Consule之外有了新的选择，开箱即用，上手简洁，暂时也没发现有太大的坑。1.1、与 eureka 对比 * eureka 2.0 闭源码了 * 从官网来看 nacos   的注册的实例数是大于 eureka","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"nacos","path":"api/categories/nacos.json"}],"tags":[{"name":"Nacos","path":"api/tags/Nacos.json"}]},{"title":"Etcd Watch机制","slug":"yuque/Etcd Watch机制","date":"2020-08-20T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/etcd/etcd-watch.json","excerpt":"watch 是 mvcc包中的一个功能，之所以拿出来说，是因为它确实有很重的逻辑。watch是监听一个或一组 key，key的任何变化都会发出消息。某种意义上讲，这就是发布订阅模式。https://segmentfault.com/a/1190000021787055对比既然 Watch机制就是发布订阅模式，我们通过对比Kafka，来更深入了解 Watch。首先说明结论：ETCD没有消费者组的概念，所以不能代替Kafka对比其他方面呢：ETCD Kafka 消费方式 监听一个Key 订阅一个 Topic 生产方式Put(Key, Value)Produc","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"etcd","path":"api/categories/etcd.json"}],"tags":[{"name":"Etcd","path":"api/tags/Etcd.json"}]},{"title":"分布式一致性Raft算法","slug":"yuque/分布式一致性Raft算法","date":"2020-08-20T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/raft.json","excerpt":"> 本文是转载的论文翻译，Raft> 算法是可以用来替代 Paxos> 算法的分布式一致性算法， 而且 raft> 算法比 Paxos> 算法更易懂且更容易实现。本文对 raft> 论文进行翻译，希望能有助于读者更方便地理解> raft 的思想。摘要Raft是用来管理复制日志（replicatedlog）的一致性协议。它跟multi-Paxos作用相同，效率也相当，但是它的组织结构跟Paxos 不同。 这使得 Raft 比Paxos更容易理解并且更容易在工程实践中实现。为了使Raft 协议更易懂，Raft将一致性的关键元素分开， 如leader选举、","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"raft","path":"api/categories/raft.json"}],"tags":[{"name":"Raft","path":"api/tags/Raft.json"}]},{"title":"Redis（八）Zset结构和跳表SkipList","slug":"yuque/Redis（八）Zset结构和跳表SkipList","date":"2020-07-27T16:00:00.000Z","updated":"2022-09-09T13:07:16.843Z","comments":true,"path":"api/articles/redis/redis-zset.json","excerpt":"zset 是 redis中一种有序、不重复的数据类型，每个元素都有一个分值，它可用于实现排行榜单，其底层采用压缩表ziplist 或跳表 skiplist的数据结构实现Zset 的两种数据结构压缩表 ziplist当 redis插入第一个元素时，同时满足以下条件，就会以ziplist 创建跳表 1. 节点数量<128 （可通过    server.zset_max_ziplist_entries    设置） 2. 节点的长度<64（可通过    server.zset_max_ziplist_value    设置）当选择用 ziplist 实现 ","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]}]}