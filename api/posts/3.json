{"total":98,"pageSize":10,"pageCount":10,"data":[{"title":"设计模式与GO","slug":"yuque/设计模式与GO","date":"2021-05-31T16:00:00.000Z","updated":"2022-05-15T04:55:51.836Z","comments":true,"path":"api/articles/design-pattern/go-design-pattern.json","excerpt":"> 原文链接：https://refactoringguru.cn/design-patterns/go> 代码可见：https://github.com/charles0212/design-patterns创建型模式创建型模式 模式描述 抽象工厂AbstractFactory，让你能创建一系列相关的对象，而无需指定其具体类。 生成器Builder，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。工厂方法 FactoryMethod，在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。原型Prototype，让你","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"设计模式","path":"api/tags/设计模式.json"},{"name":"Go","path":"api/tags/Go.json"}]},{"title":"Nacos2架构设计","slug":"yuque/Nacos2架构设计","date":"2021-03-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.495Z","comments":true,"path":"api/articles/nacos/nacos-architecture.json","excerpt":"> https://blog.csdn.net/alisystemsoftware/article/details/111934889Nacos 在阿里巴巴起源于 2008年五彩石项目，该项目完成了微服务拆分和业务中台建设，随着云计算和开源环境的兴起，2018年我们深刻感受到开源软件行业的影响，因此决定将Nacos开源，输出阿里十年关于服务发现和配管管理的沉淀，推动微服务行业发展，加速企业数字化转型。目前 Nacos 支持主流微服务开发语言& 主流服务框架和配置管理框架，比如支持Duboo 和 SCA，还对接了一些云原生的组件比如coreDNS 和 sentinel等。","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"nacos","path":"api/categories/nacos.json"}],"tags":[{"name":"Nacos","path":"api/tags/Nacos.json"}]},{"title":"Nacos2动态配置","slug":"yuque/Nacos2动态配置","date":"2021-03-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.495Z","comments":true,"path":"api/articles/nacos/nacos-config.json","excerpt":"> https://zhuanlan.zhihu.com/p/375912272> >> https://www.pianshen.com/article/4989271413/> Nacos 配置实时更新原理分析> https://www.jianshu.com/p/acb9b1093a54动态配置场景了解了动态配置管理的效果之后，我们知道了大概的原理了，Nacos服务端保存了配置信息，客户端连接到服务端之后，根据dataID，group可以获取到具体的配置信息，当服务端的配置发生变更时，客户端会收到通知。当客户端拿到变更后的最新配置信息后，就可以做自己的处理了，这非","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"nacos","path":"api/categories/nacos.json"}],"tags":[{"name":"Nacos","path":"api/tags/Nacos.json"}]},{"title":"Nacos简介","slug":"yuque/Nacos简介","date":"2021-03-19T16:00:00.000Z","updated":"2022-05-15T04:19:28.495Z","comments":true,"path":"api/articles/nacos/nacos.json","excerpt":"> https://zhuanlan.zhihu.com/p/375912272> >> https://www.cnblogs.com/crazymakercircle/p/14231815.html1、Nacos 优势问题，既然有了 Eureka，为啥还要用 Nacos？而 Nacos作为微服务核心的服务注册与发现中心，让大家在Eureka 和 Consule之外有了新的选择，开箱即用，上手简洁，暂时也没发现有太大的坑。1.1、与 eureka 对比 * eureka 2.0 闭源码了 * 从官网来看 nacos   的注册的实例数是大于 eureka","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"nacos","path":"api/categories/nacos.json"}],"tags":[{"name":"Nacos","path":"api/tags/Nacos.json"}]},{"title":"Etcd Watch机制","slug":"yuque/Etcd Watch机制","date":"2020-08-20T16:00:00.000Z","updated":"2022-05-15T04:19:28.496Z","comments":true,"path":"api/articles/etcd/etcd-watch.json","excerpt":"watch 是 mvcc包中的一个功能，之所以拿出来说，是因为它确实有很重的逻辑。watch是监听一个或一组 key，key的任何变化都会发出消息。某种意义上讲，这就是发布订阅模式。https://segmentfault.com/a/1190000021787055对比既然 Watch机制就是发布订阅模式，我们通过对比Kafka，来更深入了解 Watch。首先说明结论：ETCD没有消费者组的概念，所以不能代替Kafka对比其他方面呢：ETCD Kafka 消费方式 监听一个Key 订阅一个 Topic 生产方式Put(Key, Value)Produc","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"etcd","path":"api/categories/etcd.json"}],"tags":[{"name":"Etcd","path":"api/tags/Etcd.json"}]},{"title":"分布式一致性Raft算法","slug":"yuque/分布式一致性Raft算法","date":"2020-08-20T16:00:00.000Z","updated":"2022-05-15T04:19:28.498Z","comments":true,"path":"api/articles/raft.json","excerpt":"> 本文是转载的论文翻译，Raft> 算法是可以用来替代 Paxos> 算法的分布式一致性算法， 而且 raft> 算法比 Paxos> 算法更易懂且更容易实现。本文对 raft> 论文进行翻译，希望能有助于读者更方便地理解> raft 的思想。摘要Raft是用来管理复制日志（replicatedlog）的一致性协议。它跟multi-Paxos作用相同，效率也相当，但是它的组织结构跟Paxos 不同。 这使得 Raft 比Paxos更容易理解并且更容易在工程实践中实现。为了使Raft 协议更易懂，Raft将一致性的关键元素分开， 如leader选举、","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"raft","path":"api/categories/raft.json"}],"tags":[{"name":"Raft","path":"api/tags/Raft.json"}]},{"title":"Redis（七）大key和大value","slug":"yuque/Redis（七）大key和大value","date":"2020-06-26T16:00:00.000Z","updated":"2022-05-15T04:19:28.494Z","comments":true,"path":"api/articles/redis/redis-large-value.json","excerpt":"大 key 和大 value的危害，如何处理Redis 的大 key 有什么危害？一个 key 的 value较大时的情况，比如： * 内存不均：单 value   较大时，可能会导致节点之间的内存使用不均匀，间接地影响   key 的部分和负载不均匀； * 阻塞请求：redis 为单线程，单   value   较大读写需要较长的处理时间，会阻塞后续的请求处理； * 阻塞网络：单 value   较大时会占用服务器网卡较多带宽，可能会影响该服务器上的其他   Redis 实例或者应用。虽说答的是挺好的，但是我又随之产生了另一个疑惑，如果redis 的 ke","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（六）分布式锁","slug":"yuque/Redis（六）分布式锁","date":"2020-06-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.494Z","comments":true,"path":"api/articles/redis/redis-lock.json","excerpt":"> 分布式锁为解决分布式系统中多个应用同时访问同一个资源的问题。分布式锁的使用场景一般是在两个场景下会防止对同一个资源的重复访问 * 提升效率比如多个节点计算同一批任务，如果某个任务已经有节点在计算了，那其他节点就不用重复计算了，以免浪费计算资源。不过重复计算也没事，不会造成其他更大的损失，允许偶尔的失败。 * 保证正确性这种情况对锁的要求就很高了，如果重复计算，会对正确性造成影响，不允许失败。分布式锁支持的特性在这个技术不断更新迭代的情况下，分布式这个概念，在企业中的权重越来越高。谈及分布式时，不可避免一定会提到分布式锁，现阶段分布式锁的实现方式主流的有几","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（四）存储结构","slug":"yuque/Redis（四）存储结构","date":"2020-06-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.488Z","comments":true,"path":"api/articles/redis/redis-storage-structure.json","excerpt":"前言Redis作为一款高性能数据库，表现在：它接收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。其高性能得奥秘来缘于以下两点： * Redis 是内存数据库，   所有操作都在内存上完成，内存的访问速度本身就很快 * Reids   通过高效的数据结构来组织数据。本章节可以让你在最短的时间了解如下内容： * Redis 支持五大数据类型 * Redis 组织 Key-Value   数据结构 * Redis5 大值类型数据存储结构一、五大数据类型 * String(字符串) * List(列表) * Set(集合) * Hash","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]},{"title":"Redis（五）线程模型","slug":"yuque/Redis（五）线程模型","date":"2020-06-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.488Z","comments":true,"path":"api/articles/redis/redis-thread-model.json","excerpt":"一、Redis 有多快？Redis 是基于内存运行的高性能K-V数据库，官方提供的测试报告是单机可以支持约10w/s 的 QPS二、Redis 为什么这么快？（1）完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO 读取到内存这部分的开销。（2）数据结构简单，对数据操作也简单。Redis中的数据结构是专门进行设计的，每种数据结构都有一种或多种数据结构来支持。Redis正是依赖这些灵活的数据结构，来提升读取和写入的性能。（3）采用单线程，省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"cache","path":"api/categories/cache.json"},{"name":"redis","path":"api/categories/redis.json"}],"tags":[{"name":"Cache","path":"api/tags/Cache.json"},{"name":"Redis","path":"api/tags/Redis.json"}]}]}