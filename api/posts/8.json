{"total":99,"pageSize":10,"pageCount":10,"data":[{"title":"Cloud Native定义","slug":"yuque/Cloud Native定义","date":"2016-05-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/cncf/cloud-native.json","excerpt":"CNCF 定义CNCF（Cloud NativeComputingFoundation，云原生计算基金会），2016年 6 月 11 日，CNCF技术监督委员会经过几个月的讨论，终于投票通过了Cloud Native的定义，目前官方的翻译如下：> Cloud native> technologies empower> organizations to> build and run> scalable> applications in> modern, dynamic> environments such as> public, private, and> ","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"cncf","path":"api/categories/cncf.json"}],"tags":[{"name":"CNCF","path":"api/tags/CNCF.json"}]},{"title":"JVM（二）垃圾收集算法与收集器","slug":"yuque/JVM（二）垃圾收集算法与收集器","date":"2016-01-08T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-gc.json","excerpt":"Java 堆中几乎存放着 java中所有的对象实例，垃圾收集器在对堆进行回收前，需要确定哪些对象还”存活”着，哪些已经“死去”。垃圾回收必须能够完成两件事情：正确检测出垃圾对象；释放垃圾对象占用的空间。1、垃圾检测算法当前常见的检测垃圾的方法包括两种：1.引用计数法；2. 可达性分析算法。1.1 引用计数算法（ReferenceCounting）给对象添加一个引用计数器，每当该对象被引用，它的计数器值就＋1；当引用失效时，计数器就－1；在任何情况下，当计数器值为0 时，就表示该对象不再被使用。缺点：它很难解决对象之间相互引用，引起的循环引用问题，会产生无法被释放","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（一）Java内存区域与内存溢出","slug":"yuque/JVM（一）Java内存区域与内存溢出","date":"2016-01-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/java-oom.json","excerpt":"Java 内存区域Java虚拟机所管理的内存将包括以下几个运行时数据区域，如下图所示：程序计数器ProgramCounterRegister是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变程序计数器的值来选取下一条要执行的字节码指令，分支、循环、跳转、异常跳转、线程恢复等基础功能都需要依赖这个计数器来完成。由于 Java虚拟机的多线程时通过线程切换并分配处理器执行时间来实现的，对于单核处理器在某一个时间都只会有一个线程在运行，为了线程切换后能恢复到正确的执行位置，每个线程都需要维护一个独立的程序计数器，各个线程之","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JDK设计模式（十七）命令模式","slug":"yuque/JDK设计模式（十七）命令模式","date":"2015-11-15T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-command-pattern.json","excerpt":"1、概述命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。2、解决的问题用于“行为请求者”与“行为实现者”解耦，可实现二者之间的松耦合，以便适应变化。3、模式中的角色1、命令（Command）角色：定义命令的接口，声明执行的方法。2、具体命令（ConcreteCommand）角色：命令接口实现对象，通常它会持有命令的接收者，通过调用接收者相应的功能方法来执行当前命令所要完成的操作。3、接收者（Receiver）角色：真正执行命令的对象。任何类都可以成为一个接收者，只要它能够实现命令要求实现的相应功能即可。4","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十六）责任链模式","slug":"yuque/JDK设计模式（十六）责任链模式","date":"2015-11-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-responsibility-pattern.json","excerpt":"1、概述责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。2、解决的问题如果有多个对象都有可能接受请求，可以避免请求发送者与接收者耦合在一起。3、模式中的角色1、抽象处理者角色(Handler):定义一个处理请求的接口，和一个后继连接(可选)2、具体处理者角色(ConcreteHandler):处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。3、客户类(Client):向一个链上的具体处理者ConcreteHandler对象提","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十五）迭代器模式","slug":"yuque/JDK设计模式（十五）迭代器模式","date":"2015-11-12T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-iterator-pattern.json","excerpt":"1. 概述迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。2. 解决的问题把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所。3. 模式中的角色1、抽象迭代器(Iterator)：定义出遍历元素所需的接口。2、具体迭代器(ConcreteIterator)：实现Iterator接口，并保持迭代过程中的游标位置。3、聚集(Aggregate)：给出创建迭代器(Iterator)对象的接口。4、具体聚集(ConcreteAggregate)：实现创建迭代器(Iterator)对象的接口，返回一个合适","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十四）观察者模式","slug":"yuque/JDK设计模式（十四）观察者模式","date":"2015-11-06T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-observer-pattern.json","excerpt":"1. 概述有时被称作发布/订阅模式，观察者模式定义了对象之间的一对多的依赖关系，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。2. 解决的问题将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。3. 模式中的角色1、抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。2、具体主题（ConcreteS","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十三）模板方法模式","slug":"yuque/JDK设计模式（十三）模板方法模式","date":"2015-10-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-template-method-pattern.json","excerpt":"1、概述定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。2、模式中的角色抽象模板类（AbstractTemplate）：实现了模板方法，定义了算法的骨架。具体模板类（ConcreteTemplate)：实现抽象类中的抽象方法，已完成完整的算法。3、模式解读模板方式模式的类图如下所示模板方法中的方法可以分为两大类：模板方法和基本方法。模板方法，一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"深入理解jvm虚拟机","slug":"yuque/深入理解jvm虚拟机","date":"2015-05-03T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/understanding-jvm.json","excerpt":"> 每个 Java 开发者都知道 Java> 字节码是执行在 JRE(（Java> Runtime Environment> Java 运行时环境）上的。JRE> 中最重要的部分是 Java> 虚拟机（JVM），JVM 负责分析和执行> Java 字节码。Java> 开发人员并不需要去关心 JVM> 是如何运行的。在没有深入理解 JVM> 的情况下，许多开发者已经开发出了非常多的优秀的应用以及> Java 类库。不过，如果你了解 JVM> 的话，你会更加了解 Java> 的，并且你会轻松解决那些看似简单但是无从下手的问题。本系列主要从以下几个方面进行分析1、Jav","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JDK设计模式（十二）策略模式","slug":"yuque/JDK设计模式（十二）策略模式","date":"2015-04-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-strategy-pattern.json","excerpt":"1、定义策略模式，又叫算法簇模式，就是定义了不同的算法族，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。2、解决的问题可以动态的改变对象的行为。3、模式中的角色1、环境对象(context)：该类中实现了对抽象策略中定义的接口或者抽象类的引用。2、抽象策略对象(Strategy)：它可由接口或抽象类来实现。3、具体策略对象(ConcreteStrategy)：它封装了实现同不功能的不同算法。利用策略模式构建应用程序，可以根据用户配置等内容，选择不同有算法来实现应用程序的功能。具体的选择有环境对象来完成。采用这种方式可以避免由于使用条件语句而带来的代","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}]}