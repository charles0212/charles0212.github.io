{"total":102,"pageSize":10,"pageCount":11,"data":[{"title":"JVM（四）类文件结构解析","slug":"yuque/JVM（四）类文件结构解析","date":"2016-07-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-class.json","excerpt":"Java Class 文件结构如下图所示对于以下 java 源文件代码public class Charles implements ICharles{  private String name;  public void say() {    System.out.println(\"charles\");  }  public String getName() {    return name;  }  public void setName(String name) {    this.name = name;  }}生成的类文件字节码为根据 cla","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（三）内存分配与回收策略","slug":"yuque/JVM（三）内存分配与回收策略","date":"2016-07-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-gc-allocation.json","excerpt":"对象的分配的细节取决于当前使用哪一种垃圾收集器组合，以及和内存相关参数有关，本文主要讨论Serial/SerialOld收集器的内存分配和回收的策略，其他几种垃圾收集器可以自己去探讨。先介绍下 MinorGC 和FullGC 的概念。新生代 GC（MinorGC）:发生在新生代，Java对象大多都有朝生夕死的特性，MinorGC非常频繁，回收速度也比较快。老年代GC（MajorGC/FullGC）:发生在老年代，出现 MajorGC经常至少伴随一次的MinorGC，但非绝对。MajorGC的速度一般比 MinorGC 慢 10倍以上。下面是最普遍的内存分配规则","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"Service Mesh概述","slug":"yuque/Service Mesh概述","date":"2016-06-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/cncf/service-mesh.json","excerpt":"> 关于 ServiceMesh> 相关知识和进展，推荐资深大牛敖小剑的相关文章> https://skyao.io/> ServiceMesh 的社区网站> http://www.servicemesher.com/> 最近蚂蚁金服开源了分布式框架> SOFA，项目地址> Alipay，具体文档可见 Sofa> 关于 Sofa Mesh,> 暂时未开源，相关选型介绍可见 Sofa> Mesh一、 Service Mesh概念与定义这个概念首先由 Linkerd的团队提出，其官方定义是:> A service mesh is a> dedicated>","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"cncf","path":"api/categories/cncf.json"}],"tags":[{"name":"CNCF","path":"api/tags/CNCF.json"},{"name":"ServiceMesh","path":"api/tags/ServiceMesh.json"}]},{"title":"Cloud Native定义","slug":"yuque/Cloud Native定义","date":"2016-05-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/cncf/cloud-native.json","excerpt":"CNCF 定义CNCF（Cloud NativeComputingFoundation，云原生计算基金会），2016年 6 月 11 日，CNCF技术监督委员会经过几个月的讨论，终于投票通过了Cloud Native的定义，目前官方的翻译如下：> Cloud native> technologies empower> organizations to> build and run> scalable> applications in> modern, dynamic> environments such as> public, private, and> ","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"cncf","path":"api/categories/cncf.json"}],"tags":[{"name":"CNCF","path":"api/tags/CNCF.json"}]},{"title":"JVM（二）垃圾收集算法与收集器","slug":"yuque/JVM（二）垃圾收集算法与收集器","date":"2016-01-08T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-gc.json","excerpt":"Java 堆中几乎存放着 java中所有的对象实例，垃圾收集器在对堆进行回收前，需要确定哪些对象还”存活”着，哪些已经“死去”。垃圾回收必须能够完成两件事情：正确检测出垃圾对象；释放垃圾对象占用的空间。1、垃圾检测算法当前常见的检测垃圾的方法包括两种：1.引用计数法；2. 可达性分析算法。1.1 引用计数算法（ReferenceCounting）给对象添加一个引用计数器，每当该对象被引用，它的计数器值就＋1；当引用失效时，计数器就－1；在任何情况下，当计数器值为0 时，就表示该对象不再被使用。缺点：它很难解决对象之间相互引用，引起的循环引用问题，会产生无法被释放","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（一）Java内存区域与内存溢出","slug":"yuque/JVM（一）Java内存区域与内存溢出","date":"2016-01-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/java-oom.json","excerpt":"Java 内存区域Java虚拟机所管理的内存将包括以下几个运行时数据区域，如下图所示：程序计数器ProgramCounterRegister是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变程序计数器的值来选取下一条要执行的字节码指令，分支、循环、跳转、异常跳转、线程恢复等基础功能都需要依赖这个计数器来完成。由于 Java虚拟机的多线程时通过线程切换并分配处理器执行时间来实现的，对于单核处理器在某一个时间都只会有一个线程在运行，为了线程切换后能恢复到正确的执行位置，每个线程都需要维护一个独立的程序计数器，各个线程之","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JDK设计模式（十七）命令模式","slug":"yuque/JDK设计模式（十七）命令模式","date":"2015-11-15T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-command-pattern.json","excerpt":"1、概述命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。2、解决的问题用于“行为请求者”与“行为实现者”解耦，可实现二者之间的松耦合，以便适应变化。3、模式中的角色1、命令（Command）角色：定义命令的接口，声明执行的方法。2、具体命令（ConcreteCommand）角色：命令接口实现对象，通常它会持有命令的接收者，通过调用接收者相应的功能方法来执行当前命令所要完成的操作。3、接收者（Receiver）角色：真正执行命令的对象。任何类都可以成为一个接收者，只要它能够实现命令要求实现的相应功能即可。4","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十六）责任链模式","slug":"yuque/JDK设计模式（十六）责任链模式","date":"2015-11-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-responsibility-pattern.json","excerpt":"1、概述责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。2、解决的问题如果有多个对象都有可能接受请求，可以避免请求发送者与接收者耦合在一起。3、模式中的角色1、抽象处理者角色(Handler):定义一个处理请求的接口，和一个后继连接(可选)2、具体处理者角色(ConcreteHandler):处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。3、客户类(Client):向一个链上的具体处理者ConcreteHandler对象提","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十五）迭代器模式","slug":"yuque/JDK设计模式（十五）迭代器模式","date":"2015-11-12T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-iterator-pattern.json","excerpt":"1. 概述迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。2. 解决的问题把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所。3. 模式中的角色1、抽象迭代器(Iterator)：定义出遍历元素所需的接口。2、具体迭代器(ConcreteIterator)：实现Iterator接口，并保持迭代过程中的游标位置。3、聚集(Aggregate)：给出创建迭代器(Iterator)对象的接口。4、具体聚集(ConcreteAggregate)：实现创建迭代器(Iterator)对象的接口，返回一个合适","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十四）观察者模式","slug":"yuque/JDK设计模式（十四）观察者模式","date":"2015-11-06T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-observer-pattern.json","excerpt":"1. 概述有时被称作发布/订阅模式，观察者模式定义了对象之间的一对多的依赖关系，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。2. 解决的问题将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。3. 模式中的角色1、抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。2、具体主题（ConcreteS","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}]}