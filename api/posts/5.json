{"total":102,"pageSize":10,"pageCount":11,"data":[{"title":"HBase （一）系统架构","slug":"yuque/HBase （一）系统架构","date":"2020-06-20T16:00:00.000Z","updated":"2022-04-05T16:46:48.000Z","comments":true,"path":"api/articles/hbase/hbase-architecture.json","excerpt":"本文基本是对 MapR 的官网文章AnIn-Depth Look at theHBaseArchitecture的翻译HBase 存储架构HBase 采用Master/Slave架构搭建集群，它隶属于 Hadoop生态系统，由一下类型节点组成：HMaster节点、HRegionServer节点、ZooKeeper集群，而在底层，它将数据存储于 HDFS中，因而涉及到 HDFS 的NameNode、DataNode等，总体结构如下：HMaster 节点 * 管理   HRegionServer，实现其负载均衡。 * 管理和分配 HRegion，比","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"hbase","path":"api/categories/hbase.json"}],"tags":[{"name":"HBase","path":"api/tags/HBase.json"}]},{"title":"HBase（一）系统架构","slug":"yuque/HBase（一）系统架构","date":"2020-06-20T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/hbase/hbase-architecture.json","excerpt":"本文基本是对 MapR 的官网文章AnIn-Depth Look at theHBaseArchitecture的翻译HBase 存储架构HBase 采用Master/Slave架构搭建集群，它隶属于 Hadoop生态系统，由一下类型节点组成：HMaster节点、HRegionServer节点、ZooKeeper集群，而在底层，它将数据存储于 HDFS中，因而涉及到 HDFS 的NameNode、DataNode等，总体结构如下：HMaster 节点 * 管理   HRegionServer，实现其负载均衡。 * 管理和分配 HRegion，比","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"hbase","path":"api/categories/hbase.json"}],"tags":[{"name":"HBase","path":"api/tags/HBase.json"}]},{"title":"发号器","slug":"yuque/发号器","date":"2020-06-20T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/id-generator/id-generator.json","excerpt":"为什么需要一个发号器在使用数据库时，表的主键经常会使用数据库的自增（auto_increment）来产生。这当然很方便也很高效。但是使用自增也会带来一些麻烦。如果从一个数据库以外的地方，也就是发号器来产生全局唯一ID，这些问题就可以得到解决，生活就可以更美好。 * 难以适应分片场景在采用数据库分片时，如果使用数据库自增   ID，不同分片上会产生相同的 ID。单靠   ID   无法唯一标示一个对象，还需要额外加上分片字段才行。如果需要将   ID   用于其他对象的关联时，会麻烦很多。而采用发号器生成的是全局唯一的   ID，单靠 ID   就能实现关联。同时，这也使","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"id-generator","path":"api/categories/id-generator.json"}],"tags":[{"name":"IdGenerator","path":"api/tags/IdGenerator.json"}]},{"title":"架构（二）秒杀架构设计","slug":"yuque/架构（二）秒杀架构设计","date":"2020-05-21T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/architecture/architecture-miaosha.json","excerpt":"秒杀业务与难点秒杀业务在各业务中已然非常流行，这里我将互联网行业中的秒杀定义为：在非常短的时间内，将一件商品分成多份进行购买的行为。微信抢红包、一元夺宝、双11大促抢购等业务本质上都可视作秒杀业务。而最近大热的抢红包的难度在于这是和钱打交道的秒杀场景，对于事务的要求性更高。秒杀业务优化的难点或者说痛点在于：同一件商品在同一时间段内有非常多的用户去进行抢夺，从而造成服务器资源的紧张。非秒杀情况下，比如非大促的时候，用户购买的体验都是非常不错的。但是在秒杀场景下，这时意味着多个用户在同时抢一件商品，也就是并发很高，但集中在同一商品上，造成实质为串行操作。因为在数据库这层本质执行的是","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"architecture","path":"api/categories/architecture.json"}],"tags":[{"name":"Architecture","path":"api/tags/Architecture.json"}]},{"title":"架构（一）架构师技能和微服务架构图谱","slug":"yuque/架构（一）架构师技能和微服务架构图谱","date":"2020-05-20T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/architecture/architecture-skill.json","excerpt":"架构师技能图谱平时学习的知识比较零散，没有做系统的归类和整理，通过下面的图，可以系统的学习。补充不太熟悉知识，做到查漏补缺。微服务架构图谱","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"architecture","path":"api/categories/architecture.json"}],"tags":[{"name":"Architecture","path":"api/tags/Architecture.json"}]},{"title":"常用架构分析","slug":"yuque/常用架构分析","date":"2020-05-19T16:00:00.000Z","updated":"2022-09-09T13:07:16.840Z","comments":true,"path":"api/articles/architecture/architecture.json","excerpt":"常用架构分析常用经典架构分析，了解设计思路和注意问题1、架构师技能和微服务架构图谱2、秒杀架构设计3、通用可编排订单状态机引擎设计4、架构设计参考规范","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"architecture","path":"api/categories/architecture.json"}],"tags":[{"name":"Architecture","path":"api/tags/Architecture.json"}]},{"title":"Shell（二）分支和主干jar差异","slug":"yuque/Shell（二）分支和主干jar差异","date":"2019-07-20T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/shell/jar-diff.json","excerpt":"分支和主干 jar 差异脚本文件见附件，可以快速了解本次分支修改，便于发布前比对当前的开发分支和主干jar 差异情况。 将jar-diff.sh放在根目录文件下面。#!/bin/bash# 获取当前git分支CURRENT_BRANCH=`sh -c 'git branch --no-color 2>/dev/null' | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/\\1/'`if [ -n \"$CURRENT_BRANCH\" ]; then# 当前分支不为空APP_NAME=`cat .git/config | grep url | sed","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"shell","path":"api/categories/shell.json"}],"tags":[{"name":"Shell","path":"api/tags/Shell.json"}]},{"title":"Shell常用命令","slug":"yuque/Shell常用命令","date":"2019-06-20T16:00:00.000Z","updated":"2022-04-02T16:49:05.000Z","comments":true,"path":"api/articles/shell/shell-command.json","excerpt":"find + xargs将当前目录下.bak的文件，移动到临时/tmp 下面find . -name \"*.bak\" | xargs -I '{}' mv {} /tmp移动到/tmp 临时目录下，不要使用rm -rf 命令防止误删，其中-I‘{}’标识占位符awk分隔字符串，排序grep charles /home/zhangcheng.log | awk '{split($0,a,\",\");if (index(a[11],\"5000000000013\") > 0 || index(a[11],\"5000000000059\") > 0) print subst","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"shell","path":"api/categories/shell.json"}],"tags":[{"name":"Shell","path":"api/tags/Shell.json"}]},{"title":"Shell（一）常用命令","slug":"yuque/Shell（一）常用命令","date":"2019-06-20T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/shell/shell-command.json","excerpt":"find + xargs将当前目录下.bak的文件，移动到临时/tmp 下面find . -name \"*.bak\" | xargs -I '{}' mv {} /tmp移动到/tmp 临时目录下，不要使用rm -rf 命令防止误删，其中-I‘{}’标识占位符awk分隔字符串，排序grep charles /home/zhangcheng.log | awk '{split($0,a,\",\");if (index(a[11],\"5000000000013\") > 0 || index(a[11],\"5000000000059\") > 0) print subst","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"shell","path":"api/categories/shell.json"}],"tags":[{"name":"Shell","path":"api/tags/Shell.json"}]},{"title":"短链生成","slug":"yuque/短链生成","date":"2019-06-20T16:00:00.000Z","updated":"2022-09-04T14:05:03.095Z","comments":true,"path":"api/articles/url/short-url.json","excerpt":"背景当前短地址发号使用 hbase 的increament 指令,每个转短请求都会做一次操作, 当 qps超过 1k 时, 会造成 hbase机器报警, 需要减少 hbase 的increament 指令调用方案修改为每个请求在本地取号,当本地无号可取时请求 hbase 发号,每次在 hbase 中调用increament 时取 100个号, 回到本地具体代码流程 * 加全局锁,   所有转短请求在取号前通过全局锁串行 * 尝试本地取号, 如果不成功, 去   hbase 取号 100 个,   放入本地缓存 * 解锁, 并继续原有转短流程","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"short-url","path":"api/categories/short-url.json"}],"tags":[{"name":"ShortUrl","path":"api/tags/ShortUrl.json"}]}]}