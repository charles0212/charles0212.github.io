{"total":102,"pageSize":10,"pageCount":11,"data":[{"title":"JDK设计模式（十三）模板方法模式","slug":"yuque/JDK设计模式（十三）模板方法模式","date":"2015-10-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-template-method-pattern.json","excerpt":"1、概述定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。2、模式中的角色抽象模板类（AbstractTemplate）：实现了模板方法，定义了算法的骨架。具体模板类（ConcreteTemplate)：实现抽象类中的抽象方法，已完成完整的算法。3、模式解读模板方式模式的类图如下所示模板方法中的方法可以分为两大类：模板方法和基本方法。模板方法，一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"深入理解jvm虚拟机","slug":"yuque/深入理解jvm虚拟机","date":"2015-05-03T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/understanding-jvm.json","excerpt":"> 每个 Java 开发者都知道 Java> 字节码是执行在 JRE(（Java> Runtime Environment> Java 运行时环境）上的。JRE> 中最重要的部分是 Java> 虚拟机（JVM），JVM 负责分析和执行> Java 字节码。Java> 开发人员并不需要去关心 JVM> 是如何运行的。在没有深入理解 JVM> 的情况下，许多开发者已经开发出了非常多的优秀的应用以及> Java 类库。不过，如果你了解 JVM> 的话，你会更加了解 Java> 的，并且你会轻松解决那些看似简单但是无从下手的问题。本系列主要从以下几个方面进行分析1、Jav","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JDK设计模式（十二）策略模式","slug":"yuque/JDK设计模式（十二）策略模式","date":"2015-04-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-strategy-pattern.json","excerpt":"1、定义策略模式，又叫算法簇模式，就是定义了不同的算法族，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。2、解决的问题可以动态的改变对象的行为。3、模式中的角色1、环境对象(context)：该类中实现了对抽象策略中定义的接口或者抽象类的引用。2、抽象策略对象(Strategy)：它可由接口或抽象类来实现。3、具体策略对象(ConcreteStrategy)：它封装了实现同不功能的不同算法。利用策略模式构建应用程序，可以根据用户配置等内容，选择不同有算法来实现应用程序的功能。具体的选择有环境对象来完成。采用这种方式可以避免由于使用条件语句而带来的代","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十一）代理模式","slug":"yuque/JDK设计模式（十一）代理模式","date":"2015-04-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-proxy-pattern.json","excerpt":"1、定义为另一个对象提供一个替身或占位符以控制对这个对象的访问。2、解决的问题在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，提供额外的处理或者不同的操作。3、模式中的角色1、抽象主题角色(Subject)：声明真实对象和代理对象的共同接口；2、代理角色(Proxy)：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。3、真实主题角色(RealSub","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十）享元模式","slug":"yuque/JDK设计模式（十）享元模式","date":"2015-04-12T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-flyweight-pattern.json","excerpt":"1、定义采用一个共享来避免大量拥有相同内容对象的开销。2、解决的问题使用共享物件，用来尽可能减少内存使用量，以及分享资讯给尽可能多的相似物件；适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。3、模式中的角色内蕴状态存储在享元内部，不会随环境的改变而有所不同，是可以共享的；外蕴状态是不可以共享的，它随环境的改变而改变的，因此外蕴状态是由客户端来保持（因为环境的变化是由客户端引起的）。在每个具体的环境下，客户端将外蕴状态传递给享元，从而创建不同的对象出来。享元模式可分为：单纯享元模式和复合享元模式。1、抽象享元角色(Flyweight)：为具体享元角色规定","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（九）外观模式","slug":"yuque/JDK设计模式（九）外观模式","date":"2015-04-12T03:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-facade-pattern.json","excerpt":"1、定义提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易访问。2、解决的问题通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，降低应用程序的复杂度，并且提高了程序的可维护性。封装一组交互类，一致地对外提供接口，简化子系统调用。3、模式中的角色1、外观角色（Facade）：是模式的核心，他被客户client角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订几种功能组合。2、子系统角色（Subsystemclasses）：实现子系统的功能，并处理由Facade对象指派的任务。对子系统而言，fa","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（八）装饰模式","slug":"yuque/JDK设计模式（八）装饰模式","date":"2015-04-12T02:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-decorator-pattern.json","excerpt":"1、定义动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。2、解决的问题在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象，防止类继承带来的爆炸式增长。3、模式中的角色1、抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。2、具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。3、装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。4、具体装饰(C","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（七）组合模式","slug":"yuque/JDK设计模式（七）组合模式","date":"2015-04-12T01:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-composite-pattern.json","excerpt":"1、定义将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。2、解决的问题组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以像处理简单元素一样来处理复杂元素。3、模式中的角色1、抽象构件（component）:是组合中对象的接口，适当情况下，实现所有类共有方法的默认行为，声明一个接口，用于管理和访问component 子部件2、树枝构件（composite）：定义具有叶节点的组件的行为3、叶子构件（leaf）：定义叶节点的行为4、 客户角色（client）：使用component 接口操作组件行","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（六）桥接模式","slug":"yuque/JDK设计模式（六）桥接模式","date":"2015-04-12T01:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-bridge-pattern.json","excerpt":"1、定义将抽象部分与实现部分分离，使它们都可以独立的变化2、解决的问题某个类具有两个或两个以上的维度变化，如果只是用继承将无法实现这种需要，或者使得设计变得相当臃肿，把变化部分抽象出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要，从达到抽象化、实现化和脱耦。3、模式中的角色1、抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。2、修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。3、实现化(Imple","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（五）适配器模式","slug":"yuque/JDK设计模式（五）适配器模式","date":"2015-04-12T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-adapter-pattern.json","excerpt":"1、定义将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。2、解决的问题即 Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。3、模式中的角色目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。需要适配的类（Adaptee）：需要适配的类或适配者类。适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。4、模式解读在 GoF的设计模式中，对适配器模式讲了两种类型，类适配器模式和对象适配器模式。由于","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]}]}