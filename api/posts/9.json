{"total":98,"pageSize":10,"pageCount":10,"data":[{"title":"JDK设计模式（十）享元模式","slug":"yuque/JDK设计模式（十）享元模式","date":"2015-04-12T16:00:00.000Z","updated":"2022-05-15T04:19:28.492Z","comments":true,"path":"api/articles/design-pattern/jdk-flyweight-pattern.json","excerpt":"1、定义采用一个共享来避免大量拥有相同内容对象的开销。2、解决的问题使用共享物件，用来尽可能减少内存使用量，以及分享资讯给尽可能多的相似物件；适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。3、模式中的角色内蕴状态存储在享元内部，不会随环境的改变而有所不同，是可以共享的；外蕴状态是不可以共享的，它随环境的改变而改变的，因此外蕴状态是由客户端来保持（因为环境的变化是由客户端引起的）。在每个具体的环境下，客户端将外蕴状态传递给享元，从而创建不同的对象出来。享元模式可分为：单纯享元模式和复合享元模式。1、抽象享元角色(Flyweight)：为具体享元角色规定","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（九）外观模式","slug":"yuque/JDK设计模式（九）外观模式","date":"2015-04-12T03:00:00.000Z","updated":"2022-05-15T04:19:28.492Z","comments":true,"path":"api/articles/design-pattern/jdk-facade-pattern.json","excerpt":"1、定义提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易访问。2、解决的问题通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，降低应用程序的复杂度，并且提高了程序的可维护性。封装一组交互类，一致地对外提供接口，简化子系统调用。3、模式中的角色1、外观角色（Facade）：是模式的核心，他被客户client角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订几种功能组合。2、子系统角色（Subsystemclasses）：实现子系统的功能，并处理由Facade对象指派的任务。对子系统而言，fa","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（八）装饰模式","slug":"yuque/JDK设计模式（八）装饰模式","date":"2015-04-12T02:00:00.000Z","updated":"2022-05-15T04:19:28.492Z","comments":true,"path":"api/articles/design-pattern/jdk-decorator-pattern.json","excerpt":"1、定义动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。2、解决的问题在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象，防止类继承带来的爆炸式增长。3、模式中的角色1、抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。2、具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。3、装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。4、具体装饰(C","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（七）组合模式","slug":"yuque/JDK设计模式（七）组合模式","date":"2015-04-12T01:00:00.000Z","updated":"2022-05-15T04:19:28.492Z","comments":true,"path":"api/articles/design-pattern/jdk-composite-pattern.json","excerpt":"1、定义将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。2、解决的问题组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以像处理简单元素一样来处理复杂元素。3、模式中的角色1、抽象构件（component）:是组合中对象的接口，适当情况下，实现所有类共有方法的默认行为，声明一个接口，用于管理和访问component 子部件2、树枝构件（composite）：定义具有叶节点的组件的行为3、叶子构件（leaf）：定义叶节点的行为4、 客户角色（client）：使用component 接口操作组件行","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（六）桥接模式","slug":"yuque/JDK设计模式（六）桥接模式","date":"2015-04-12T01:00:00.000Z","updated":"2022-05-15T04:19:28.493Z","comments":true,"path":"api/articles/design-pattern/jdk-bridge-pattern.json","excerpt":"1、定义将抽象部分与实现部分分离，使它们都可以独立的变化2、解决的问题某个类具有两个或两个以上的维度变化，如果只是用继承将无法实现这种需要，或者使得设计变得相当臃肿，把变化部分抽象出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要，从达到抽象化、实现化和脱耦。3、模式中的角色1、抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。2、修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。3、实现化(Imple","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（五）适配器模式","slug":"yuque/JDK设计模式（五）适配器模式","date":"2015-04-12T00:00:00.000Z","updated":"2022-05-15T04:19:28.493Z","comments":true,"path":"api/articles/design-pattern/jdk-adapter-pattern.json","excerpt":"1、定义将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。2、解决的问题即 Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。3、模式中的角色目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。需要适配的类（Adaptee）：需要适配的类或适配者类。适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。4、模式解读在 GoF的设计模式中，对适配器模式讲了两种类型，类适配器模式和对象适配器模式。由于","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（四）原型模式","slug":"yuque/JDK设计模式（四）原型模式","date":"2015-03-08T00:00:00.000Z","updated":"2022-05-15T04:19:28.493Z","comments":true,"path":"api/articles/design-pattern/jdk-prototype-pattern.json","excerpt":"用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。在原型模式中，所发动创建的对象通过请求原型对象来拷贝原型对象自己来实现创建过程，当然所发动创建的对象需要知道原型对象的类型。这里也就是说所发动创建的对象只需要知道原型对象的类型就可以获得更多的原型实例对象，至于这些原型对象时如何创建的根本不需要关心，其类图如下所示。原型模式主要包含如下三个角色： * Prototype：抽象原型类。声明克隆自身的接口。 * ConcretePrototype：具体原型类。实现克隆的具体操作。 * Client：客户类。让一个原型克隆自身，从而获得一个新的对象。讲到原型模式，我们就","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"Java引用类型","slug":"yuque/Java引用类型","date":"2015-02-28T16:00:00.000Z","updated":"2022-05-15T04:19:28.488Z","comments":true,"path":"api/articles/java/java-reference.json","excerpt":"内存回收每一个 Java程序中的对象都会占用一定的计算机资源，最常见的，如：每个对象都会在堆空间上申请一定的内存空间。但是除了内存之外，对象还会占用其它资源，如文件句柄，端口，socket等等。当你创建一个对象的时候，必须保证它在销毁的时候会释放它占用的资源。否则程序将会在OOM 中结束它的使命。在 Java中数据内存分配发生在栈和堆中，对于栈中的变量（引用类型，基本类型）会在方法的退出时自动释放，对于new出来对象分配到堆中，不需要程序员来管理内存的分配和释放，Java有自动进行内存管理的神器——垃圾回收器，垃圾回收器会自动回收那些不再使用的对象。那如何判断对象不再使用呢","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Java锁（五）CyclicBarrier分析","slug":"yuque/Java锁（五）CyclicBarrier分析","date":"2015-02-07T16:00:00.000Z","updated":"2022-05-15T04:19:28.499Z","comments":true,"path":"api/articles/java/java-cyclicbarrier.json","excerpt":"CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(intparties)，其参数表示屏障拦截的线程数量，每个线程调用await 方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。1、CyclicBarrier 使用实例public class CyclicBarrierTest {    stati","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（四）ConditionObject分析","slug":"yuque/Java锁（四）ConditionObject分析","date":"2015-02-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.499Z","comments":true,"path":"api/articles/java/java-conditionobject.json","excerpt":"在讲 ConditionObject之前，先讲解下条件队列。条件队列能够使得一组线程能够通过某种方式来等待特定的条件变成真，条件队列中的成员是一个个正在等待状态的线程。条件队列提供了一种挂起方式，当现场等待的条件非真时，挂起自己并释放锁，一旦等待条件为真，则立即醒来。条件队列主要功能1、隐式锁对应的条件队列对象的内置锁（synchronized语义对应的同步机制），关联着一个内置的条件队列。Object的wait/notify/notifyAll等方法构成了内部条件队列的API（即将内部锁与内部条件队列关联的机制）。内部条件队列是需要内置锁保护的，需要调用对象X","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]}]}