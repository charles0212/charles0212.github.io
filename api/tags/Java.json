{"name":"Java","postlist":[{"title":"Disruptor（一）RingBuffer数据结构","slug":"yuque/Disruptor（一）RingBuffer数据结构","date":"2016-09-19T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer.json","excerpt":"> Disruptor 是 LMAX> 公司开源的一个高效的内存无锁队列。并发程序设计几个概念1、锁：锁是用来做并发最简单的方式，当然其代价也是最高的。内核态的锁的时候需要操作系统进行一次上下文切换，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。用户态的锁虽然避免了这些问题，但是其实它们只是在没有真实的竞争时才有效。2、CAS： CAS的涵义不多介绍了。使用 CAS时不像上锁那样需要一次上下文切换，但是也需要处理器锁住它的指令流水线来保证原子性，并且还要加上Memory Barrier来保证其结果可见。3","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（三）RingBuffer单生产者写入","slug":"yuque/Disruptor（三）RingBuffer单生产者写入","date":"2017-02-15T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-single-write.json","excerpt":"上一章主要介绍了消费者从RingBuffer读取数据，本章主要介绍单个生产者如何向RingBuffer 数据写入数据。在RingBuffer数据写入过程中如何不要让 Ring重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作。在 RingBuffer写入数据的过程涉及到两阶段提交(two-phasecommit)1）生产者需要申请 buffer里的下一个节点。2）当生产者向节点写完数据，需要调用调用publish 发布数据。1、单个生产者SingleProducerSequencer数据写入在后台由ProducerSequencer","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（二）RingBuffer读取","slug":"yuque/Disruptor（二）RingBuffer读取","date":"2016-12-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-read.json","excerpt":"上一章主要介绍 Ring Buffer的数据结构，本章主要讲解如何使用Disruptor 从 RingBuffer 中读取数据。1、消费者通过ProcessingSequenceBarrier读取数据能够读取数据的前提是数据已经写入到Ring Buffer中，关于数据的写入，后面一章节会详细讲解。RingBuffer 的元素的大小是 2的 n 次方（上面ringBufferSize 为8，从序号 0开始）。消费者(Consumer)是一个想从RingBuffer里读取数据的线程，它可以通过访问ProcessingSequenceBarrier对象和 ","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（五）DSL相关实战","slug":"yuque/Disruptor（五）DSL相关实战","date":"2017-03-09T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-practise.json","excerpt":"本文主要讲解使用 Disruptor 的DSL演示生产者和消费者的数据交换，和以往的线程间通信不同，disruptor使用消息传递的方式，通过RingBuffer进行线程间的数据传递和通信，下面分别从一对一和多对一的模型进行讲解。下面主要通过计算区间[0 ,100000000)中的所有数值相加为例子讲解Disruptor 中的 dsl 使用。1、一对一一个生产者和一个消费者之间进行数据传递，使用disruptor 主要涉及到RingBuffer 中的ValueEvent定义，ValueAdditionEventHandler消费者处理，以及生产者发布。","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Disruptor（四）RingBuffer多生产者写入","slug":"yuque/Disruptor（四）RingBuffer多生产者写入","date":"2017-03-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/disruptor-ringbuffer-muti-write.json","excerpt":"上一章主要介绍了单个生产者如何向RingBuffer数据写入数据，如何不要让 Ring重叠，写入后通知消费者，生产者一端的批处理，以及多个生产者如何协同工作，本章主要介绍多生产者向RingBuffer 数据写入数据。1、多生产者MultiProducerSequencer申请下一个节点和单生产者不同的是在 next方法中会直接通过cursor.compareAndSet(current,next)设置生产者的游标 cursor的sequence。大家很可能会问设置了生产者的游标后，没有提交数据之前，多生产者场景中消费者是否就能够获取到数据，答案是否定的，在M","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"JDK中的设计模式","slug":"yuque/JDK中的设计模式","date":"2015-01-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-design-pattern.json","excerpt":"本文主要是归纳了 JDK中所包含的设计模式，包括作用和其设计类图。一、设计模式的作用 1. 反复出现问题的解决方案 2. 增强软件的灵活性 3. 适应软件不断变化二、设计模式的七大原则 1. 开闭原则 OCP（Open Close    Principle），一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 2. 里氏代换原则 LSP（Liskov    Substitution    Principle），子类可以扩展父类的功能，但不能改变父类原有的功能 3. 依赖倒转原则    DIP（Dependence    Inversion    ","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（一）单例模式","slug":"yuque/JDK设计模式（一）单例模式","date":"2015-01-17T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-singleton-pattern.json","excerpt":"单例模式确保一个类只有一个实例，并提供一个全局访问点。其类图如下所示。本文主要从饿汉式，懒汉式，懒汉式改进，来讲解单例模式。1、饿汉式单例饿汉式单例类是在 Java语言里实现得最为简便的单例类。在类被加载时，就会将自己实例化。public class Singleton {    private static Singleton uniqueInstance = new Singleton();    private Singleton() {        // Exists only to defeat instantiation.    }    publ","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（七）组合模式","slug":"yuque/JDK设计模式（七）组合模式","date":"2015-04-12T01:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-composite-pattern.json","excerpt":"1、定义将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。2、解决的问题组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以像处理简单元素一样来处理复杂元素。3、模式中的角色1、抽象构件（component）:是组合中对象的接口，适当情况下，实现所有类共有方法的默认行为，声明一个接口，用于管理和访问component 子部件2、树枝构件（composite）：定义具有叶节点的组件的行为3、叶子构件（leaf）：定义叶节点的行为4、 客户角色（client）：使用component 接口操作组件行","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（三）建造者模式","slug":"yuque/JDK设计模式（三）建造者模式","date":"2015-01-19T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-builder-pattern.json","excerpt":"将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心，其类图如下。建造者角色Product :产品类，由多个部件构成。class Product {    List parts = new ArrayList();    public void AddPart(String part) {        parts.add(part);    }    public void sho","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（九）外观模式","slug":"yuque/JDK设计模式（九）外观模式","date":"2015-04-12T03:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-facade-pattern.json","excerpt":"1、定义提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易访问。2、解决的问题通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，降低应用程序的复杂度，并且提高了程序的可维护性。封装一组交互类，一致地对外提供接口，简化子系统调用。3、模式中的角色1、外观角色（Facade）：是模式的核心，他被客户client角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订几种功能组合。2、子系统角色（Subsystemclasses）：实现子系统的功能，并处理由Facade对象指派的任务。对子系统而言，fa","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（二）工厂模式","slug":"yuque/JDK设计模式（二）工厂模式","date":"2015-01-18T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-factory-pattern.json","excerpt":"工厂模式是我们最常用的实例化对象模式，使用工厂方法代替new操作的一种模式，使用工厂模式，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。1、简单工厂模式简单工厂模式是属于创建型模式，又叫做静态工厂方法（StaticFactoryMethod）模式，但不属于 23 种GOF 设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。使","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（五）适配器模式","slug":"yuque/JDK设计模式（五）适配器模式","date":"2015-04-12T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-adapter-pattern.json","excerpt":"1、定义将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。2、解决的问题即 Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。3、模式中的角色目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。需要适配的类（Adaptee）：需要适配的类或适配者类。适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。4、模式解读在 GoF的设计模式中，对适配器模式讲了两种类型，类适配器模式和对象适配器模式。由于","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（八）装饰模式","slug":"yuque/JDK设计模式（八）装饰模式","date":"2015-04-12T02:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-decorator-pattern.json","excerpt":"1、定义动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。2、解决的问题在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象，防止类继承带来的爆炸式增长。3、模式中的角色1、抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。2、具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。3、装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。4、具体装饰(C","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（六）桥接模式","slug":"yuque/JDK设计模式（六）桥接模式","date":"2015-04-12T01:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-bridge-pattern.json","excerpt":"1、定义将抽象部分与实现部分分离，使它们都可以独立的变化2、解决的问题某个类具有两个或两个以上的维度变化，如果只是用继承将无法实现这种需要，或者使得设计变得相当臃肿，把变化部分抽象出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要，从达到抽象化、实现化和脱耦。3、模式中的角色1、抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。2、修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。3、实现化(Imple","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十一）代理模式","slug":"yuque/JDK设计模式（十一）代理模式","date":"2015-04-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-proxy-pattern.json","excerpt":"1、定义为另一个对象提供一个替身或占位符以控制对这个对象的访问。2、解决的问题在某些情况下，一个对象不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，提供额外的处理或者不同的操作。3、模式中的角色1、抽象主题角色(Subject)：声明真实对象和代理对象的共同接口；2、代理角色(Proxy)：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。3、真实主题角色(RealSub","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十七）命令模式","slug":"yuque/JDK设计模式（十七）命令模式","date":"2015-11-15T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-command-pattern.json","excerpt":"1、概述命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。2、解决的问题用于“行为请求者”与“行为实现者”解耦，可实现二者之间的松耦合，以便适应变化。3、模式中的角色1、命令（Command）角色：定义命令的接口，声明执行的方法。2、具体命令（ConcreteCommand）角色：命令接口实现对象，通常它会持有命令的接收者，通过调用接收者相应的功能方法来执行当前命令所要完成的操作。3、接收者（Receiver）角色：真正执行命令的对象。任何类都可以成为一个接收者，只要它能够实现命令要求实现的相应功能即可。4","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十二）策略模式","slug":"yuque/JDK设计模式（十二）策略模式","date":"2015-04-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-strategy-pattern.json","excerpt":"1、定义策略模式，又叫算法簇模式，就是定义了不同的算法族，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。2、解决的问题可以动态的改变对象的行为。3、模式中的角色1、环境对象(context)：该类中实现了对抽象策略中定义的接口或者抽象类的引用。2、抽象策略对象(Strategy)：它可由接口或抽象类来实现。3、具体策略对象(ConcreteStrategy)：它封装了实现同不功能的不同算法。利用策略模式构建应用程序，可以根据用户配置等内容，选择不同有算法来实现应用程序的功能。具体的选择有环境对象来完成。采用这种方式可以避免由于使用条件语句而带来的代","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十三）模板方法模式","slug":"yuque/JDK设计模式（十三）模板方法模式","date":"2015-10-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-template-method-pattern.json","excerpt":"1、概述定义一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。2、模式中的角色抽象模板类（AbstractTemplate）：实现了模板方法，定义了算法的骨架。具体模板类（ConcreteTemplate)：实现抽象类中的抽象方法，已完成完整的算法。3、模式解读模板方式模式的类图如下所示模板方法中的方法可以分为两大类：模板方法和基本方法。模板方法，一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十五）迭代器模式","slug":"yuque/JDK设计模式（十五）迭代器模式","date":"2015-11-12T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-iterator-pattern.json","excerpt":"1. 概述迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。2. 解决的问题把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所。3. 模式中的角色1、抽象迭代器(Iterator)：定义出遍历元素所需的接口。2、具体迭代器(ConcreteIterator)：实现Iterator接口，并保持迭代过程中的游标位置。3、聚集(Aggregate)：给出创建迭代器(Iterator)对象的接口。4、具体聚集(ConcreteAggregate)：实现创建迭代器(Iterator)对象的接口，返回一个合适","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十六）责任链模式","slug":"yuque/JDK设计模式（十六）责任链模式","date":"2015-11-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-responsibility-pattern.json","excerpt":"1、概述责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。2、解决的问题如果有多个对象都有可能接受请求，可以避免请求发送者与接收者耦合在一起。3、模式中的角色1、抽象处理者角色(Handler):定义一个处理请求的接口，和一个后继连接(可选)2、具体处理者角色(ConcreteHandler):处理它所负责的请求，可以访问后继者，如果可以处理请求则处理，否则将该请求转给他的后继者。3、客户类(Client):向一个链上的具体处理者ConcreteHandler对象提","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十四）观察者模式","slug":"yuque/JDK设计模式（十四）观察者模式","date":"2015-11-06T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-observer-pattern.json","excerpt":"1. 概述有时被称作发布/订阅模式，观察者模式定义了对象之间的一对多的依赖关系，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。2. 解决的问题将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。3. 模式中的角色1、抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。2、具体主题（ConcreteS","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（十）享元模式","slug":"yuque/JDK设计模式（十）享元模式","date":"2015-04-12T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-flyweight-pattern.json","excerpt":"1、定义采用一个共享来避免大量拥有相同内容对象的开销。2、解决的问题使用共享物件，用来尽可能减少内存使用量，以及分享资讯给尽可能多的相似物件；适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。3、模式中的角色内蕴状态存储在享元内部，不会随环境的改变而有所不同，是可以共享的；外蕴状态是不可以共享的，它随环境的改变而改变的，因此外蕴状态是由客户端来保持（因为环境的变化是由客户端引起的）。在每个具体的环境下，客户端将外蕴状态传递给享元，从而创建不同的对象出来。享元模式可分为：单纯享元模式和复合享元模式。1、抽象享元角色(Flyweight)：为具体享元角色规定","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JDK设计模式（四）原型模式","slug":"yuque/JDK设计模式（四）原型模式","date":"2015-03-08T00:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/design-pattern/jdk-prototype-pattern.json","excerpt":"用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。在原型模式中，所发动创建的对象通过请求原型对象来拷贝原型对象自己来实现创建过程，当然所发动创建的对象需要知道原型对象的类型。这里也就是说所发动创建的对象只需要知道原型对象的类型就可以获得更多的原型实例对象，至于这些原型对象时如何创建的根本不需要关心，其类图如下所示。原型模式主要包含如下三个角色： * Prototype：抽象原型类。声明克隆自身的接口。 * ConcretePrototype：具体原型类。实现克隆的具体操作。 * Client：客户类。让一个原型克隆自身，从而获得一个新的对象。讲到原型模式，我们就","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"design-pattern","path":"api/categories/design-pattern.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"设计模式","path":"api/tags/设计模式.json"}]},{"title":"JVM（一）Java内存区域与内存溢出","slug":"yuque/JVM（一）Java内存区域与内存溢出","date":"2016-01-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/java-oom.json","excerpt":"Java 内存区域Java虚拟机所管理的内存将包括以下几个运行时数据区域，如下图所示：程序计数器ProgramCounterRegister是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变程序计数器的值来选取下一条要执行的字节码指令，分支、循环、跳转、异常跳转、线程恢复等基础功能都需要依赖这个计数器来完成。由于 Java虚拟机的多线程时通过线程切换并分配处理器执行时间来实现的，对于单核处理器在某一个时间都只会有一个线程在运行，为了线程切换后能恢复到正确的执行位置，每个线程都需要维护一个独立的程序计数器，各个线程之","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（七）深入理解java内存模型","slug":"yuque/JVM（七）深入理解java内存模型","date":"2016-08-06T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/java-memory-model.json","excerpt":"> java> 线程之间的通信对程序员完全透明，内存可见性问题很容易困扰> java 程序员，本文试图揭开 java> 内存模型神秘的面纱。本文大致分三部分：重排序与顺序一致性；三个同步原语（lock，volatile，final）的内存语义，重排序规则及在处理器中的实现；java内存模型的设计目标，及其与处理器内存模型和顺序一致性内存模型的关系。 * 深入理解 java   内存模型（一）——基础 * 深入理解 java   内存模型（二）——重排序 * 深入理解 java   内存模型（三）——顺序一致性 * 深入理解 java   内存模型（四）——v","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（三）内存分配与回收策略","slug":"yuque/JVM（三）内存分配与回收策略","date":"2016-07-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-gc-allocation.json","excerpt":"对象的分配的细节取决于当前使用哪一种垃圾收集器组合，以及和内存相关参数有关，本文主要讨论Serial/SerialOld收集器的内存分配和回收的策略，其他几种垃圾收集器可以自己去探讨。先介绍下 MinorGC 和FullGC 的概念。新生代 GC（MinorGC）:发生在新生代，Java对象大多都有朝生夕死的特性，MinorGC非常频繁，回收速度也比较快。老年代GC（MajorGC/FullGC）:发生在老年代，出现 MajorGC经常至少伴随一次的MinorGC，但非绝对。MajorGC的速度一般比 MinorGC 慢 10倍以上。下面是最普遍的内存分配规则","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（二）垃圾收集算法与收集器","slug":"yuque/JVM（二）垃圾收集算法与收集器","date":"2016-01-08T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-gc.json","excerpt":"Java 堆中几乎存放着 java中所有的对象实例，垃圾收集器在对堆进行回收前，需要确定哪些对象还”存活”着，哪些已经“死去”。垃圾回收必须能够完成两件事情：正确检测出垃圾对象；释放垃圾对象占用的空间。1、垃圾检测算法当前常见的检测垃圾的方法包括两种：1.引用计数法；2. 可达性分析算法。1.1 引用计数算法（ReferenceCounting）给对象添加一个引用计数器，每当该对象被引用，它的计数器值就＋1；当引用失效时，计数器就－1；在任何情况下，当计数器值为0 时，就表示该对象不再被使用。缺点：它很难解决对象之间相互引用，引起的循环引用问题，会产生无法被释放","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（五）虚拟机类加载机制","slug":"yuque/JVM（五）虚拟机类加载机制","date":"2016-08-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-classloader.json","excerpt":"Java提供了动态的装载特性；它会在运行时的第一次引用到一个class的时候对它进行装载和链接，而不是在编译期进行。JVM的类装载器负责动态装载，基本上所有的类加载器都是java.lang.ClassLoader类的一个实例。Java 类装载器有如下几个特点： * 层级结构：Java   里的类装载器被组织成了有父子关系的层级结构。Bootstrap   类装载器是所有装载器的父亲。 * 代理模式：基于层级结构，类的装载可以在装载器之间进行代理。当装载器装载一个类时，首先会检查它是否在父装载器中进行装载了。如果上层的装载器已经装载了这个类，这个类会被直接使用。反","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"JVM（六）虚拟机类加载委派模型","slug":"yuque/JVM（六）虚拟机类加载委派模型","date":"2016-08-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-classloader-delegate.json","excerpt":"双亲委派模型当一个类装载器（classloader）被请求装载类时，它首先按照顺序在上层装载器、父装载器以及自身的装载器的缓存里检查这个类是否已经存在。简单来说，就是在缓存里查看这个类是否已经被自己装载过了，如果没有的话，继续查找父类的缓存，直到在bootstrap类装载器里也没有找到的话，它就会自己在文件系统里去查找并且加载这个类。ClassLoader 的loadClass 方法protected Class loadClass(String name, boolean resolve)            throws ClassNotFoundExcepti","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"Java并发编程之锁","slug":"yuque/Java并发编程之锁","date":"2015-01-31T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-lock.json","excerpt":"> 作为一个 java> 开发者，并发编程是不可或缺的，在并发的过程，Lock> 是并发的关键，> 本文主要从排它锁和共享锁的实例来讲解锁的机制。本文主要从以下方面来讲解锁的原理及使用： 1. AbstractQueuedSynchronizer    分析 2. ReentrantLock 独占锁分析 3. CountDownLatch 共享锁分析 4. ConditionObject 分析 5. CyclicBarrier 分析","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"JVM（四）类文件结构解析","slug":"yuque/JVM（四）类文件结构解析","date":"2016-07-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/jvm-class.json","excerpt":"Java Class 文件结构如下图所示对于以下 java 源文件代码public class Charles implements ICharles{  private String name;  public void say() {    System.out.println(\"charles\");  }  public String getName() {    return name;  }  public void setName(String name) {    this.name = name;  }}生成的类文件字节码为根据 cla","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]},{"title":"Java引用类型","slug":"yuque/Java引用类型","date":"2015-02-28T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-reference.json","excerpt":"内存回收每一个 Java程序中的对象都会占用一定的计算机资源，最常见的，如：每个对象都会在堆空间上申请一定的内存空间。但是除了内存之外，对象还会占用其它资源，如文件句柄，端口，socket等等。当你创建一个对象的时候，必须保证它在销毁的时候会释放它占用的资源。否则程序将会在OOM 中结束它的使命。在 Java中数据内存分配发生在栈和堆中，对于栈中的变量（引用类型，基本类型）会在方法的退出时自动释放，对于new出来对象分配到堆中，不需要程序员来管理内存的分配和释放，Java有自动进行内存管理的神器——垃圾回收器，垃圾回收器会自动回收那些不再使用的对象。那如何判断对象不再使用呢","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Java锁（三）CountDownLatch共享锁分析","slug":"yuque/Java锁（三）CountDownLatch共享锁分析","date":"2015-02-04T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-countdownlatch.json","excerpt":"> 在开始解读 AQS> 的共享功能前，我们再重温一下> CountDownLatch，CountDownLatch> 为> java.util.concurrent> 包下的计数器工具类，常被用在多线程环境下，它在初始时需要指定一个计数器的大小，然后可被多个线程并发的实现减> 1 操作，并在计数器为 0 后调用> await> 方法的线程被唤醒，从而实现多线程间的协作。1、闭锁使用class Driver2 {    void main() throws InterruptedException {        CountDownLatch doneSigna","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（一）AQS分析","slug":"yuque/Java锁（一）AQS分析","date":"2015-02-01T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-aqs.json","excerpt":"> 作为一个 java> 开发者，并发编程是不可或缺的，在并发的过程，Lock> 是并发的关键。本系列文章主要来讲解锁的原理和机制。在理解 J.U.C原理以及锁机制之前，我们来介绍J.U.C框架最核心也是最复杂的一个基础类：java.util.concurrent.locks.AbstractQueuedSynchronizer。上面的继承体系中，AbstractQueuedSynchronizer是CountDownLatch/Semaphore/RenntrantReadWriteLock/Worker/ReentrantLock的基础，因此AbstractQ","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（五）CyclicBarrier分析","slug":"yuque/Java锁（五）CyclicBarrier分析","date":"2015-02-07T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-cyclicbarrier.json","excerpt":"CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(intparties)，其参数表示屏障拦截的线程数量，每个线程调用await 方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。1、CyclicBarrier 使用实例public class CyclicBarrierTest {    stati","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（二）ReentrantLock独占锁分析","slug":"yuque/Java锁（二）ReentrantLock独占锁分析","date":"2015-02-02T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-reentrantlock.json","excerpt":"ReentrantLock的功能是实现代码段的并发访问控制，是一种排它锁，也就是通常意义上所说的锁，内部有两种实现NonfairSync 和FairSync，公平锁和非公平锁，默认采用非公平锁策略。ReentrantLock的实现不仅可以替代隐式的synchronized关键字，而且能够提供超过关键字本身的多种功能。1、ReentrantLock 的使用class X {  private final ReentrantLock lock = new ReentrantLock();  // ...  public void m() {    lock.lock","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Java锁（四）ConditionObject分析","slug":"yuque/Java锁（四）ConditionObject分析","date":"2015-02-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/java/java-conditionobject.json","excerpt":"在讲 ConditionObject之前，先讲解下条件队列。条件队列能够使得一组线程能够通过某种方式来等待特定的条件变成真，条件队列中的成员是一个个正在等待状态的线程。条件队列提供了一种挂起方式，当现场等待的条件非真时，挂起自己并释放锁，一旦等待条件为真，则立即醒来。条件队列主要功能1、隐式锁对应的条件队列对象的内置锁（synchronized语义对应的同步机制），关联着一个内置的条件队列。Object的wait/notify/notifyAll等方法构成了内部条件队列的API（即将内部锁与内部条件队列关联的机制）。内部条件队列是需要内置锁保护的，需要调用对象X","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Lock","path":"api/tags/Lock.json"}]},{"title":"Spock 基于BDD测试","slug":"yuque/Spock 基于BDD测试","date":"2018-07-14T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/spock.json","excerpt":"> Spock 测试框架基于 Groovy> 并吸收了> Junit、TestNG、Mockito> 等测试框架的优点。 Spock> 编写的单元测试层次清晰，代码量少，可读性好，Groovy> 最终会编译为 class> 文件，支持各种集成开发环境（eclipse，Intellij> Ieda）， 尤其是 Intellij> idea 已经集成支持 Groovy> 的插件，也支持> maven-surefire-plugin、jacoco> 等 maven 插件。Spock 官网，必读书籍《JavaTesting with Spock》,如要速成只需要阅读以下","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"spock","path":"api/categories/spock.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Spock","path":"api/tags/Spock.json"}]},{"title":"深入理解Disruptor","slug":"yuque/深入理解Disruptor","date":"2016-09-05T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/disruptor/understanding-disruptor.json","excerpt":"> Disruptor 是 LMAX> 公司开源的一个高效的内存无锁队列，一个高性能的异步处理框架，或者可以认为是最快的消息框架(轻量的> JMS)，也可以认为是一个观察者模式实现，或者事件-监听模式的实现，直接称> disruptor> 模式。disruptor> 最大特点是高性能，其 LMAX> 架构可以获得每秒 6 百万订单，用 1> 微秒的延迟获得吞吐量为 100K+。理解> Disruptor> 的原理，可以帮助我们更好的理解内存无锁，CAS，volatile，缓冲行等并发原理。本文主要从以下方面介绍disruptor：1、Disruptor 概念和Rin","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"disruptor","path":"api/categories/disruptor.json"}],"tags":[{"name":"Disruptor","path":"api/tags/Disruptor.json"},{"name":"Java","path":"api/tags/Java.json"}]},{"title":"深入理解jvm虚拟机","slug":"yuque/深入理解jvm虚拟机","date":"2015-05-03T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/jvm/understanding-jvm.json","excerpt":"> 每个 Java 开发者都知道 Java> 字节码是执行在 JRE(（Java> Runtime Environment> Java 运行时环境）上的。JRE> 中最重要的部分是 Java> 虚拟机（JVM），JVM 负责分析和执行> Java 字节码。Java> 开发人员并不需要去关心 JVM> 是如何运行的。在没有深入理解 JVM> 的情况下，许多开发者已经开发出了非常多的优秀的应用以及> Java 类库。不过，如果你了解 JVM> 的话，你会更加了解 Java> 的，并且你会轻松解决那些看似简单但是无从下手的问题。本系列主要从以下几个方面进行分析1、Jav","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"jvm","path":"api/categories/jvm.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"JVM","path":"api/tags/JVM.json"}]}]}