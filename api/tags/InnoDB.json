{"name":"InnoDB","postlist":[{"title":"InnoDB中的页合并与分裂","slug":"yuque/InnoDB中的页合并与分裂","date":"2019-03-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-page-merge-and-split.json","excerpt":"原文链接：https://www.percona.com/blog/2017/04/10/innodb-page-merging-and-page-splitting/https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/如果您遇到了全球（为数不多的）MySQL顾问之一并要求他/她审查您的查询和/或模式，我相信他/她会告诉您有关良好主键设计的重要性的一些信息.特别是在 InnoDB的情况下，我相信他们已经开始向","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]},{"title":"MVCC多版本并发控制","slug":"yuque/MVCC多版本并发控制","date":"2019-05-24T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-mvcc.json","excerpt":"https://cloud.tencent.com/developer/article/1488871https://zhuanlan.zhihu.com/p/40208895https://blog.csdn.net/u014532775/article/details/107018538https://www.jianshu.com/p/0ef46997c300https://blog.csdn.net/fuzhongmin05/article/details/91351933redolog 和 undologhttps://www.cnblogs.com/f-ck-need","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]},{"title":"MySQL B+树深度的了解","slug":"yuque/MySQL B+树深度的了解","date":"2019-05-26T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-btree-depth.json","excerpt":"> https://zhuanlan.zhihu.com/p/444448405以下从B+树深度简单模拟计算，有两个主要特征决定了B 树（或 B+ 树）的深度。 1. 数据库中的行数。我们将其称为 N。 2. 索引键的大小。让我们称 B 为适合 B    树节点的键数。（有时 B    用于指代节点大小本身，而不是它持有的键数，但我希望这样看起来更直观。）给定这些数量，B 树的深度是 log B为下标 N。那只是 (log N)/logB。现在我们可以注意到小键意味着更大的B，这会减少 (log N )/logB。如果我们将键的字节大小减半，那么 B树的深度将","keywords":null,"cover":["/images/c2.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]},{"title":"MySQL事务redo和undo日志","slug":"yuque/MySQL事务redo和undo日志","date":"2022-02-14T16:00:00.000Z","updated":"2022-09-09T14:42:08.640Z","comments":true,"path":"api/articles/mysql/mysql-redo-and-undo-log.json","excerpt":"> 事务有 4> 种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？ * 事务的隔离性由锁机制实现。 * 事务的原子性、一致性和持久性由事务的   redo 日志和 undo 日志来保证。   * redo log     称为重做日志，提供再写入操作，恢复提交事务修改的页操作(我们对数据进行修改，数据会报存在内存中，此时还没有保存在磁盘当中，如果此时由于不可抗因素如宕机，事务将不能保证持久性。而     redo log     就阔以保证了，我们在修改完数据之后，将相关的数据保存到     redo log     中，就算出现宕机我","keywords":null,"cover":["/images/c3.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]},{"title":"MySQL表碎片","slug":"yuque/MySQL表碎片","date":"2019-05-25T16:00:00.000Z","updated":"2022-05-15T04:19:28.000Z","comments":true,"path":"api/articles/mysql/mysql-table-fragmentation.json","excerpt":"> 原文链接：> https://www.percona.com/blog/2020/06/24/mysql-table-fragmentation-beware-of-bulk-insert-with-failure-or-rollback/当心批量插入失败或者回滚时带来的MySQL 表碎片，通常，DBA都了解使用 DELETE语句会产生表碎片。在大多数情况下，当执行大量的删除时，DBA总会重新构建表以回收磁盘空间。但是，您是否认为只有删除才会导致表碎片？（答案：并不是）。在这篇博文中，我将解释插入如何会带来碎片。在讨论这个主题之前，我们需要了解MySQL，有两种碎片：","keywords":null,"cover":["/images/c1.jpg"],"content":null,"raw":null,"categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","path":"api/tags/Mysql.json"},{"name":"InnoDB","path":"api/tags/InnoDB.json"}]}]}